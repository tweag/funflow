-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A hashing class for content-addressed storage
--   
--   A hashing class for content-addressed storage. Content can be hashed
--   either by value or through an IO action. Part of the funflow
--   ecosystem.
@package cas-hashable
@version 1.0.1


-- | <a>ContentHashable</a> provides a hashing function suitable for use in
--   the Funflow content store.
--   
--   This behaves as does a normal hashing function on Haskell types.
--   However, on path types, this instead calculates a hash based on the
--   contents of the file or directory referenced.
--   
--   We also export the <a>ExternallyAssuredFile</a> and
--   <a>ExternallyAssuredDirectory</a> types. These instead use the path,
--   file size and modification time to control the hash.
module Data.CAS.ContentHashable
data ContentHash
toBytes :: ContentHash -> ByteString
fromBytes :: ByteString -> Maybe ContentHash
class Monad m => ContentHashable m a

-- | Update a hash context based on the given value.
--   
--   See <a>hashUpdate</a>.
--   
--   XXX: Consider swapping the arguments.
contentHashUpdate :: ContentHashable m a => Context SHA256 -> a -> m (Context SHA256)

-- | Update a hash context based on the given value.
--   
--   See <a>hashUpdate</a>.
--   
--   XXX: Consider swapping the arguments.
contentHashUpdate :: (ContentHashable m a, Generic a, GContentHashable m (Rep a)) => Context SHA256 -> a -> m (Context SHA256)

-- | Generate hash of the given value.
--   
--   See <a>hash</a>.
contentHash :: ContentHashable m a => a -> m ContentHash

-- | Update hash context based on binary contents of the given file.
contentHashUpdate_binaryFile :: Context SHA256 -> FilePath -> IO (Context SHA256)

-- | Update hash context based on <a>ByteArray#</a> by copying into a newly
--   allocated <a>Bytes</a> and updating the hash context from there.
--   
--   XXX: <tt><a>byteArrayContents#</a> :: <a>ByteArray#</a> -&gt;
--   <a>Addr#</a></tt> could be used together with <a>MemView</a> instead.
--   However, <a>byteArrayContents#</a> explicitly says, that it is only
--   safe to use on a pinned <a>ByteArray#</a>.
contentHashUpdate_byteArray# :: ByteArray# -> Int -> Int -> Context SHA256 -> Context SHA256

-- | Update hash context based on a type's <a>Fingerprint</a>.
--   
--   The fingerprint is constructed from the library-name, module-name, and
--   name of the type itself.
contentHashUpdate_fingerprint :: (Monad m, Typeable a) => Context SHA256 -> a -> m (Context SHA256)

-- | Update hash context by combining <a>contentHashUpdate_fingerprint</a>
--   and <a>contentHashUpdate_storable</a>. Intended for primitive types
--   like <a>Int</a>.
contentHashUpdate_primitive :: (Monad m, Typeable a, Storable a) => Context SHA256 -> a -> m (Context SHA256)

-- | Update hash context based on binary in memory representation due to
--   <a>Storable</a>.
--   
--   XXX: Do we need to worry about endianness?
contentHashUpdate_storable :: (Monad m, Storable a) => Context SHA256 -> a -> m (Context SHA256)

-- | Path to a regular file
--   
--   Only the file's content and its executable permission is taken into
--   account when generating the content hash. The path itself is ignored.
newtype FileContent
FileContent :: Path Abs File -> FileContent

-- | Path to a directory
--   
--   Only the contents of the directory and their path relative to the
--   directory are taken into account when generating the content hash. The
--   path to the directory is ignored.
newtype DirectoryContent
DirectoryContent :: Path Abs Dir -> DirectoryContent

-- | Path to a file to be treated as _externally assured_.
--   
--   An externally assured file is handled in a somewhat <tt>cheating</tt>
--   way by funflow. The <a>ContentHashable</a> instance for such assumes
--   that some external agent guarantees the integrity of the file being
--   referenced. Thus, rather than hashing the file contents, we only
--   consider its (absolute) path, size and modification time, which can be
--   rapidly looked up from filesystem metadata.
--   
--   For a similar approach, see the instance for <tt>ObjectInBucket</tt>
--   in Data.CAS.ContentHashable.S3 (in `cas-hashable-s3` package), where
--   we exploit the fact that S3 is already content hashed to avoid
--   performing any hashing.
newtype ExternallyAssuredFile
ExternallyAssuredFile :: Path Abs File -> ExternallyAssuredFile

-- | Path to a directory to be treated as _externally assured_.
--   
--   For an externally assured directory, we _do_ traverse its contents and
--   verify those as we would externally assured files, rather than just
--   relying on the directory path. Doing this traversal is pretty cheap,
--   and it's quite likely for directory contents to be modified without
--   modifying the contents.
--   
--   If an item in the directory cannot be read due to lacking permissions,
--   then it will be ignored and not included in the hash. If the flow does
--   not have permissions to access the contents of a subdirectory, then
--   these contents cannot influence the outcome of a task and it is okay
--   to exclude them from the hash. In that case we only hash the name, as
--   that could influence the outcome of a task.
newtype ExternallyAssuredDirectory
ExternallyAssuredDirectory :: Path Abs Dir -> ExternallyAssuredDirectory

-- | File path appropriate encoding of a hash
encodeHash :: ContentHash -> ByteString

-- | Inverse of <a>encodeHash</a> if given a valid input.
--   
--   <pre>
--   decodeHash (encodeHash x) = Just x
--   </pre>
decodeHash :: ByteString -> Maybe ContentHash

-- | File path appropriate encoding of a hash
hashToPath :: ContentHash -> Path Rel Dir

-- | Inverse of <a>hashToPath</a> if given a valid input.
--   
--   <pre>
--   pathToHash (hashToPath x) = Just x
--   </pre>
pathToHash :: FilePath -> Maybe ContentHash

-- | SHA256 cryptographic hash algorithm
data SHA256

-- | Represent a context for a given hash algorithm.
data Context a

-- | Represent a digest for a given hash algorithm.
--   
--   This type is an instance of <a>ByteArrayAccess</a> from package
--   <a>memory</a>. Module <a>Data.ByteArray</a> provides many primitives
--   to work with those values including conversion to other types.
--   
--   Creating a digest from a bytearray is also possible with function
--   <a>digestFromByteString</a>.
data Digest a
instance GHC.Show.Show Data.CAS.ContentHashable.ExternallyAssuredDirectory
instance GHC.Generics.Generic Data.CAS.ContentHashable.ExternallyAssuredDirectory
instance GHC.Show.Show Data.CAS.ContentHashable.ExternallyAssuredFile
instance GHC.Generics.Generic Data.CAS.ContentHashable.ExternallyAssuredFile
instance GHC.Generics.Generic Data.CAS.ContentHashable.ContentHash
instance GHC.Classes.Ord Data.CAS.ContentHashable.ContentHash
instance GHC.Classes.Eq Data.CAS.ContentHashable.ContentHash
instance Data.Aeson.Types.FromJSON.FromJSON Data.CAS.ContentHashable.ExternallyAssuredDirectory
instance Data.Aeson.Types.ToJSON.ToJSON Data.CAS.ContentHashable.ExternallyAssuredDirectory
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Data.CAS.ContentHashable.ExternallyAssuredDirectory
instance Data.Aeson.Types.FromJSON.FromJSON Data.CAS.ContentHashable.ExternallyAssuredFile
instance Data.Aeson.Types.ToJSON.ToJSON Data.CAS.ContentHashable.ExternallyAssuredFile
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Data.CAS.ContentHashable.ExternallyAssuredFile
instance Control.Monad.IO.Class.MonadIO m => Data.CAS.ContentHashable.ContentHashable m Data.CAS.ContentHashable.DirectoryContent
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Data.CAS.ContentHashable.FileContent
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Fingerprint.Type.Fingerprint
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Bool
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Char
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Int
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Int.Int8
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Int.Int16
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Int.Int32
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Int.Int64
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Word
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Word.Word8
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Word.Word16
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Word.Word32
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Word.Word64
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Float
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Types.Double
instance (Data.CAS.ContentHashable.ContentHashable m n, Data.Typeable.Internal.Typeable n) => Data.CAS.ContentHashable.ContentHashable m (GHC.Real.Ratio n)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.Scientific.Scientific
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m GHC.Natural.Natural
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.ByteString.Internal.ByteString
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.ByteString.Lazy.Internal.ByteString
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.Text.Internal.Text
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.Text.Internal.Lazy.Text
instance (Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable v, Data.CAS.ContentHashable.ContentHashable m k, Data.CAS.ContentHashable.ContentHashable m v) => Data.CAS.ContentHashable.ContentHashable m (Data.Map.Internal.Map k v)
instance (Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable v, Data.CAS.ContentHashable.ContentHashable m k, Data.CAS.ContentHashable.ContentHashable m v) => Data.CAS.ContentHashable.ContentHashable m (Data.HashMap.Base.HashMap k v)
instance (Data.Typeable.Internal.Typeable v, Data.CAS.ContentHashable.ContentHashable m v) => Data.CAS.ContentHashable.ContentHashable m (Data.HashSet.Base.HashSet v)
instance (Data.Typeable.Internal.Typeable a, Data.CAS.ContentHashable.ContentHashable m a) => Data.CAS.ContentHashable.ContentHashable m [a]
instance (Data.Typeable.Internal.Typeable a, Data.CAS.ContentHashable.ContentHashable m a) => Data.CAS.ContentHashable.ContentHashable m (GHC.Base.NonEmpty a)
instance (Data.Typeable.Internal.Typeable a, Data.CAS.ContentHashable.ContentHashable m a) => Data.CAS.ContentHashable.ContentHashable m (Data.Vector.Vector a)
instance (Data.Typeable.Internal.Typeable a, Foreign.Storable.Storable a, Data.CAS.ContentHashable.ContentHashable m a) => Data.CAS.ContentHashable.ContentHashable m (Data.Vector.Storable.Vector a)
instance (Data.Typeable.Internal.Typeable a, Data.Vector.Unboxed.Base.Unbox a, Data.CAS.ContentHashable.ContentHashable m a) => Data.CAS.ContentHashable.ContentHashable m (Data.Vector.Unboxed.Base.Vector a)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m ()
instance (Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b) => Data.CAS.ContentHashable.ContentHashable m (a, b)
instance (Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b, Data.CAS.ContentHashable.ContentHashable m c) => Data.CAS.ContentHashable.ContentHashable m (a, b, c)
instance (Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b, Data.CAS.ContentHashable.ContentHashable m c, Data.CAS.ContentHashable.ContentHashable m d) => Data.CAS.ContentHashable.ContentHashable m (a, b, c, d)
instance (Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b, Data.CAS.ContentHashable.ContentHashable m c, Data.CAS.ContentHashable.ContentHashable m d, Data.CAS.ContentHashable.ContentHashable m e) => Data.CAS.ContentHashable.ContentHashable m (a, b, c, d, e)
instance (GHC.Base.Monad m, Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b, Data.CAS.ContentHashable.ContentHashable m c, Data.CAS.ContentHashable.ContentHashable m d, Data.CAS.ContentHashable.ContentHashable m e, Data.CAS.ContentHashable.ContentHashable m f) => Data.CAS.ContentHashable.ContentHashable m (a, b, c, d, e, f)
instance (GHC.Base.Monad m, Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b, Data.CAS.ContentHashable.ContentHashable m c, Data.CAS.ContentHashable.ContentHashable m d, Data.CAS.ContentHashable.ContentHashable m e, Data.CAS.ContentHashable.ContentHashable m f, Data.CAS.ContentHashable.ContentHashable m g) => Data.CAS.ContentHashable.ContentHashable m (a, b, c, d, e, f, g)
instance Data.CAS.ContentHashable.ContentHashable m a => Data.CAS.ContentHashable.ContentHashable m (GHC.Maybe.Maybe a)
instance (Data.CAS.ContentHashable.ContentHashable m a, Data.CAS.ContentHashable.ContentHashable m b) => Data.CAS.ContentHashable.ContentHashable m (Data.Either.Either a b)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.Aeson.Types.Internal.Value
instance Data.CAS.ContentHashable.ContentHashable m c => Data.CAS.ContentHashable.GContentHashable m (GHC.Generics.K1 i c)
instance (GHC.Base.Monad m, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable t) => Data.CAS.ContentHashable.ContentHashable m (Path.Internal.Path b t)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.Time.Clock.Internal.UTCTime.UTCTime
instance GHC.Base.Monad m => Data.CAS.ContentHashable.GContentHashable m GHC.Generics.V1
instance GHC.Base.Monad m => Data.CAS.ContentHashable.GContentHashable m GHC.Generics.U1
instance (GHC.Generics.Constructor c, Data.CAS.ContentHashable.GContentHashable m f) => Data.CAS.ContentHashable.GContentHashable m (GHC.Generics.C1 c f)
instance (GHC.Generics.Datatype d, Data.CAS.ContentHashable.GContentHashable m f) => Data.CAS.ContentHashable.GContentHashable m (GHC.Generics.D1 d f)
instance Data.CAS.ContentHashable.GContentHashable m f => Data.CAS.ContentHashable.GContentHashable m (GHC.Generics.S1 s f)
instance (Data.CAS.ContentHashable.GContentHashable m a, Data.CAS.ContentHashable.GContentHashable m b) => Data.CAS.ContentHashable.GContentHashable m (a GHC.Generics.:*: b)
instance (Data.CAS.ContentHashable.GContentHashable m a, Data.CAS.ContentHashable.GContentHashable m b) => Data.CAS.ContentHashable.GContentHashable m (a GHC.Generics.:+: b)
instance Data.Aeson.Types.FromJSON.FromJSON Data.CAS.ContentHashable.ContentHash
instance Data.Aeson.Types.ToJSON.ToJSON Data.CAS.ContentHashable.ContentHash
instance Data.Hashable.Class.Hashable Data.CAS.ContentHashable.ContentHash
instance GHC.Show.Show Data.CAS.ContentHashable.ContentHash
