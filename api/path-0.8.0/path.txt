-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support for well-typed paths
--   
--   Support for well-typed paths.
@package path
@version 0.8.0


-- | Internal types and functions.
module Path.Internal

-- | Path of some base and type.
--   
--   The type variables are:
--   
--   <ul>
--   <li><tt>b</tt> — base, the base location of the path; absolute or
--   relative.</li>
--   <li><tt>t</tt> — type, whether file or directory.</li>
--   </ul>
--   
--   Internally is a string. The string can be of two formats only:
--   
--   <ol>
--   <li>File format: <tt>file.txt</tt>, <tt>foo/bar.txt</tt>,
--   <tt>/foo/bar.txt</tt></li>
--   <li>Directory format: <tt>foo/</tt>, <tt>/foo/bar/</tt></li>
--   </ol>
--   
--   All directories end in a trailing separator. There are no duplicate
--   path separators <tt>//</tt>, no <tt>..</tt>, no <tt>./</tt>, no
--   <tt>~/</tt>, etc.
newtype Path b t
Path :: FilePath -> Path b t

-- | Helper function: check if the filepath has any parent directories in
--   it. This handles the logic of checking for different path separators
--   on Windows.
hasParentDir :: FilePath -> Bool

-- | Normalized file path representation for the relative path root
relRootFP :: FilePath

-- | Convert to a <a>FilePath</a> type.
--   
--   All directories have a trailing slash, so if you want no trailing
--   slash, you can use <a>dropTrailingPathSeparator</a> from the filepath
--   package.
toFilePath :: Path b t -> FilePath
instance GHC.Generics.Generic (Path.Internal.Path b t)
instance (Data.Data.Data b, Data.Data.Data t) => Data.Data.Data (Path.Internal.Path b t)
instance GHC.Classes.Eq (Path.Internal.Path b t)
instance GHC.Classes.Ord (Path.Internal.Path b t)
instance GHC.Show.Show (Path.Internal.Path b t)
instance Control.DeepSeq.NFData (Path.Internal.Path b t)
instance Data.Aeson.Types.ToJSON.ToJSON (Path.Internal.Path b t)
instance Data.Aeson.Types.ToJSON.ToJSONKey (Path.Internal.Path b t)
instance Data.Hashable.Class.Hashable (Path.Internal.Path b t)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => Language.Haskell.TH.Syntax.Lift (Path.Internal.Path a b)


-- | This library provides a well-typed representation of paths in a
--   filesystem directory tree.
--   
--   <b>Note</b>: This module is for working with Posix style paths.
--   Importing <a>Path</a> is usually better.
--   
--   A path is represented by a number of path components separated by a
--   path separator which is a <tt>/</tt> on POSIX systems and can be a
--   <tt>/</tt> or <tt>\</tt> on Windows. The root of the tree is
--   represented by a <tt>/</tt> on POSIX and a drive letter followed by a
--   <tt>/</tt> or <tt>\</tt> on Windows (e.g. <tt>C:\</tt>). Paths can be
--   absolute or relative. An absolute path always starts from the root of
--   the tree (e.g. <tt>/x/y</tt>) whereas a relative path never starts
--   with the root (e.g. <tt>x/y</tt>). Just like we represent the notion
--   of an absolute root by "<tt>/</tt>", the same way we represent the
--   notion of a relative root by "<tt>.</tt>". The relative root denotes
--   the directory which contains the first component of a relative path.
module Path.Posix

-- | Path of some base and type.
--   
--   The type variables are:
--   
--   <ul>
--   <li><tt>b</tt> — base, the base location of the path; absolute or
--   relative.</li>
--   <li><tt>t</tt> — type, whether file or directory.</li>
--   </ul>
--   
--   Internally is a string. The string can be of two formats only:
--   
--   <ol>
--   <li>File format: <tt>file.txt</tt>, <tt>foo/bar.txt</tt>,
--   <tt>/foo/bar.txt</tt></li>
--   <li>Directory format: <tt>foo/</tt>, <tt>/foo/bar/</tt></li>
--   </ol>
--   
--   All directories end in a trailing separator. There are no duplicate
--   path separators <tt>//</tt>, no <tt>..</tt>, no <tt>./</tt>, no
--   <tt>~/</tt>, etc.
data Path b t

-- | An absolute path.
data Abs

-- | A relative path; one without a root. Note that a <tt>..</tt> path
--   component to represent the parent directory is not allowed by this
--   library.
data Rel

-- | A file path.
data File

-- | A directory path.
data Dir

-- | Path of some type. <tt>t</tt> represents the type, whether file or
--   directory. Pattern match to find whether the path is absolute or
--   relative.
data SomeBase t
Abs :: Path Abs t -> SomeBase t
Rel :: Path Rel t -> SomeBase t

-- | Exceptions that can occur during path operations.
data PathException
InvalidAbsDir :: FilePath -> PathException
InvalidRelDir :: FilePath -> PathException
InvalidAbsFile :: FilePath -> PathException
InvalidRelFile :: FilePath -> PathException
InvalidFile :: FilePath -> PathException
InvalidDir :: FilePath -> PathException
NotAProperPrefix :: FilePath -> FilePath -> PathException
HasNoExtension :: FilePath -> PathException
InvalidExtension :: String -> PathException

-- | Construct a <a>Path</a> <a>Abs</a> <a>Dir</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/|]
--   
--   [absdir|/home/chris|]
--   </pre>
--   
--   Remember: due to the nature of absolute paths a path like
--   <tt>[absdir|/home/chris|]</tt> may compile on your platform, but it
--   may not compile on another platform (Windows).
absdir :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Rel</a> <a>Dir</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/home|]&lt;/&gt;[reldir|chris|]
--   </pre>
reldir :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Abs</a> <a>File</a> using QuasiQuotes.
--   
--   <pre>
--   [absfile|/home/chris/foo.txt|]
--   </pre>
--   
--   Remember: due to the nature of absolute paths a path like
--   <tt>[absdir|/home/chris/foo.txt|]</tt> may compile on your platform,
--   but it may not compile on another platform (Windows).
absfile :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Rel</a> <a>File</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/home/chris|]&lt;/&gt;[relfile|foo.txt|]
--   </pre>
relfile :: QuasiQuoter

-- | Append two paths.
--   
--   The following cases are valid and the equalities hold:
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelDir y) = $(mkAbsDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelFile y) = $(mkAbsFile (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelDir y) = $(mkRelDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelFile y) = $(mkRelFile (x ++ "/" ++ y))
--   </pre>
--   
--   The following are proven not possible to express:
--   
--   <pre>
--   $(mkAbsFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   $(mkRelFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsFile …)
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsDir …)
--   </pre>
(</>) :: Path b Dir -> Path Rel t -> Path b t
infixr 5 </>

-- | If the directory in the first argument is a proper prefix of the path
--   in the second argument strip it from the second argument, generating a
--   path relative to the directory. Throws <a>NotAProperPrefix</a> if the
--   directory is not a proper prefix of the path.
--   
--   The following properties hold:
--   
--   <pre>
--   stripProperPrefix x (x &lt;/&gt; y) = y
--   </pre>
--   
--   Cases which are proven not possible:
--   
--   <pre>
--   stripProperPrefix (a :: Path Abs …) (b :: Path Rel …)
--   </pre>
--   
--   <pre>
--   stripProperPrefix (a :: Path Rel …) (b :: Path Abs …)
--   </pre>
--   
--   In other words the bases must match.
stripProperPrefix :: MonadThrow m => Path b Dir -> Path b t -> m (Path Rel t)

-- | Determines if the path in the first parameter is a proper prefix of
--   the path in the second parameter.
--   
--   The following properties hold:
--   
--   <pre>
--   not (x `isProperPrefixOf` x)
--   </pre>
--   
--   <pre>
--   x `isProperPrefixOf` (x &lt;/&gt; y)
--   </pre>
isProperPrefixOf :: Path b Dir -> Path b t -> Bool

-- | Take the parent path component from a path.
--   
--   The following properties hold:
--   
--   <pre>
--   parent (x &lt;/&gt; y) == x
--   parent "/x" == "/"
--   parent "x" == "."
--   </pre>
--   
--   On the root (absolute or relative), getting the parent is idempotent:
--   
--   <pre>
--   parent "/" = "/"
--   parent "." = "."
--   </pre>
parent :: Path b t -> Path b Dir

-- | Extract the file part of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   filename (p &lt;/&gt; a) == filename a
--   </pre>
filename :: Path b File -> Path Rel File

-- | Extract the last directory name of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   dirname $(mkRelDir ".") == $(mkRelDir ".")
--   </pre>
--   
--   <pre>
--   dirname (p &lt;/&gt; a) == dirname a
--   </pre>
dirname :: Path b Dir -> Path Rel Dir

-- | Add extension to given file path.
--   
--   <pre>
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo"    )
--   
--   &gt;&gt;&gt; addExtension ".foo."  $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo."   )
--   
--   &gt;&gt;&gt; addExtension ".foo.." $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo.."  )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name.bar" ) == Just $(mkRelFile "name.bar.foo")
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile ".name"    ) == Just $(mkRelFile ".name.foo"   )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name."    ) == Just $(mkRelFile "name..foo"   )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "..."      ) == Just $(mkRelFile "....foo"     )
--   </pre>
--   
--   Throws an <a>InvalidExtension</a> exception if the extension is not
--   valid. A valid extension starts with a <tt>.</tt> followed by one or
--   more characters not including <tt>.</tt> followed by zero or more
--   <tt>.</tt> in trailing position. Moreover, an extension must be a
--   valid filename, notably it cannot include path separators.
--   Particularly, <tt>.foo.bar</tt> is an invalid extension, instead you
--   have to first set <tt>.foo</tt> and then <tt>.bar</tt> individually.
--   Some examples of invalid extensions are:
--   
--   <pre>
--   &gt;&gt;&gt; addExtension "foo"      $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension "..foo"    $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension ".foo.bar" $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension ".foo/bar" $(mkRelFile "name")
--   </pre>
addExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | <a>splitExtension</a> is the inverse of <a>addExtension</a>. It splits
--   the given file path into a valid filename and a valid extension.
--   
--   <pre>
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo"     ) == Just ($(mkRelFile "name"    ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo."    ) == Just ($(mkRelFile "name"    ), ".foo." )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo.."   ) == Just ($(mkRelFile "name"    ), ".foo..")
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.bar.foo" ) == Just ($(mkRelFile "name.bar"), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile ".name.foo"    ) == Just ($(mkRelFile ".name"   ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name..foo"    ) == Just ($(mkRelFile "name."   ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "....foo"      ) == Just ($(mkRelFile "..."     ), ".foo"  )
--   </pre>
--   
--   Throws <a>HasNoExtension</a> exception if the filename does not have
--   an extension or in other words it cannot be split into a valid
--   filename and a valid extension. The following cases throw an
--   exception, please note that "." and ".." are not valid filenames:
--   
--   <pre>
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name"   )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name."  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.." )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile ".name"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "..name" )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "...name")
--   </pre>
--   
--   <a>splitExtension</a> and <a>addExtension</a> are inverses of each
--   other, the following laws hold:
--   
--   <pre>
--   uncurry addExtension . swap &gt;=&gt; splitExtension == return
--   splitExtension &gt;=&gt; uncurry addExtension . swap == return
--   </pre>
splitExtension :: MonadThrow m => Path b File -> m (Path b File, String)

-- | Get extension from given file path. Throws <a>HasNoExtension</a>
--   exception if the file does not have an extension. The following laws
--   hold:
--   
--   <pre>
--   flip addExtension file &gt;=&gt; fileExtension == return
--   fileExtension == (fmap snd) . splitExtension
--   </pre>
fileExtension :: MonadThrow m => Path b File -> m String

-- | If the file has an extension replace it with the given extension
--   otherwise add the new extension to it. Throws an
--   <a>InvalidExtension</a> exception if the new extension is not a valid
--   extension (see <a>fileExtension</a> for validity rules).
--   
--   The following law holds:
--   
--   <pre>
--   (fileExtension &gt;=&gt; flip replaceExtension file) file == return file
--   </pre>
replaceExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | Convert an absolute <a>FilePath</a> to a normalized absolute dir
--   <a>Path</a>.
--   
--   Throws: <a>InvalidAbsDir</a> when the supplied path:
--   
--   <ul>
--   <li>is not an absolute path</li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseAbsDir :: MonadThrow m => FilePath -> m (Path Abs Dir)

-- | Convert a relative <a>FilePath</a> to a normalized relative dir
--   <a>Path</a>.
--   
--   Throws: <a>InvalidRelDir</a> when the supplied path:
--   
--   <ul>
--   <li>is not a relative path</li>
--   <li>is <tt>""</tt></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   <li>is all path separators</li>
--   </ul>
parseRelDir :: MonadThrow m => FilePath -> m (Path Rel Dir)

-- | Convert an absolute <a>FilePath</a> to a normalized absolute file
--   <a>Path</a>.
--   
--   Throws: <a>InvalidAbsFile</a> when the supplied path:
--   
--   <ul>
--   <li>is not an absolute path</li>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseAbsFile :: MonadThrow m => FilePath -> m (Path Abs File)

-- | Convert a relative <a>FilePath</a> to a normalized relative file
--   <a>Path</a>.
--   
--   Throws: <a>InvalidRelFile</a> when the supplied path:
--   
--   <ul>
--   <li>is not a relative path</li>
--   <li>is <tt>""</tt></li>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseRelFile :: MonadThrow m => FilePath -> m (Path Rel File)

-- | Convert an absolute or relative <a>FilePath</a> to a normalized
--   <a>SomeBase</a> representing a directory.
--   
--   Throws: <a>InvalidDir</a> when the supplied path:
--   
--   <ul>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseSomeDir :: MonadThrow m => FilePath -> m (SomeBase Dir)

-- | Convert an absolute or relative <a>FilePath</a> to a normalized
--   <a>SomeBase</a> representing a file.
--   
--   Throws: <a>InvalidFile</a> when the supplied path:
--   
--   <ul>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseSomeFile :: MonadThrow m => FilePath -> m (SomeBase File)

-- | Convert to a <a>FilePath</a> type.
--   
--   All directories have a trailing slash, so if you want no trailing
--   slash, you can use <a>dropTrailingPathSeparator</a> from the filepath
--   package.
toFilePath :: Path b t -> FilePath

-- | Convert absolute path to directory to <a>FilePath</a> type.
fromAbsDir :: Path Abs Dir -> FilePath

-- | Convert relative path to directory to <a>FilePath</a> type.
fromRelDir :: Path Rel Dir -> FilePath

-- | Convert absolute path to file to <a>FilePath</a> type.
fromAbsFile :: Path Abs File -> FilePath

-- | Convert relative path to file to <a>FilePath</a> type.
fromRelFile :: Path Rel File -> FilePath

-- | Convert a valid directory to a <a>FilePath</a>.
fromSomeDir :: SomeBase Dir -> FilePath

-- | Convert a valid file to a <a>FilePath</a>.
fromSomeFile :: SomeBase File -> FilePath

-- | Make a <a>Path</a> <a>Abs</a> <a>Dir</a>.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsDir :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Rel</a> <a>Dir</a>.
mkRelDir :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Abs</a> <a>File</a>.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsFile :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Rel</a> <a>File</a>.
mkRelFile :: FilePath -> Q Exp

-- | Same as <a>PathException</a>.

-- | <i>Deprecated: Please use PathException instead.</i>
type PathParseException = PathException

-- | Same as <a>stripProperPrefix</a>.

-- | <i>Deprecated: Please use stripProperPrefix instead.</i>
stripDir :: MonadThrow m => Path b Dir -> Path b t -> m (Path Rel t)

-- | Same as <a>isProperPrefixOf</a>.

-- | <i>Deprecated: Please use isProperPrefixOf instead.</i>
isParentOf :: Path b Dir -> Path b t -> Bool

-- | Add extension to given file path. Throws if the resulting filename
--   does not parse.
--   
--   <pre>
--   &gt;&gt;&gt; addFileExtension "txt $(mkRelFile "foo")
--   "foo.txt"
--   
--   &gt;&gt;&gt; addFileExtension "symbols" $(mkRelFile "Data.List")
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; addFileExtension ".symbols" $(mkRelFile "Data.List")
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; addFileExtension "symbols" $(mkRelFile "Data.List.")
--   "Data.List..symbols"
--   
--   &gt;&gt;&gt; addFileExtension ".symbols" $(mkRelFile "Data.List.")
--   "Data.List..symbols"
--   
--   &gt;&gt;&gt; addFileExtension "evil/" $(mkRelFile "Data.List")
--   *** Exception: InvalidRelFile "Data.List.evil/"
--   </pre>

-- | <i>Deprecated: Please use addExtension instead.</i>
addFileExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | A synonym for <a>addFileExtension</a> in the form of an infix
--   operator. See more examples there.
--   
--   <pre>
--   &gt;&gt;&gt; $(mkRelFile "Data.List") &lt;.&gt; "symbols"
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; $(mkRelFile "Data.List") &lt;.&gt; "evil/"
--   *** Exception: InvalidRelFile "Data.List.evil/"
--   </pre>

-- | <i>Deprecated: Please use addExtension instead.</i>
(<.>) :: MonadThrow m => Path b File -> String -> m (Path b File)
infixr 7 <.>

-- | Replace/add extension to given file path. Throws if the resulting
--   filename does not parse.

-- | <i>Deprecated: Please use replaceExtension instead.</i>
setFileExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | A synonym for <a>setFileExtension</a> in the form of an operator.

-- | <i>Deprecated: Please use replaceExtension instead.</i>
(-<.>) :: MonadThrow m => Path b File -> String -> m (Path b File)
infixr 7 -<.>
instance GHC.Classes.Eq Path.Posix.PathException
instance GHC.Show.Show Path.Posix.PathException
instance GHC.Classes.Ord (Path.Posix.SomeBase t)
instance GHC.Classes.Eq (Path.Posix.SomeBase t)
instance GHC.Generics.Generic (Path.Posix.SomeBase t)
instance Control.DeepSeq.NFData (Path.Posix.SomeBase t)
instance GHC.Show.Show (Path.Posix.SomeBase t)
instance Data.Aeson.Types.ToJSON.ToJSON (Path.Posix.SomeBase t)
instance Data.Hashable.Class.Hashable (Path.Posix.SomeBase t)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Posix.SomeBase Path.Posix.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Posix.SomeBase Path.Posix.File)
instance GHC.Exception.Type.Exception Path.Posix.PathException
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Posix.Abs Path.Posix.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Posix.Rel Path.Posix.Dir)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Posix.Abs Path.Posix.Dir)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Posix.Rel Path.Posix.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Posix.Abs Path.Posix.File)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Posix.Rel Path.Posix.File)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Posix.Abs Path.Posix.File)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Posix.Rel Path.Posix.File)


-- | This library provides a well-typed representation of paths in a
--   filesystem directory tree.
--   
--   Both <a>Path.Posix</a> and <a>Path.Windows</a> provide the same
--   interface. This module will reexport the appropriate module for your
--   platform.
module Path


-- | This library provides a well-typed representation of paths in a
--   filesystem directory tree.
--   
--   <b>Note</b>: This module is for working with Windows style paths.
--   Importing <a>Path</a> is usually better.
--   
--   A path is represented by a number of path components separated by a
--   path separator which is a <tt>/</tt> on POSIX systems and can be a
--   <tt>/</tt> or <tt>\</tt> on Windows. The root of the tree is
--   represented by a <tt>/</tt> on POSIX and a drive letter followed by a
--   <tt>/</tt> or <tt>\</tt> on Windows (e.g. <tt>C:\</tt>). Paths can be
--   absolute or relative. An absolute path always starts from the root of
--   the tree (e.g. <tt>/x/y</tt>) whereas a relative path never starts
--   with the root (e.g. <tt>x/y</tt>). Just like we represent the notion
--   of an absolute root by "<tt>/</tt>", the same way we represent the
--   notion of a relative root by "<tt>.</tt>". The relative root denotes
--   the directory which contains the first component of a relative path.
module Path.Windows

-- | Path of some base and type.
--   
--   The type variables are:
--   
--   <ul>
--   <li><tt>b</tt> — base, the base location of the path; absolute or
--   relative.</li>
--   <li><tt>t</tt> — type, whether file or directory.</li>
--   </ul>
--   
--   Internally is a string. The string can be of two formats only:
--   
--   <ol>
--   <li>File format: <tt>file.txt</tt>, <tt>foo/bar.txt</tt>,
--   <tt>/foo/bar.txt</tt></li>
--   <li>Directory format: <tt>foo/</tt>, <tt>/foo/bar/</tt></li>
--   </ol>
--   
--   All directories end in a trailing separator. There are no duplicate
--   path separators <tt>//</tt>, no <tt>..</tt>, no <tt>./</tt>, no
--   <tt>~/</tt>, etc.
data Path b t

-- | An absolute path.
data Abs

-- | A relative path; one without a root. Note that a <tt>..</tt> path
--   component to represent the parent directory is not allowed by this
--   library.
data Rel

-- | A file path.
data File

-- | A directory path.
data Dir

-- | Path of some type. <tt>t</tt> represents the type, whether file or
--   directory. Pattern match to find whether the path is absolute or
--   relative.
data SomeBase t
Abs :: Path Abs t -> SomeBase t
Rel :: Path Rel t -> SomeBase t

-- | Exceptions that can occur during path operations.
data PathException
InvalidAbsDir :: FilePath -> PathException
InvalidRelDir :: FilePath -> PathException
InvalidAbsFile :: FilePath -> PathException
InvalidRelFile :: FilePath -> PathException
InvalidFile :: FilePath -> PathException
InvalidDir :: FilePath -> PathException
NotAProperPrefix :: FilePath -> FilePath -> PathException
HasNoExtension :: FilePath -> PathException
InvalidExtension :: String -> PathException

-- | Construct a <a>Path</a> <a>Abs</a> <a>Dir</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/|]
--   
--   [absdir|/home/chris|]
--   </pre>
--   
--   Remember: due to the nature of absolute paths a path like
--   <tt>[absdir|/home/chris|]</tt> may compile on your platform, but it
--   may not compile on another platform (Windows).
absdir :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Rel</a> <a>Dir</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/home|]&lt;/&gt;[reldir|chris|]
--   </pre>
reldir :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Abs</a> <a>File</a> using QuasiQuotes.
--   
--   <pre>
--   [absfile|/home/chris/foo.txt|]
--   </pre>
--   
--   Remember: due to the nature of absolute paths a path like
--   <tt>[absdir|/home/chris/foo.txt|]</tt> may compile on your platform,
--   but it may not compile on another platform (Windows).
absfile :: QuasiQuoter

-- | Construct a <a>Path</a> <a>Rel</a> <a>File</a> using QuasiQuotes.
--   
--   <pre>
--   [absdir|/home/chris|]&lt;/&gt;[relfile|foo.txt|]
--   </pre>
relfile :: QuasiQuoter

-- | Append two paths.
--   
--   The following cases are valid and the equalities hold:
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelDir y) = $(mkAbsDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkAbsDir x) &lt;/&gt; $(mkRelFile y) = $(mkAbsFile (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelDir y) = $(mkRelDir (x ++ "/" ++ y))
--   </pre>
--   
--   <pre>
--   $(mkRelDir x) &lt;/&gt; $(mkRelFile y) = $(mkRelFile (x ++ "/" ++ y))
--   </pre>
--   
--   The following are proven not possible to express:
--   
--   <pre>
--   $(mkAbsFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   $(mkRelFile …) &lt;/&gt; x
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsFile …)
--   </pre>
--   
--   <pre>
--   x &lt;/&gt; $(mkAbsDir …)
--   </pre>
(</>) :: Path b Dir -> Path Rel t -> Path b t
infixr 5 </>

-- | If the directory in the first argument is a proper prefix of the path
--   in the second argument strip it from the second argument, generating a
--   path relative to the directory. Throws <a>NotAProperPrefix</a> if the
--   directory is not a proper prefix of the path.
--   
--   The following properties hold:
--   
--   <pre>
--   stripProperPrefix x (x &lt;/&gt; y) = y
--   </pre>
--   
--   Cases which are proven not possible:
--   
--   <pre>
--   stripProperPrefix (a :: Path Abs …) (b :: Path Rel …)
--   </pre>
--   
--   <pre>
--   stripProperPrefix (a :: Path Rel …) (b :: Path Abs …)
--   </pre>
--   
--   In other words the bases must match.
stripProperPrefix :: MonadThrow m => Path b Dir -> Path b t -> m (Path Rel t)

-- | Determines if the path in the first parameter is a proper prefix of
--   the path in the second parameter.
--   
--   The following properties hold:
--   
--   <pre>
--   not (x `isProperPrefixOf` x)
--   </pre>
--   
--   <pre>
--   x `isProperPrefixOf` (x &lt;/&gt; y)
--   </pre>
isProperPrefixOf :: Path b Dir -> Path b t -> Bool

-- | Take the parent path component from a path.
--   
--   The following properties hold:
--   
--   <pre>
--   parent (x &lt;/&gt; y) == x
--   parent "/x" == "/"
--   parent "x" == "."
--   </pre>
--   
--   On the root (absolute or relative), getting the parent is idempotent:
--   
--   <pre>
--   parent "/" = "/"
--   parent "." = "."
--   </pre>
parent :: Path b t -> Path b Dir

-- | Extract the file part of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   filename (p &lt;/&gt; a) == filename a
--   </pre>
filename :: Path b File -> Path Rel File

-- | Extract the last directory name of a path.
--   
--   The following properties hold:
--   
--   <pre>
--   dirname $(mkRelDir ".") == $(mkRelDir ".")
--   </pre>
--   
--   <pre>
--   dirname (p &lt;/&gt; a) == dirname a
--   </pre>
dirname :: Path b Dir -> Path Rel Dir

-- | Add extension to given file path.
--   
--   <pre>
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo"    )
--   
--   &gt;&gt;&gt; addExtension ".foo."  $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo."   )
--   
--   &gt;&gt;&gt; addExtension ".foo.." $(mkRelFile "name"     ) == Just $(mkRelFile "name.foo.."  )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name.bar" ) == Just $(mkRelFile "name.bar.foo")
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile ".name"    ) == Just $(mkRelFile ".name.foo"   )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "name."    ) == Just $(mkRelFile "name..foo"   )
--   
--   &gt;&gt;&gt; addExtension ".foo"   $(mkRelFile "..."      ) == Just $(mkRelFile "....foo"     )
--   </pre>
--   
--   Throws an <a>InvalidExtension</a> exception if the extension is not
--   valid. A valid extension starts with a <tt>.</tt> followed by one or
--   more characters not including <tt>.</tt> followed by zero or more
--   <tt>.</tt> in trailing position. Moreover, an extension must be a
--   valid filename, notably it cannot include path separators.
--   Particularly, <tt>.foo.bar</tt> is an invalid extension, instead you
--   have to first set <tt>.foo</tt> and then <tt>.bar</tt> individually.
--   Some examples of invalid extensions are:
--   
--   <pre>
--   &gt;&gt;&gt; addExtension "foo"      $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension "..foo"    $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension ".foo.bar" $(mkRelFile "name")
--   
--   &gt;&gt;&gt; addExtension ".foo/bar" $(mkRelFile "name")
--   </pre>
addExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | <a>splitExtension</a> is the inverse of <a>addExtension</a>. It splits
--   the given file path into a valid filename and a valid extension.
--   
--   <pre>
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo"     ) == Just ($(mkRelFile "name"    ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo."    ) == Just ($(mkRelFile "name"    ), ".foo." )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.foo.."   ) == Just ($(mkRelFile "name"    ), ".foo..")
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.bar.foo" ) == Just ($(mkRelFile "name.bar"), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile ".name.foo"    ) == Just ($(mkRelFile ".name"   ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name..foo"    ) == Just ($(mkRelFile "name."   ), ".foo"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "....foo"      ) == Just ($(mkRelFile "..."     ), ".foo"  )
--   </pre>
--   
--   Throws <a>HasNoExtension</a> exception if the filename does not have
--   an extension or in other words it cannot be split into a valid
--   filename and a valid extension. The following cases throw an
--   exception, please note that "." and ".." are not valid filenames:
--   
--   <pre>
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name"   )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name."  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "name.." )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile ".name"  )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "..name" )
--   
--   &gt;&gt;&gt; splitExtension $(mkRelFile "...name")
--   </pre>
--   
--   <a>splitExtension</a> and <a>addExtension</a> are inverses of each
--   other, the following laws hold:
--   
--   <pre>
--   uncurry addExtension . swap &gt;=&gt; splitExtension == return
--   splitExtension &gt;=&gt; uncurry addExtension . swap == return
--   </pre>
splitExtension :: MonadThrow m => Path b File -> m (Path b File, String)

-- | Get extension from given file path. Throws <a>HasNoExtension</a>
--   exception if the file does not have an extension. The following laws
--   hold:
--   
--   <pre>
--   flip addExtension file &gt;=&gt; fileExtension == return
--   fileExtension == (fmap snd) . splitExtension
--   </pre>
fileExtension :: MonadThrow m => Path b File -> m String

-- | If the file has an extension replace it with the given extension
--   otherwise add the new extension to it. Throws an
--   <a>InvalidExtension</a> exception if the new extension is not a valid
--   extension (see <a>fileExtension</a> for validity rules).
--   
--   The following law holds:
--   
--   <pre>
--   (fileExtension &gt;=&gt; flip replaceExtension file) file == return file
--   </pre>
replaceExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | Convert an absolute <a>FilePath</a> to a normalized absolute dir
--   <a>Path</a>.
--   
--   Throws: <a>InvalidAbsDir</a> when the supplied path:
--   
--   <ul>
--   <li>is not an absolute path</li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseAbsDir :: MonadThrow m => FilePath -> m (Path Abs Dir)

-- | Convert a relative <a>FilePath</a> to a normalized relative dir
--   <a>Path</a>.
--   
--   Throws: <a>InvalidRelDir</a> when the supplied path:
--   
--   <ul>
--   <li>is not a relative path</li>
--   <li>is <tt>""</tt></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   <li>is all path separators</li>
--   </ul>
parseRelDir :: MonadThrow m => FilePath -> m (Path Rel Dir)

-- | Convert an absolute <a>FilePath</a> to a normalized absolute file
--   <a>Path</a>.
--   
--   Throws: <a>InvalidAbsFile</a> when the supplied path:
--   
--   <ul>
--   <li>is not an absolute path</li>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseAbsFile :: MonadThrow m => FilePath -> m (Path Abs File)

-- | Convert a relative <a>FilePath</a> to a normalized relative file
--   <a>Path</a>.
--   
--   Throws: <a>InvalidRelFile</a> when the supplied path:
--   
--   <ul>
--   <li>is not a relative path</li>
--   <li>is <tt>""</tt></li>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseRelFile :: MonadThrow m => FilePath -> m (Path Rel File)

-- | Convert an absolute or relative <a>FilePath</a> to a normalized
--   <a>SomeBase</a> representing a directory.
--   
--   Throws: <a>InvalidDir</a> when the supplied path:
--   
--   <ul>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseSomeDir :: MonadThrow m => FilePath -> m (SomeBase Dir)

-- | Convert an absolute or relative <a>FilePath</a> to a normalized
--   <a>SomeBase</a> representing a file.
--   
--   Throws: <a>InvalidFile</a> when the supplied path:
--   
--   <ul>
--   <li>is a directory path i.e.<ul><li>has a trailing path
--   separator</li><li>is <tt>.</tt> or ends in <tt>/.</tt></li></ul></li>
--   <li>contains a <tt>..</tt> path component representing the parent
--   directory</li>
--   <li>is not a valid path (See <a>isValid</a>)</li>
--   </ul>
parseSomeFile :: MonadThrow m => FilePath -> m (SomeBase File)

-- | Convert to a <a>FilePath</a> type.
--   
--   All directories have a trailing slash, so if you want no trailing
--   slash, you can use <a>dropTrailingPathSeparator</a> from the filepath
--   package.
toFilePath :: Path b t -> FilePath

-- | Convert absolute path to directory to <a>FilePath</a> type.
fromAbsDir :: Path Abs Dir -> FilePath

-- | Convert relative path to directory to <a>FilePath</a> type.
fromRelDir :: Path Rel Dir -> FilePath

-- | Convert absolute path to file to <a>FilePath</a> type.
fromAbsFile :: Path Abs File -> FilePath

-- | Convert relative path to file to <a>FilePath</a> type.
fromRelFile :: Path Rel File -> FilePath

-- | Convert a valid directory to a <a>FilePath</a>.
fromSomeDir :: SomeBase Dir -> FilePath

-- | Convert a valid file to a <a>FilePath</a>.
fromSomeFile :: SomeBase File -> FilePath

-- | Make a <a>Path</a> <a>Abs</a> <a>Dir</a>.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsDir :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Rel</a> <a>Dir</a>.
mkRelDir :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Abs</a> <a>File</a>.
--   
--   Remember: due to the nature of absolute paths this (e.g.
--   <tt>/home/foo</tt>) may compile on your platform, but it may not
--   compile on another platform (Windows).
mkAbsFile :: FilePath -> Q Exp

-- | Make a <a>Path</a> <a>Rel</a> <a>File</a>.
mkRelFile :: FilePath -> Q Exp

-- | Same as <a>PathException</a>.

-- | <i>Deprecated: Please use PathException instead.</i>
type PathParseException = PathException

-- | Same as <a>stripProperPrefix</a>.

-- | <i>Deprecated: Please use stripProperPrefix instead.</i>
stripDir :: MonadThrow m => Path b Dir -> Path b t -> m (Path Rel t)

-- | Same as <a>isProperPrefixOf</a>.

-- | <i>Deprecated: Please use isProperPrefixOf instead.</i>
isParentOf :: Path b Dir -> Path b t -> Bool

-- | Add extension to given file path. Throws if the resulting filename
--   does not parse.
--   
--   <pre>
--   &gt;&gt;&gt; addFileExtension "txt $(mkRelFile "foo")
--   "foo.txt"
--   
--   &gt;&gt;&gt; addFileExtension "symbols" $(mkRelFile "Data.List")
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; addFileExtension ".symbols" $(mkRelFile "Data.List")
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; addFileExtension "symbols" $(mkRelFile "Data.List.")
--   "Data.List..symbols"
--   
--   &gt;&gt;&gt; addFileExtension ".symbols" $(mkRelFile "Data.List.")
--   "Data.List..symbols"
--   
--   &gt;&gt;&gt; addFileExtension "evil/" $(mkRelFile "Data.List")
--   *** Exception: InvalidRelFile "Data.List.evil/"
--   </pre>

-- | <i>Deprecated: Please use addExtension instead.</i>
addFileExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | A synonym for <a>addFileExtension</a> in the form of an infix
--   operator. See more examples there.
--   
--   <pre>
--   &gt;&gt;&gt; $(mkRelFile "Data.List") &lt;.&gt; "symbols"
--   "Data.List.symbols"
--   
--   &gt;&gt;&gt; $(mkRelFile "Data.List") &lt;.&gt; "evil/"
--   *** Exception: InvalidRelFile "Data.List.evil/"
--   </pre>

-- | <i>Deprecated: Please use addExtension instead.</i>
(<.>) :: MonadThrow m => Path b File -> String -> m (Path b File)
infixr 7 <.>

-- | Replace/add extension to given file path. Throws if the resulting
--   filename does not parse.

-- | <i>Deprecated: Please use replaceExtension instead.</i>
setFileExtension :: MonadThrow m => String -> Path b File -> m (Path b File)

-- | A synonym for <a>setFileExtension</a> in the form of an operator.

-- | <i>Deprecated: Please use replaceExtension instead.</i>
(-<.>) :: MonadThrow m => Path b File -> String -> m (Path b File)
infixr 7 -<.>
instance GHC.Classes.Eq Path.Windows.PathException
instance GHC.Show.Show Path.Windows.PathException
instance GHC.Classes.Ord (Path.Windows.SomeBase t)
instance GHC.Classes.Eq (Path.Windows.SomeBase t)
instance GHC.Generics.Generic (Path.Windows.SomeBase t)
instance Control.DeepSeq.NFData (Path.Windows.SomeBase t)
instance GHC.Show.Show (Path.Windows.SomeBase t)
instance Data.Aeson.Types.ToJSON.ToJSON (Path.Windows.SomeBase t)
instance Data.Hashable.Class.Hashable (Path.Windows.SomeBase t)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Windows.SomeBase Path.Windows.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Windows.SomeBase Path.Windows.File)
instance GHC.Exception.Type.Exception Path.Windows.PathException
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Windows.Abs Path.Windows.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Windows.Rel Path.Windows.Dir)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Windows.Abs Path.Windows.Dir)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Windows.Rel Path.Windows.Dir)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Windows.Abs Path.Windows.File)
instance Data.Aeson.Types.FromJSON.FromJSON (Path.Internal.Path Path.Windows.Rel Path.Windows.File)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Windows.Abs Path.Windows.File)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Path.Internal.Path Path.Windows.Rel Path.Windows.File)
