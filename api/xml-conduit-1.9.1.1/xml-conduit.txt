-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure-Haskell utilities for dealing with XML with the conduit package.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/xml-conduit</a>.
@package xml-conduit
@version 1.9.1.1


-- | Generalized cursors to be applied to different nodes.
module Text.XML.Cursor.Generic

-- | A cursor: contains an XML <tt>Node</tt> and pointers to its children,
--   ancestors and siblings.
data Cursor node
type Axis node = Cursor node -> [Cursor node]
toCursor :: (node -> [node]) -> node -> Cursor node

-- | The current node.
node :: Cursor node -> node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> Cursor node -> [b]
infixr 1 &|

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &/

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &//

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &.//

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a
infixr 1 $|

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $/

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $//

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $.//

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>
instance GHC.Show.Show node => GHC.Show.Show (Text.XML.Cursor.Generic.Cursor node)


-- | <tt>Enumeratee</tt>s to render XML <a>Event</a>s. Unlike
--   libxml-enumerator and expat-enumerator, this module does not provide
--   IO and ST variants, since the underlying rendering operations are pure
--   functions.
module Text.XML.Stream.Render

-- | Render a stream of <a>Event</a>s into a stream of <a>Builder</a>s.
--   Builders are from the blaze-builder package, and allow the create of
--   optimally sized <a>ByteString</a>s with minimal buffer copying.
renderBuilder :: Monad m => RenderSettings -> ConduitT Event Builder m ()

-- | Same as <a>renderBuilder</a> but allows you to flush XML stream to
--   ensure that all events at needed point are rendered.
renderBuilderFlush :: Monad m => RenderSettings -> ConduitT (Flush Event) (Flush Builder) m ()

-- | Render a stream of <a>Event</a>s into a stream of <a>ByteString</a>s.
--   This function wraps around <a>renderBuilder</a> and
--   <a>builderToByteString</a>, so it produces optimally sized
--   <a>ByteString</a>s with minimal buffer copying.
--   
--   The output is UTF8 encoded.
renderBytes :: PrimMonad m => RenderSettings -> ConduitT Event ByteString m ()

-- | Render a stream of <a>Event</a>s into a stream of <a>Text</a>s. This
--   function wraps around <a>renderBuilder</a>, <a>builderToByteString</a>
--   and <a>renderBytes</a>, so it produces optimally sized <a>Text</a>s
--   with minimal buffer copying.
renderText :: (PrimMonad m, MonadThrow m) => RenderSettings -> ConduitT Event Text m ()

-- | Convert a stream of <a>Event</a>s into a prettified one, adding extra
--   whitespace. Note that this can change the meaning of your XML.
prettify :: Monad m => ConduitT (Flush Event) (Flush Event) m ()
data RenderSettings

-- | The default value for this type.
def :: Default a => a
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Determines if for a given text content the renderer should use a CDATA
--   node.
--   
--   Default: <tt>False</tt>
rsUseCDATA :: RenderSettings -> Content -> Bool

-- | Determines whether the XML declaration will be output.
--   
--   Default: <tt>True</tt>
rsXMLDeclaration :: RenderSettings -> Bool

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]

-- | Generate a complete XML <tt>Element</tt>.
tag :: Monad m => Name -> Attributes -> ConduitT i Event m () -> ConduitT i Event m ()

-- | Generate a textual <a>EventContent</a>.
content :: Monad m => Text -> ConduitT i Event m ()

-- | A list of attributes.
data Attributes

-- | Generate a single attribute.
attr :: Name -> Text -> Attributes

-- | Helper function that generates a valid attribute if input isn't
--   <a>Nothing</a>, or <a>mempty</a> otherwise.
optionalAttr :: Name -> Maybe Text -> Attributes
instance GHC.Base.Monoid Text.XML.Stream.Render.Attributes
instance GHC.Base.Semigroup Text.XML.Stream.Render.Attributes
instance Data.Default.Class.Default Text.XML.Stream.Render.RenderSettings


-- | This module provides both a native Haskell solution for parsing XML
--   documents into a stream of events, and a set of parser combinators for
--   dealing with a stream of events.
--   
--   As a simple example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import Conduit (runConduit, (.|))
--   
--   &gt;&gt;&gt; import Data.Text (Text, unpack)
--   
--   &gt;&gt;&gt; import Data.XML.Types (Event)
--   
--   &gt;&gt;&gt; data Person = Person Int Text Text deriving Show
--   
--   &gt;&gt;&gt; :{
--   let parsePerson :: MonadThrow m =&gt; ConduitT Event o m (Maybe Person)
--       parsePerson = tag' "person" parseAttributes $ \(age, goodAtHaskell) -&gt; do
--         name &lt;- content
--         return $ Person (read $ unpack age) name goodAtHaskell
--         where parseAttributes = (,) &lt;$&gt; requireAttr "age" &lt;*&gt; requireAttr "goodAtHaskell" &lt;* ignoreAttrs
--       parsePeople :: MonadThrow m =&gt; ConduitT Event o m (Maybe [Person])
--       parsePeople = tagNoAttr "people" $ many parsePerson
--       inputXml = mconcat
--         [ "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"
--         , "&lt;people&gt;"
--         , "  &lt;person age=\"25\" goodAtHaskell=\"yes\"&gt;Michael&lt;/person&gt;"
--         , "  &lt;person age=\"2\" goodAtHaskell=\"might become\"&gt;Eliezer&lt;/person&gt;"
--         , "&lt;/people&gt;"
--         ]
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def inputXml .| force "people required" parsePeople
--   [Person 25 "Michael" "yes",Person 2 "Eliezer" "might become"]
--   </pre>
--   
--   This module also supports streaming results using <a>yield</a>. This
--   allows parser results to be processed using conduits while a
--   particular parser (e.g. <a>many</a>) is still running. Without using
--   streaming results, you have to wait until the parser finished before
--   you can process the result list. Large XML files might be easier to
--   process by using streaming results. See
--   <a>http://stackoverflow.com/q/21367423/2597135</a> for a related
--   discussion.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Conduit.List as CL
--   
--   &gt;&gt;&gt; :{
--   let parsePeople' :: MonadThrow m =&gt; ConduitT Event Person m (Maybe ())
--       parsePeople' = tagNoAttr "people" $ manyYield parsePerson
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def inputXml .| force "people required" parsePeople' .| CL.mapM_ print
--   Person 25 "Michael" "yes"
--   Person 2 "Eliezer" "might become"
--   </pre>
--   
--   Previous versions of this module contained a number of more
--   sophisticated functions written by Aristid Breitkreuz and Dmitry
--   Olshansky. To keep this package simpler, those functions are being
--   moved to a separate package. This note will be updated with the name
--   of the package(s) when available.
module Text.XML.Stream.Parse

-- | Parses a byte stream into <a>Event</a>s. This function is implemented
--   fully in Haskell using attoparsec-text for parsing. The produced error
--   messages do not give line/column information, so you may prefer to
--   stick with the parser provided by libxml-enumerator. However, this has
--   the advantage of not relying on any C libraries.
--   
--   This relies on <a>detectUtf</a> to determine character encoding, and
--   <a>parseText</a> to do the actual parsing.
parseBytes :: MonadThrow m => ParseSettings -> ConduitT ByteString Event m ()
parseBytesPos :: MonadThrow m => ParseSettings -> ConduitT ByteString EventPos m ()

-- | Parses a character stream into <a>Event</a>s. This function is
--   implemented fully in Haskell using attoparsec-text for parsing. The
--   produced error messages do not give line/column information, so you
--   may prefer to stick with the parser provided by libxml-enumerator.
--   However, this has the advantage of not relying on any C libraries.
--   
--   Since 1.2.4
parseText :: MonadThrow m => ParseSettings -> ConduitT Text Event m ()

-- | Same as <a>parseText</a>, but includes the position of each event.
--   
--   Since 1.2.4
parseTextPos :: MonadThrow m => ParseSettings -> ConduitT Text EventPos m ()

-- | Automatically determine which UTF variant is being used. This function
--   first checks for BOMs, removing them as necessary, and then check for
--   the equivalent of &lt;?xml for each of UTF-8, UTF-16LE<i>BE, and
--   UTF-32LE</i>BE. It defaults to assuming UTF-8.
detectUtf :: MonadThrow m => ConduitT ByteString Text m ()

-- | A helper function which reads a file from disk using
--   <tt>enumFile</tt>, detects character encoding using <a>detectUtf</a>,
--   parses the XML using <a>parseBytes</a>, and then hands off control to
--   your supplied parser.
parseFile :: MonadResource m => ParseSettings -> FilePath -> ConduitT i Event m ()

-- | Parse an event stream from a lazy <a>ByteString</a>.
parseLBS :: MonadThrow m => ParseSettings -> ByteString -> ConduitT i Event m ()
data ParseSettings

-- | The default value for this type.
def :: Default a => a
type DecodeEntities = Text -> Content
type DecodeIllegalCharacters = Int -> Maybe Char
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | How to decode illegal character references (<tt>&amp;#[0-9]+;</tt> or
--   <tt>&amp;#x[0-9a-fA-F]+;</tt>).
--   
--   Character references within the legal ranges defined by <a>the
--   standard</a> are automatically parsed. Others are passed to this
--   function.
--   
--   Default: <tt>const Nothing</tt>
--   
--   Since 1.7.1
psDecodeIllegalCharacters :: ParseSettings -> DecodeIllegalCharacters

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Maximum number of characters allowed in expanding an internal entity.
--   This is intended to protect against the billion laughs attack.
--   
--   Default: <tt>8192</tt>
--   
--   Since 1.9.1
psEntityExpansionSizeLimit :: ParseSettings -> Int

-- | Default implementation of <a>DecodeEntities</a>, which leaves the
--   entity as-is. Numeric character references and the five standard
--   entities (lt, gt, amp, quot, pos) are handled internally by the
--   parser.
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles the additional 248 entities
--   defined by HTML 4 and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities

-- | The most generic way to parse a tag. It takes a <a>NameMatcher</a> to
--   check whether this is a correct tag name, an <a>AttrParser</a> to
--   handle attributes, and then a parser to deal with content.
--   
--   <tt>Events</tt> are consumed if and only if the tag name and its
--   attributes match.
--   
--   This function automatically absorbs its balancing closing tag, and
--   will throw an exception if not all of the attributes or child elements
--   are consumed. If you want to allow extra attributes, see
--   <a>ignoreAttrs</a>.
--   
--   This function automatically ignores comments, instructions and
--   whitespace.
tag :: MonadThrow m => NameMatcher a -> (a -> AttrParser b) -> (b -> ConduitT Event o m c) -> ConduitT Event o m (Maybe c)

-- | A simplified version of <a>tag</a> where the <a>NameMatcher</a> result
--   isn't forwarded to the attributes parser.
--   
--   Since 1.5.0
tag' :: MonadThrow m => NameMatcher a -> AttrParser b -> (b -> ConduitT Event o m c) -> ConduitT Event o m (Maybe c)

-- | A further simplified tag parser, which requires that no attributes
--   exist.
tagNoAttr :: MonadThrow m => NameMatcher a -> ConduitT Event o m b -> ConduitT Event o m (Maybe b)

-- | A further simplified tag parser, which ignores all attributes, if any
--   exist
tagIgnoreAttrs :: MonadThrow m => NameMatcher a -> ConduitT Event o m b -> ConduitT Event o m (Maybe b)

-- | Grabs the next piece of content. If none if available, returns
--   <a>empty</a>. This is simply a wrapper around <a>contentMaybe</a>.
content :: MonadThrow m => ConduitT Event o m Text

-- | Grabs the next piece of content if available. This function skips over
--   any comments, instructions or entities, and concatenates all content
--   until the next start or end tag.
contentMaybe :: MonadThrow m => ConduitT Event o m (Maybe Text)

-- | Ignore an empty tag and all of its attributes. This does not ignore
--   the tag recursively (i.e. it assumes there are no child elements).
--   This function returns <tt>Just ()</tt> if the tag matched.
--   
--   Since 1.5.0
ignoreEmptyTag :: MonadThrow m => NameMatcher a -> ConduitT Event o m (Maybe ())

-- | Same as <a>takeTree</a>, without yielding <a>Event</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| (ignoreTree "a" ignoreAttrs &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "b", ...}) [],EventEndElement (Name {nameLocalName = "b", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;" .| (ignoreTree "b" ignoreAttrs &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventContent (ContentText "content"),EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;" .| (ignoreTree anyName ignoreAttrs &gt;&gt; sinkList)
--   [EventContent (ContentText "content"),EventBeginElement (Name {nameLocalName = "a", ...}) [],EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   Since 1.9.0
ignoreTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())

-- | Same as <a>takeContent</a>, without yielding <a>Event</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;" .| (ignoreContent &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventContent (ContentText "content"),EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;" .| (ignoreContent &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;" .| (ignoreContent &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   Since 1.9.0
ignoreContent :: MonadThrow m => ConduitT Event o m (Maybe ())

-- | Same as <a>takeTreeContent</a>, without yielding <a>Event</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| (ignoreTreeContent "a" ignoreAttrs &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "b", ...}) [],EventEndElement (Name {nameLocalName = "b", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;" .| (ignoreTreeContent "b" ignoreAttrs &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventContent (ContentText "content"),EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;" .| (ignoreTreeContent anyName ignoreAttrs &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "a", ...}) [],EventEndElement (Name {nameLocalName = "a", ...}),EventEndDocument]
--   </pre>
--   
--   Since 1.5.0
ignoreTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event o m (Maybe ())

-- | Same as <a>takeAnyTreeContent</a>, without yielding <a>Event</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| (ignoreAnyTreeContent &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "b", ...}) [],EventEndElement (Name {nameLocalName = "b", ...}),EventEndDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "text&lt;b&gt;&lt;/b&gt;" .| (ignoreAnyTreeContent &gt;&gt; sinkList)
--   [EventBeginElement (Name {nameLocalName = "b", ...}) [],EventEndElement (Name {nameLocalName = "b", ...}),EventEndDocument]
--   </pre>
--   
--   Since 1.5.0
ignoreAnyTreeContent :: MonadThrow m => ConduitT Event o m (Maybe ())

-- | Stream a single content <a>Event</a>.
--   
--   Returns <tt>Just ()</tt> if a content <a>Event</a> was consumed,
--   <tt>Nothing</tt> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;" .| void takeContent .| sinkList
--   [EventBeginDocument,EventContent (ContentText "content")]
--   </pre>
--   
--   If next event isn't a content, nothing is consumed.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;" .| void takeContent .| sinkList
--   [EventBeginDocument]
--   </pre>
--   
--   Since 1.5.0
takeContent :: MonadThrow m => ConduitT Event Event m (Maybe ())

-- | Stream <a>Event</a>s corresponding to a single XML element that
--   matches given <a>NameMatcher</a> and <a>AttrParser</a>, from the
--   opening- to the closing-tag.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTree "a" ignoreAttrs) .| sinkList
--   [EventBeginDocument,EventBeginElement (Name {nameLocalName = "a", ...}) [],EventContent (ContentText "content"),EventEndElement (Name {nameLocalName = "a", ...})]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTree "b" ignoreAttrs) .| sinkList
--   [EventBeginDocument]
--   </pre>
--   
--   If next <a>Event</a> isn't an element, nothing is consumed.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "text&lt;a&gt;&lt;/a&gt;" .| void (takeTree "a" ignoreAttrs) .| sinkList
--   [EventBeginDocument]
--   </pre>
--   
--   If an opening-tag is consumed but no matching closing-tag is found, an
--   <a>XmlException</a> is thrown.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTree "a" ignoreAttrs) .| sinkList
--   *** Exception: InvalidEndElement (Name {nameLocalName = "a", nameNamespace = Nothing, namePrefix = Nothing}) Nothing
--   </pre>
--   
--   This function automatically ignores comments, instructions and
--   whitespace.
--   
--   Returns <tt>Just ()</tt> if an element was consumed, <a>Nothing</a>
--   otherwise.
--   
--   Since 1.5.0
takeTree :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())

-- | Like <a>takeTree</a>, but can also stream a content <a>Event</a>.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTreeContent "a" ignoreAttrs) .| sinkList
--   [EventBeginDocument,EventBeginElement (Name {nameLocalName = "a", ...}) [],EventContent (ContentText "content"),EventEndElement (Name {nameLocalName = "a", ...})]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;a&gt;content&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTreeContent "b" ignoreAttrs) .| sinkList
--   [EventBeginDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "content&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void (takeTreeContent "a" ignoreAttrs) .| sinkList
--   [EventBeginDocument,EventContent (ContentText "content")]
--   </pre>
--   
--   Since 1.5.0
takeTreeContent :: MonadThrow m => NameMatcher a -> AttrParser b -> ConduitT Event Event m (Maybe ())

-- | Like <a>takeTreeContent</a>, without checking for tag name or
--   attributes.
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "text&lt;a&gt;&lt;/a&gt;" .| void takeAnyTreeContent .| sinkList
--   [EventBeginDocument,EventContent (ContentText "text")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| void takeAnyTreeContent .| sinkList
--   [EventBeginDocument]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ parseLBS def "&lt;b&gt;&lt;c&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;text" .| void takeAnyTreeContent .| sinkList
--   [EventBeginDocument,EventBeginElement (Name {nameLocalName = "b", ...}) [],EventBeginElement (Name {nameLocalName = "c", ...}) [],EventEndElement (Name {nameLocalName = "c", ...}),EventEndElement (Name {nameLocalName = "b", ...})]
--   </pre>
--   
--   Since 1.5.0
takeAnyTreeContent :: MonadThrow m => ConduitT Event Event m (Maybe ())

-- | A <tt>NameMatcher</tt> describes which names a tag parser is allowed
--   to match.
--   
--   Since 1.5.0
newtype NameMatcher a
NameMatcher :: (Name -> Maybe a) -> NameMatcher a
[runNameMatcher] :: NameMatcher a -> Name -> Maybe a

-- | <tt>matching f</tt> matches <tt>name</tt> iff <tt>f name</tt> is true.
--   Returns the matched <a>Name</a>.
--   
--   Since 1.5.0
matching :: (Name -> Bool) -> NameMatcher Name

-- | Matches any <a>Name</a> from the given list. Returns the matched
--   <a>Name</a>.
--   
--   Since 1.5.0
anyOf :: [Name] -> NameMatcher Name

-- | Matches any <a>Name</a>. Returns the matched <a>Name</a>.
--   
--   Since 1.5.0
anyName :: NameMatcher Name

-- | A monad for parsing attributes. By default, it requires you to deal
--   with all attributes present on an element, and will throw an exception
--   if there are unhandled attributes. Use the <a>requireAttr</a>,
--   <a>attr</a> et al functions for handling an attribute, and
--   <a>ignoreAttrs</a> if you would like to skip the rest of the
--   attributes on an element.
--   
--   <a>Alternative</a> instance behaves like <tt>First</tt> monoid: it
--   chooses first parser which doesn't fail.
data AttrParser a

-- | Return the value for an attribute if present.
attr :: Name -> AttrParser (Maybe Text)

-- | Shortcut composition of <a>force</a> and <a>attr</a>.
requireAttr :: Name -> AttrParser Text

-- | <i>Deprecated: Please use <a>attr</a>.</i>
optionalAttr :: Name -> AttrParser (Maybe Text)
requireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b
optionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)

-- | Skip the remaining attributes on an element. Since this will clear the
--   list of attributes, you must call this <i>after</i> any calls to
--   <a>requireAttr</a>, <a>optionalAttr</a>, etc.
ignoreAttrs :: AttrParser ()

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <tt>Just</tt>), this function returns
--   <a>Nothing</a>.
--   
--   <pre>
--   orE a b = choose [a, b]
--   </pre>
--   
--   Warning: <a>orE</a> doesn't backtrack. See <a>choose</a> for detailed
--   explanation.
orE :: Monad m => ConduitT Event o m (Maybe a) -> ConduitT Event o m (Maybe a) -> ConduitT Event o m (Maybe a)

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <a>Just</a>), this function returns
--   <a>Nothing</a>.
--   
--   Warning: <a>choose</a> doesn't backtrack. If a parser consumed some
--   events, subsequent parsers will continue from the following events.
--   This can be a problem if parsers share an accepted prefix of events,
--   so an earlier (failing) parser will discard the events that the later
--   parser could potentially succeed on.
--   
--   An other problematic case is using <a>choose</a> to implement
--   order-independent parsing using a set of parsers, with a final
--   trailing ignore-anything-else action. In this case, certain trees
--   might be skipped.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let parse2Tags name1 name2 = do
--         tag1 &lt;- tagNoAttr name1 (pure ())
--         tag2 &lt;- tagNoAttr name2 (pure tag1)
--         return $ join tag2
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runConduit $ parseLBS def "&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| choose
--     [ parse2Tags "a" "b"
--     , parse2Tags "a" "c"
--     ]
--   :}
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runConduit $ parseLBS def "&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" .| choose
--     [ parse2Tags "a" "c"
--     , parse2Tags "a" "b"
--     ]
--   :}
--   Nothing
--   </pre>
choose :: Monad m => [ConduitT Event o m (Maybe a)] -> ConduitT Event o m (Maybe a)

-- | Keep parsing elements as long as the parser returns <a>Just</a>.
many :: Monad m => ConduitT Event o m (Maybe a) -> ConduitT Event o m [a]

-- | Like <a>many</a> but discards the results without building an
--   intermediate list.
--   
--   Since 1.5.0
many_ :: MonadThrow m => ConduitT Event o m (Maybe a) -> ConduitT Event o m ()

-- | Keep parsing elements as long as the parser returns <a>Just</a> or the
--   ignore parser returns <a>Just</a>.
manyIgnore :: Monad m => ConduitT Event o m (Maybe a) -> ConduitT Event o m (Maybe b) -> ConduitT Event o m [a]

-- | Like <tt>many</tt>, but any tags and content the consumer doesn't
--   match on are silently ignored.
many' :: MonadThrow m => ConduitT Event o m (Maybe a) -> ConduitT Event o m [a]

-- | Force an optional parser into a required parser. All of the <a>tag</a>
--   functions, <a>attr</a>, <a>choose</a> and <a>many</a> deal with
--   <a>Maybe</a> parsers. Use this when you want to finally force
--   something to happen.
force :: MonadThrow m => String -> m (Maybe a) -> m a

-- | Like <a>many</a>, but uses <a>yield</a> so the result list can be
--   streamed to downstream conduits without waiting for <a>manyYield</a>
--   to finish
manyYield :: Monad m => ConduitT a b m (Maybe b) -> ConduitT a b m ()

-- | Like <a>many'</a>, but uses <a>yield</a> so the result list can be
--   streamed to downstream conduits without waiting for <a>manyYield'</a>
--   to finish
manyYield' :: MonadThrow m => ConduitT Event b m (Maybe b) -> ConduitT Event b m ()

-- | Like <a>manyIgnore</a>, but uses <a>yield</a> so the result list can
--   be streamed to downstream conduits without waiting for
--   <a>manyIgnoreYield</a> to finish
manyIgnoreYield :: MonadThrow m => ConduitT Event b m (Maybe b) -> ConduitT Event b m (Maybe ()) -> ConduitT Event b m ()
data XmlException
XmlException :: String -> Maybe Event -> XmlException
[xmlErrorMessage] :: XmlException -> String
[xmlBadInput] :: XmlException -> Maybe Event
InvalidEndElement :: Name -> Maybe Event -> XmlException
InvalidEntity :: String -> Maybe Event -> XmlException
MissingAttribute :: String -> XmlException
UnparsedAttributes :: [(Name, [Content])] -> XmlException
data PositionRange
type EventPos = (Maybe PositionRange, Event)
instance GHC.Show.Show Text.XML.Stream.Parse.XmlException
instance GHC.Base.Functor Text.XML.Stream.Parse.NameMatcher
instance GHC.Base.Monad Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Functor Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Applicative Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Alternative Text.XML.Stream.Parse.AttrParser
instance Control.Monad.Catch.MonadThrow Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Applicative Text.XML.Stream.Parse.NameMatcher
instance GHC.Base.Alternative Text.XML.Stream.Parse.NameMatcher
instance (a GHC.Types.~ Data.XML.Types.Name) => Data.String.IsString (Text.XML.Stream.Parse.NameMatcher a)
instance GHC.Exception.Type.Exception Text.XML.Stream.Parse.XmlException
instance Data.Default.Class.Default Text.XML.Stream.Parse.ParseSettings


-- | DOM-based XML parsing and rendering.
--   
--   In this module, attribute values and content nodes can contain either
--   raw text or entities. In most cases, these can be fully resolved at
--   parsing. If that is the case for your documents, the <a>Text.XML</a>
--   module provides simplified datatypes that only contain raw text.
module Text.XML.Unresolved
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
readFile :: ParseSettings -> FilePath -> IO Document
renderLBS :: RenderSettings -> Document -> ByteString
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> ConduitT Text o m Document
sinkDoc :: MonadThrow m => ParseSettings -> ConduitT ByteString o m Document

-- | Render a document into events.
toEvents :: Document -> [Event]

-- | Render a document element into events.
elementToEvents :: Element -> [Event]

-- | Parse a document from a stream of events.
fromEvents :: MonadThrow m => ConduitT EventPos o m Document

-- | Try to parse a document element (as defined in XML) from a stream of
--   events.
elementFromEvents :: MonadThrow m => ConduitT EventPos o m (Maybe Element)
renderBuilder :: Monad m => RenderSettings -> Document -> ConduitT i Builder m ()
renderBytes :: PrimMonad m => RenderSettings -> Document -> ConduitT i ByteString m ()
renderText :: (MonadThrow m, PrimMonad m) => RenderSettings -> Document -> ConduitT i Text m ()
data InvalidEventStream
ContentAfterRoot :: EventPos -> InvalidEventStream
MissingRootElement :: InvalidEventStream
InvalidInlineDoctype :: EventPos -> InvalidEventStream
MissingEndElement :: Name -> Maybe EventPos -> InvalidEventStream
UnterminatedInlineDoctype :: InvalidEventStream

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]
instance GHC.Exception.Type.Exception Text.XML.Unresolved.InvalidEventStream
instance GHC.Show.Show Text.XML.Unresolved.InvalidEventStream


-- | DOM-based parsing and rendering.
--   
--   This module requires that all entities be resolved at parsing. If you
--   need to interact with unresolved entities, please use
--   <a>Text.XML.Unresolved</a>. This is the recommended module for most
--   uses cases.
--   
--   While many of the datatypes in this module are simply re-exported from
--   <tt>Data.XML.Types</tt>, <a>Document</a>, <a>Node</a> and
--   <a>Element</a> are all redefined here to disallow the possibility of
--   unresolved entities. Conversion functions are provided to switch
--   between the two sets of datatypes.
--   
--   For simpler, bidirectional traversal of the DOM tree, see the
--   <a>Text.XML.Cursor</a> module.
module Text.XML
data Document
Document :: Prologue -> Element -> [Miscellaneous] -> Document
[documentPrologue] :: Document -> Prologue
[documentRoot] :: Document -> Element
[documentEpilogue] :: Document -> [Miscellaneous]
data Prologue
Prologue :: [Miscellaneous] -> Maybe Doctype -> [Miscellaneous] -> Prologue
[prologueBefore] :: Prologue -> [Miscellaneous]
[prologueDoctype] :: Prologue -> Maybe Doctype
[prologueAfter] :: Prologue -> [Miscellaneous]
data Instruction
Instruction :: Text -> Text -> Instruction
[instructionTarget] :: Instruction -> Text
[instructionData] :: Instruction -> Text
data Miscellaneous
MiscInstruction :: Instruction -> Miscellaneous
MiscComment :: Text -> Miscellaneous
data Node
NodeElement :: Element -> Node
NodeInstruction :: Instruction -> Node
NodeContent :: Text -> Node
NodeComment :: Text -> Node
data Element
Element :: Name -> Map Name Text -> [Node] -> Element
[elementName] :: Element -> Name
[elementAttributes] :: Element -> Map Name Text
[elementNodes] :: Element -> [Node]

-- | A fully qualified name.
--   
--   Prefixes are not semantically important; they are included only to
--   simplify pass-through parsing. When comparing names with <a>Eq</a> or
--   <a>Ord</a> methods, prefixes are ignored.
--   
--   The <tt>IsString</tt> instance supports Clark notation; see
--   <a>http://www.jclark.com/xml/xmlns.htm</a> and
--   <a>http://infohost.nmt.edu/tcc/help/pubs/pylxml/etree-QName.html</a>.
--   Use the <tt>OverloadedStrings</tt> language extension for very simple
--   <tt>Name</tt> construction:
--   
--   <pre>
--   myname :: Name
--   myname = "{http://example.com/ns/my-namespace}my-name"
--   </pre>
data Name
Name :: Text -> Maybe Text -> Maybe Text -> Name
[nameLocalName] :: Name -> Text
[nameNamespace] :: Name -> Maybe Text
[namePrefix] :: Name -> Maybe Text

-- | Note: due to the incredible complexity of DTDs, this type only
--   supports external subsets. I've tried adding internal subset types,
--   but they quickly gain more code than the rest of this module put
--   together.
--   
--   It is possible that some future version of this library might support
--   internal subsets, but I am no longer actively working on adding them.
data Doctype
Doctype :: Text -> Maybe ExternalID -> Doctype
[doctypeName] :: Doctype -> Text
[doctypeID] :: Doctype -> Maybe ExternalID
data ExternalID
SystemID :: Text -> ExternalID
PublicID :: Text -> Text -> ExternalID
readFile :: ParseSettings -> FilePath -> IO Document
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
sinkDoc :: MonadThrow m => ParseSettings -> ConduitT ByteString o m Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> ConduitT Text o m Document
fromEvents :: MonadThrow m => ConduitT EventPos o m Document
data UnresolvedEntityException
UnresolvedEntityException :: Set Text -> UnresolvedEntityException
data XMLException
InvalidXMLFile :: FilePath -> SomeException -> XMLException
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
renderLBS :: RenderSettings -> Document -> ByteString
renderText :: RenderSettings -> Document -> Text
renderBytes :: PrimMonad m => RenderSettings -> Document -> ConduitT i ByteString m ()

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Default implementation of <a>DecodeEntities</a>, which leaves the
--   entity as-is. Numeric character references and the five standard
--   entities (lt, gt, amp, quot, pos) are handled internally by the
--   parser.
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles the additional 248 entities
--   defined by HTML 4 and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Determines if for a given text content the renderer should use a CDATA
--   node.
--   
--   Default: <tt>False</tt>
rsUseCDATA :: RenderSettings -> Content -> Bool

-- | Determines whether the XML declaration will be output.
--   
--   Default: <tt>True</tt>
rsXMLDeclaration :: RenderSettings -> Bool

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]
toXMLDocument :: Document -> Document
fromXMLDocument :: Document -> Either (Set Text) Document
toXMLNode :: Node -> Node
fromXMLNode :: Node -> Either (Set Text) Node
toXMLElement :: Element -> Element
fromXMLElement :: Element -> Either (Set Text) Element
instance Data.Data.Data Text.XML.Node
instance GHC.Classes.Ord Text.XML.Node
instance GHC.Classes.Eq Text.XML.Node
instance GHC.Show.Show Text.XML.Node
instance Data.Data.Data Text.XML.Element
instance GHC.Classes.Ord Text.XML.Element
instance GHC.Classes.Eq Text.XML.Element
instance GHC.Show.Show Text.XML.Element
instance Data.Data.Data Text.XML.Document
instance GHC.Classes.Eq Text.XML.Document
instance GHC.Show.Show Text.XML.Document
instance GHC.Show.Show Text.XML.UnresolvedEntityException
instance GHC.Exception.Type.Exception Text.XML.UnresolvedEntityException
instance GHC.Show.Show Text.XML.XMLException
instance GHC.Exception.Type.Exception Text.XML.XMLException
instance Control.DeepSeq.NFData Text.XML.Document
instance Text.Blaze.ToMarkup Text.XML.Document
instance Control.DeepSeq.NFData Text.XML.Node
instance Control.DeepSeq.NFData Text.XML.Element
instance Text.Blaze.ToMarkup Text.XML.Element
instance Text.Blaze.ToMarkup Text.XML.Node


-- | This module provides for simple DOM traversal. It is inspired by
--   XPath. There are two central concepts here:
--   
--   <ul>
--   <li>A <a>Cursor</a> represents a node in the DOM. It also contains
--   information on the node's <i>location</i>. While the <a>Node</a>
--   datatype will only know of its children, a <tt>Cursor</tt> knows about
--   its parent and siblings as well. (The underlying mechanism allowing
--   this is called a zipper, see
--   <a>http://www.haskell.org/haskellwiki/Zipper</a> and
--   <a>http://www.haskell.org/haskellwiki/Tying_the_Knot</a>.)</li>
--   <li>An <a>Axis</a>, in its simplest form, takes a <tt>Cursor</tt> and
--   returns a list of <tt>Cursor</tt>s. It is used for selections, such as
--   finding children, ancestors, etc. Axes can be chained together to
--   express complex rules, such as all children named <i>foo</i>.</li>
--   </ul>
--   
--   The terminology used in this module is taken directly from the XPath
--   specification: <a>http://www.w3.org/TR/xpath/</a>. For those familiar
--   with XPath, the one major difference is that attributes are not
--   considered nodes in this module.
module Text.XML.Cursor

-- | A cursor: contains an XML <a>Node</a> and pointers to its children,
--   ancestors and siblings.
type Cursor = Cursor Node

-- | The type of an Axis that returns a list of Cursors. They are roughly
--   modeled after <a>http://www.w3.org/TR/xpath/#axes</a>.
--   
--   Axes can be composed with <a>&gt;=&gt;</a>, where e.g. <tt>f &gt;=&gt;
--   g</tt> means that on all results of the <tt>f</tt> axis, the
--   <tt>g</tt> axis will be applied, and all results joined together.
--   Because Axis is just a type synonym for <tt>Cursor -&gt;
--   [Cursor]</tt>, it is possible to use other standard functions like
--   <a>&gt;&gt;=</a> or <a>concatMap</a> similarly.
--   
--   The operators <tt>&amp;|</tt>, <tt>&amp;/</tt>, <tt>&amp;//</tt> and
--   <tt>&amp;.//</tt> can be used to combine axes so that the second axis
--   works on the context nodes, children, descendants, respectively the
--   context node as well as its descendants of the results of the first
--   axis.
--   
--   The operators <tt>$|</tt>, <tt>$/</tt>, <tt>$//</tt> and <tt>$.//</tt>
--   can be used to apply an axis (right-hand side) to a cursor so that it
--   is applied on the cursor itself, its children, its descendants,
--   respectively itself and its descendants.
--   
--   Note that many of these operators also work on <i>generalised Axes</i>
--   that can return lists of something other than Cursors, for example
--   Content elements.
type Axis = Cursor -> [Cursor]

-- | Convert a <a>Document</a> to a <a>Cursor</a>. It will point to the
--   document root.
fromDocument :: Document -> Cursor

-- | Convert a <a>Node</a> to a <a>Cursor</a> (without parents).
fromNode :: Node -> Cursor

-- | Cut a cursor off from its parent. The idea is to allow restricting the
--   scope of queries on it.
cut :: Cursor -> Cursor

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The current node.
node :: Cursor node -> node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | Filter cursors that don't pass a check.
check :: Boolean b => (Cursor -> b) -> Axis

-- | Filter nodes that don't pass a check.
checkNode :: Boolean b => (Node -> b) -> Axis

-- | Filter elements that don't pass a check, and remove all non-elements.
checkElement :: Boolean b => (Element -> b) -> Axis

-- | Filter elements that don't pass a name check, and remove all
--   non-elements.
checkName :: Boolean b => (Name -> b) -> Axis

-- | Remove all non-elements. Compare roughly to XPath: <i>A node test * is
--   true for any node of the principal node type. For example, child::*
--   will select all element children of the context node [...]</i>.
anyElement :: Axis

-- | Select only those elements with a matching tag name. XPath: <i>A node
--   test that is a QName is true if and only if the type of the node (see
--   [5 Data Model]) is the principal node type and has an expanded-name
--   equal to the expanded-name specified by the QName.</i>
element :: Name -> Axis

-- | Select only those elements with a loosely matching tag name. Namespace
--   and case are ignored. XPath: <i>A node test that is a QName is true if
--   and only if the type of the node (see [5 Data Model]) is the principal
--   node type and has an expanded-name equal to the expanded-name
--   specified by the QName.</i>
laxElement :: Text -> Axis

-- | Select only text nodes, and directly give the <tt>Content</tt> values.
--   XPath: <i>The node test text() is true for any text node.</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
content :: Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). XPath: <i>the attribute axis contains the attributes of the
--   context node; the axis will be empty unless the context node is an
--   element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
attribute :: Name -> Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). Namespace and case are ignored. XPath: <i>the attribute axis
--   contains the attributes of the context node; the axis will be empty
--   unless the context node is an element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
laxAttribute :: Text -> Cursor -> [Text]

-- | Select only those element nodes with the given attribute.
hasAttribute :: Name -> Axis

-- | Select only those element nodes containing the given attribute
--   key/value pair.
attributeIs :: Name -> Text -> Axis

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> Cursor node -> [b]
infixr 1 &|

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &/

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &//

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> Cursor node -> [a]
infixr 1 &.//

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a
infixr 1 $|

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $/

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $//

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $.//

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Something that can be used in a predicate check as a boolean.
class Boolean a
bool :: Boolean a => a -> Bool
force :: (Exception e, MonadThrow f) => e -> [a] -> f a
forceM :: (Exception e, MonadThrow f) => e -> [f a] -> f a
instance Text.XML.Cursor.Boolean GHC.Types.Bool
instance Text.XML.Cursor.Boolean [a]
instance Text.XML.Cursor.Boolean (GHC.Maybe.Maybe a)
instance Text.XML.Cursor.Boolean (Data.Either.Either a b)
