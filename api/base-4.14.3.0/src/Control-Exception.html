<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Control/Exception.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE Trustworthy #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE NoImplicitPrelude, ExistentialQuantification #-}</span>
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-5"></a><span class='hs-comment'>-- |</span>
<a name="line-6"></a><span class='hs-comment'>-- Module      :  Control.Exception</span>
<a name="line-7"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow 2001</span>
<a name="line-8"></a><span class='hs-comment'>-- License     :  BSD-style (see the file libraries/base/LICENSE)</span>
<a name="line-9"></a><span class='hs-comment'>--</span>
<a name="line-10"></a><span class='hs-comment'>-- Maintainer  :  libraries@haskell.org</span>
<a name="line-11"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-12"></a><span class='hs-comment'>-- Portability :  non-portable (extended exceptions)</span>
<a name="line-13"></a><span class='hs-comment'>--</span>
<a name="line-14"></a><span class='hs-comment'>-- This module provides support for raising and catching both built-in</span>
<a name="line-15"></a><span class='hs-comment'>-- and user-defined exceptions.</span>
<a name="line-16"></a><span class='hs-comment'>--</span>
<a name="line-17"></a><span class='hs-comment'>-- In addition to exceptions thrown by 'IO' operations, exceptions may</span>
<a name="line-18"></a><span class='hs-comment'>-- be thrown by pure code (imprecise exceptions) or by external events</span>
<a name="line-19"></a><span class='hs-comment'>-- (asynchronous exceptions), but may only be caught in the 'IO' monad.</span>
<a name="line-20"></a><span class='hs-comment'>-- For more details, see:</span>
<a name="line-21"></a><span class='hs-comment'>--</span>
<a name="line-22"></a><span class='hs-comment'>--  * /A semantics for imprecise exceptions/, by Simon Peyton Jones,</span>
<a name="line-23"></a><span class='hs-comment'>--    Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson,</span>
<a name="line-24"></a><span class='hs-comment'>--    in /PLDI'99/.</span>
<a name="line-25"></a><span class='hs-comment'>--</span>
<a name="line-26"></a><span class='hs-comment'>--  * /Asynchronous exceptions in Haskell/, by Simon Marlow, Simon Peyton</span>
<a name="line-27"></a><span class='hs-comment'>--    Jones, Andy Moran and John Reppy, in /PLDI'01/.</span>
<a name="line-28"></a><span class='hs-comment'>--</span>
<a name="line-29"></a><span class='hs-comment'>--  * /An Extensible Dynamically-Typed Hierarchy of Exceptions/,</span>
<a name="line-30"></a><span class='hs-comment'>--    by Simon Marlow, in /Haskell '06/.</span>
<a name="line-31"></a><span class='hs-comment'>--</span>
<a name="line-32"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Control.Exception</span> <span class='hs-layout'>(</span>
<a name="line-35"></a>
<a name="line-36"></a>        <span class='hs-comment'>-- * The Exception type</span>
<a name="line-37"></a>        <span class='hs-conid'>SomeException</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-38"></a>        <span class='hs-conid'>Exception</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- class</span>
<a name="line-39"></a>        <span class='hs-conid'>IOException</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- instance Eq, Ord, Show, Typeable, Exception</span>
<a name="line-40"></a>        <span class='hs-conid'>ArithException</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- instance Eq, Ord, Show, Typeable, Exception</span>
<a name="line-41"></a>        <span class='hs-conid'>ArrayException</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- instance Eq, Ord, Show, Typeable, Exception</span>
<a name="line-42"></a>        <span class='hs-conid'>AssertionFailed</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-43"></a>        <span class='hs-conid'>SomeAsyncException</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-44"></a>        <span class='hs-conid'>AsyncException</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- instance Eq, Ord, Show, Typeable, Exception</span>
<a name="line-45"></a>        <span class='hs-varid'>asyncExceptionToException</span><span class='hs-layout'>,</span> <span class='hs-varid'>asyncExceptionFromException</span><span class='hs-layout'>,</span>
<a name="line-46"></a>
<a name="line-47"></a>        <span class='hs-conid'>NonTermination</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-48"></a>        <span class='hs-conid'>NestedAtomically</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-49"></a>        <span class='hs-conid'>BlockedIndefinitelyOnMVar</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-50"></a>        <span class='hs-conid'>BlockedIndefinitelyOnSTM</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-51"></a>        <span class='hs-conid'>AllocationLimitExceeded</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-52"></a>        <span class='hs-conid'>CompactionFailed</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-53"></a>        <span class='hs-conid'>Deadlock</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-54"></a>        <span class='hs-conid'>NoMethodError</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-55"></a>        <span class='hs-conid'>PatternMatchFail</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-56"></a>        <span class='hs-conid'>RecConError</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-57"></a>        <span class='hs-conid'>RecSelError</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-58"></a>        <span class='hs-conid'>RecUpdError</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-59"></a>        <span class='hs-conid'>ErrorCall</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-60"></a>        <span class='hs-conid'>TypeError</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-61"></a>
<a name="line-62"></a>        <span class='hs-comment'>-- * Throwing exceptions</span>
<a name="line-63"></a>        <span class='hs-varid'>throw</span><span class='hs-layout'>,</span>
<a name="line-64"></a>        <span class='hs-varid'>throwIO</span><span class='hs-layout'>,</span>
<a name="line-65"></a>        <span class='hs-varid'>ioError</span><span class='hs-layout'>,</span>
<a name="line-66"></a>        <span class='hs-varid'>throwTo</span><span class='hs-layout'>,</span>
<a name="line-67"></a>
<a name="line-68"></a>        <span class='hs-comment'>-- * Catching Exceptions</span>
<a name="line-69"></a>
<a name="line-70"></a>        <span class='hs-comment'>-- $catching</span>
<a name="line-71"></a>
<a name="line-72"></a>        <span class='hs-comment'>-- ** Catching all exceptions</span>
<a name="line-73"></a>
<a name="line-74"></a>        <span class='hs-comment'>-- $catchall</span>
<a name="line-75"></a>
<a name="line-76"></a>        <span class='hs-comment'>-- ** The @catch@ functions</span>
<a name="line-77"></a>        <span class='hs-varid'>catch</span><span class='hs-layout'>,</span>
<a name="line-78"></a>        <span class='hs-varid'>catches</span><span class='hs-layout'>,</span> <span class='hs-conid'>Handler</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-79"></a>        <span class='hs-varid'>catchJust</span><span class='hs-layout'>,</span>
<a name="line-80"></a>
<a name="line-81"></a>        <span class='hs-comment'>-- ** The @handle@ functions</span>
<a name="line-82"></a>        <span class='hs-varid'>handle</span><span class='hs-layout'>,</span>
<a name="line-83"></a>        <span class='hs-varid'>handleJust</span><span class='hs-layout'>,</span>
<a name="line-84"></a>
<a name="line-85"></a>        <span class='hs-comment'>-- ** The @try@ functions</span>
<a name="line-86"></a>        <span class='hs-varid'>try</span><span class='hs-layout'>,</span>
<a name="line-87"></a>        <span class='hs-varid'>tryJust</span><span class='hs-layout'>,</span>
<a name="line-88"></a>
<a name="line-89"></a>        <span class='hs-comment'>-- ** The @evaluate@ function</span>
<a name="line-90"></a>        <span class='hs-varid'>evaluate</span><span class='hs-layout'>,</span>
<a name="line-91"></a>
<a name="line-92"></a>        <span class='hs-comment'>-- ** The @mapException@ function</span>
<a name="line-93"></a>        <span class='hs-varid'>mapException</span><span class='hs-layout'>,</span>
<a name="line-94"></a>
<a name="line-95"></a>        <span class='hs-comment'>-- * Asynchronous Exceptions</span>
<a name="line-96"></a>
<a name="line-97"></a>        <span class='hs-comment'>-- $async</span>
<a name="line-98"></a>
<a name="line-99"></a>        <span class='hs-comment'>-- ** Asynchronous exception control</span>
<a name="line-100"></a>
<a name="line-101"></a>        <span class='hs-comment'>-- |The following functions allow a thread to control delivery of</span>
<a name="line-102"></a>        <span class='hs-comment'>-- asynchronous exceptions during a critical region.</span>
<a name="line-103"></a>
<a name="line-104"></a>        <span class='hs-varid'>mask</span><span class='hs-layout'>,</span>
<a name="line-105"></a>        <span class='hs-varid'>mask_</span><span class='hs-layout'>,</span>
<a name="line-106"></a>        <span class='hs-varid'>uninterruptibleMask</span><span class='hs-layout'>,</span>
<a name="line-107"></a>        <span class='hs-varid'>uninterruptibleMask_</span><span class='hs-layout'>,</span>
<a name="line-108"></a>        <span class='hs-conid'>MaskingState</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-109"></a>        <span class='hs-varid'>getMaskingState</span><span class='hs-layout'>,</span>
<a name="line-110"></a>        <span class='hs-varid'>interruptible</span><span class='hs-layout'>,</span>
<a name="line-111"></a>        <span class='hs-varid'>allowInterrupt</span><span class='hs-layout'>,</span>
<a name="line-112"></a>
<a name="line-113"></a>        <span class='hs-comment'>-- *** Applying @mask@ to an exception handler</span>
<a name="line-114"></a>
<a name="line-115"></a>        <span class='hs-comment'>-- $block_handler</span>
<a name="line-116"></a>
<a name="line-117"></a>        <span class='hs-comment'>-- *** Interruptible operations</span>
<a name="line-118"></a>
<a name="line-119"></a>        <span class='hs-comment'>-- $interruptible</span>
<a name="line-120"></a>
<a name="line-121"></a>        <span class='hs-comment'>-- * Assertions</span>
<a name="line-122"></a>
<a name="line-123"></a>        <span class='hs-varid'>assert</span><span class='hs-layout'>,</span>
<a name="line-124"></a>
<a name="line-125"></a>        <span class='hs-comment'>-- * Utilities</span>
<a name="line-126"></a>
<a name="line-127"></a>        <span class='hs-varid'>bracket</span><span class='hs-layout'>,</span>
<a name="line-128"></a>        <span class='hs-varid'>bracket_</span><span class='hs-layout'>,</span>
<a name="line-129"></a>        <span class='hs-varid'>bracketOnError</span><span class='hs-layout'>,</span>
<a name="line-130"></a>
<a name="line-131"></a>        <span class='hs-varid'>finally</span><span class='hs-layout'>,</span>
<a name="line-132"></a>        <span class='hs-varid'>onException</span><span class='hs-layout'>,</span>
<a name="line-133"></a>
<a name="line-134"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-135"></a>
<a name="line-136"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Exception.Base</span>
<a name="line-137"></a>
<a name="line-138"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Base</span>
<a name="line-139"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>interruptible</span><span class='hs-layout'>)</span>
<a name="line-140"></a>
<a name="line-141"></a><a name="Handler"></a><span class='hs-comment'>-- | You need this when using 'catches'.</span>
<a name="line-142"></a><a name="Handler"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Handler</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>e</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Exception</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Handler</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-143"></a>
<a name="line-144"></a><a name="instance%20Functor%20Handler"></a><span class='hs-comment'>-- | @since 4.6.0.0</span>
<a name="line-145"></a><a name="instance%20Functor%20Handler"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>Handler</span> <span class='hs-keyword'>where</span>
<a name="line-146"></a>     <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Handler</span> <span class='hs-varid'>h</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Handler</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>h</span><span class='hs-layout'>)</span>
<a name="line-147"></a>
<a name="line-148"></a><a name="catches"></a><span class='hs-comment'>{- |
<a name="line-149"></a>Sometimes you want to catch two different sorts of exception. You could
<a name="line-150"></a>do something like
<a name="line-151"></a>
<a name="line-152"></a>&gt; f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
<a name="line-153"></a>&gt;          `catch` \ (ex :: IOException)    -&gt; handleIO    ex
<a name="line-154"></a>
<a name="line-155"></a>However, there are a couple of problems with this approach. The first is
<a name="line-156"></a>that having two exception handlers is inefficient. However, the more
<a name="line-157"></a>serious issue is that the second exception handler will catch exceptions
<a name="line-158"></a>in the first, e.g. in the example above, if @handleArith@ throws an
<a name="line-159"></a>@IOException@ then the second exception handler will catch it.
<a name="line-160"></a>
<a name="line-161"></a>Instead, we provide a function 'catches', which would be used thus:
<a name="line-162"></a>
<a name="line-163"></a>&gt; f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
<a name="line-164"></a>&gt;                     Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
<a name="line-165"></a>-}</span>
<a name="line-166"></a><span class='hs-definition'>catches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Handler</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-167"></a><span class='hs-definition'>catches</span> <span class='hs-varid'>io</span> <span class='hs-varid'>handlers</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>io</span> <span class='hs-varop'>`catch`</span> <span class='hs-varid'>catchesHandler</span> <span class='hs-varid'>handlers</span>
<a name="line-168"></a>
<a name="line-169"></a><a name="catchesHandler"></a><span class='hs-definition'>catchesHandler</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Handler</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SomeException</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-170"></a><span class='hs-definition'>catchesHandler</span> <span class='hs-varid'>handlers</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>tryHandler</span> <span class='hs-layout'>(</span><span class='hs-varid'>throw</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>handlers</span>
<a name="line-171"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>tryHandler</span> <span class='hs-layout'>(</span><span class='hs-conid'>Handler</span> <span class='hs-varid'>handler</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span>
<a name="line-172"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fromException</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-173"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>handler</span> <span class='hs-varid'>e'</span>
<a name="line-174"></a>                <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>res</span>
<a name="line-175"></a>
<a name="line-176"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-177"></a><span class='hs-comment'>-- Catching exceptions</span>
<a name="line-178"></a>
<a name="line-179"></a><span class='hs-comment'>{- $catching
<a name="line-180"></a>
<a name="line-181"></a>There are several functions for catching and examining
<a name="line-182"></a>exceptions; all of them may only be used from within the
<a name="line-183"></a>'IO' monad.
<a name="line-184"></a>
<a name="line-185"></a>Here's a rule of thumb for deciding which catch-style function to
<a name="line-186"></a>use:
<a name="line-187"></a>
<a name="line-188"></a> * If you want to do some cleanup in the event that an exception
<a name="line-189"></a>   is raised, use 'finally', 'bracket' or 'onException'.
<a name="line-190"></a>
<a name="line-191"></a> * To recover after an exception and do something else, the best
<a name="line-192"></a>   choice is to use one of the 'try' family.
<a name="line-193"></a>
<a name="line-194"></a> * ... unless you are recovering from an asynchronous exception, in which
<a name="line-195"></a>   case use 'catch' or 'catchJust'.
<a name="line-196"></a>
<a name="line-197"></a>The difference between using 'try' and 'catch' for recovery is that in
<a name="line-198"></a>'catch' the handler is inside an implicit 'mask' (see \"Asynchronous
<a name="line-199"></a>Exceptions\") which is important when catching asynchronous
<a name="line-200"></a>exceptions, but when catching other kinds of exception it is
<a name="line-201"></a>unnecessary.  Furthermore it is possible to accidentally stay inside
<a name="line-202"></a>the implicit 'mask' by tail-calling rather than returning from the
<a name="line-203"></a>handler, which is why we recommend using 'try' rather than 'catch' for
<a name="line-204"></a>ordinary exception recovery.
<a name="line-205"></a>
<a name="line-206"></a>A typical use of 'tryJust' for recovery looks like this:
<a name="line-207"></a>
<a name="line-208"></a>&gt;  do r &lt;- tryJust (guard . isDoesNotExistError) $ getEnv "HOME"
<a name="line-209"></a>&gt;     case r of
<a name="line-210"></a>&gt;       Left  e    -&gt; ...
<a name="line-211"></a>&gt;       Right home -&gt; ...
<a name="line-212"></a>
<a name="line-213"></a>-}</span>
<a name="line-214"></a>
<a name="line-215"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-216"></a><span class='hs-comment'>-- Asynchronous exceptions</span>
<a name="line-217"></a>
<a name="line-218"></a><a name="allowInterrupt"></a><span class='hs-comment'>-- | When invoked inside 'mask', this function allows a masked</span>
<a name="line-219"></a><span class='hs-comment'>-- asynchronous exception to be raised, if one exists.  It is</span>
<a name="line-220"></a><span class='hs-comment'>-- equivalent to performing an interruptible operation (see</span>
<a name="line-221"></a><span class='hs-comment'>-- #interruptible), but does not involve any actual blocking.</span>
<a name="line-222"></a><span class='hs-comment'>--</span>
<a name="line-223"></a><span class='hs-comment'>-- When called outside 'mask', or inside 'uninterruptibleMask', this</span>
<a name="line-224"></a><span class='hs-comment'>-- function has no effect.</span>
<a name="line-225"></a><span class='hs-comment'>--</span>
<a name="line-226"></a><span class='hs-comment'>-- @since 4.4.0.0</span>
<a name="line-227"></a><span class='hs-definition'>allowInterrupt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-228"></a><span class='hs-definition'>allowInterrupt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interruptible</span> <span class='hs-varop'>$</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-229"></a>
<a name="line-230"></a><span class='hs-comment'>{- $async
<a name="line-231"></a>
<a name="line-232"></a> #AsynchronousExceptions# Asynchronous exceptions are so-called because they arise due to
<a name="line-233"></a>external influences, and can be raised at any point during execution.
<a name="line-234"></a>'StackOverflow' and 'HeapOverflow' are two examples of
<a name="line-235"></a>system-generated asynchronous exceptions.
<a name="line-236"></a>
<a name="line-237"></a>The primary source of asynchronous exceptions, however, is
<a name="line-238"></a>'throwTo':
<a name="line-239"></a>
<a name="line-240"></a>&gt;  throwTo :: ThreadId -&gt; Exception -&gt; IO ()
<a name="line-241"></a>
<a name="line-242"></a>'throwTo' (also 'Control.Concurrent.killThread') allows one
<a name="line-243"></a>running thread to raise an arbitrary exception in another thread.  The
<a name="line-244"></a>exception is therefore asynchronous with respect to the target thread,
<a name="line-245"></a>which could be doing anything at the time it receives the exception.
<a name="line-246"></a>Great care should be taken with asynchronous exceptions; it is all too
<a name="line-247"></a>easy to introduce race conditions by the over zealous use of
<a name="line-248"></a>'throwTo'.
<a name="line-249"></a>-}</span>
<a name="line-250"></a>
<a name="line-251"></a><span class='hs-comment'>{- $block_handler
<a name="line-252"></a>There\'s an implied 'mask' around every exception handler in a call
<a name="line-253"></a>to one of the 'catch' family of functions.  This is because that is
<a name="line-254"></a>what you want most of the time - it eliminates a common race condition
<a name="line-255"></a>in starting an exception handler, because there may be no exception
<a name="line-256"></a>handler on the stack to handle another exception if one arrives
<a name="line-257"></a>immediately.  If asynchronous exceptions are masked on entering the
<a name="line-258"></a>handler, though, we have time to install a new exception handler
<a name="line-259"></a>before being interrupted.  If this weren\'t the default, one would have
<a name="line-260"></a>to write something like
<a name="line-261"></a>
<a name="line-262"></a>&gt;      mask $ \restore -&gt;
<a name="line-263"></a>&gt;           catch (restore (...))
<a name="line-264"></a>&gt;                 (\e -&gt; handler)
<a name="line-265"></a>
<a name="line-266"></a>If you need to unmask asynchronous exceptions again in the exception
<a name="line-267"></a>handler, @restore@ can be used there too.
<a name="line-268"></a>
<a name="line-269"></a>Note that 'try' and friends /do not/ have a similar default, because
<a name="line-270"></a>there is no exception handler in this case.  Don't use 'try' for
<a name="line-271"></a>recovering from an asynchronous exception.
<a name="line-272"></a>-}</span>
<a name="line-273"></a>
<a name="line-274"></a><span class='hs-comment'>{- $interruptible
<a name="line-275"></a>
<a name="line-276"></a> #interruptible#
<a name="line-277"></a>Some operations are /interruptible/, which means that they can receive
<a name="line-278"></a>asynchronous exceptions even in the scope of a 'mask'.  Any function
<a name="line-279"></a>which may itself block is defined as interruptible; this includes
<a name="line-280"></a>'Control.Concurrent.MVar.takeMVar'
<a name="line-281"></a>(but not 'Control.Concurrent.MVar.tryTakeMVar'),
<a name="line-282"></a>and most operations which perform
<a name="line-283"></a>some I\/O with the outside world.  The reason for having
<a name="line-284"></a>interruptible operations is so that we can write things like
<a name="line-285"></a>
<a name="line-286"></a>&gt;      mask $ \restore -&gt; do
<a name="line-287"></a>&gt;         a &lt;- takeMVar m
<a name="line-288"></a>&gt;         catch (restore (...))
<a name="line-289"></a>&gt;               (\e -&gt; ...)
<a name="line-290"></a>
<a name="line-291"></a>if the 'Control.Concurrent.MVar.takeMVar' was not interruptible,
<a name="line-292"></a>then this particular
<a name="line-293"></a>combination could lead to deadlock, because the thread itself would be
<a name="line-294"></a>blocked in a state where it can\'t receive any asynchronous exceptions.
<a name="line-295"></a>With 'Control.Concurrent.MVar.takeMVar' interruptible, however, we can be
<a name="line-296"></a>safe in the knowledge that the thread can receive exceptions right up
<a name="line-297"></a>until the point when the 'Control.Concurrent.MVar.takeMVar' succeeds.
<a name="line-298"></a>Similar arguments apply for other interruptible operations like
<a name="line-299"></a>'System.IO.openFile'.
<a name="line-300"></a>
<a name="line-301"></a>It is useful to think of 'mask' not as a way to completely prevent
<a name="line-302"></a>asynchronous exceptions, but as a way to switch from asynchronous mode
<a name="line-303"></a>to polling mode.  The main difficulty with asynchronous
<a name="line-304"></a>exceptions is that they normally can occur anywhere, but within a
<a name="line-305"></a>'mask' an asynchronous exception is only raised by operations that are
<a name="line-306"></a>interruptible (or call other interruptible operations).  In many cases
<a name="line-307"></a>these operations may themselves raise exceptions, such as I\/O errors,
<a name="line-308"></a>so the caller will usually be prepared to handle exceptions arising from the
<a name="line-309"></a>operation anyway.  To perform an explicit poll for asynchronous exceptions
<a name="line-310"></a>inside 'mask', use 'allowInterrupt'.
<a name="line-311"></a>
<a name="line-312"></a>Sometimes it is too onerous to handle exceptions in the middle of a
<a name="line-313"></a>critical piece of stateful code.  There are three ways to handle this
<a name="line-314"></a>kind of situation:
<a name="line-315"></a>
<a name="line-316"></a> * Use STM.  Since a transaction is always either completely executed
<a name="line-317"></a>   or not at all, transactions are a good way to maintain invariants
<a name="line-318"></a>   over state in the presence of asynchronous (and indeed synchronous)
<a name="line-319"></a>   exceptions.
<a name="line-320"></a>
<a name="line-321"></a> * Use 'mask', and avoid interruptible operations.  In order to do
<a name="line-322"></a>   this, we have to know which operations are interruptible.  It is
<a name="line-323"></a>   impossible to know for any given library function whether it might
<a name="line-324"></a>   invoke an interruptible operation internally; so instead we give a
<a name="line-325"></a>   list of guaranteed-not-to-be-interruptible operations below.
<a name="line-326"></a>
<a name="line-327"></a> * Use 'uninterruptibleMask'.  This is generally not recommended,
<a name="line-328"></a>   unless you can guarantee that any interruptible operations invoked
<a name="line-329"></a>   during the scope of 'uninterruptibleMask' can only ever block for
<a name="line-330"></a>   a short time.  Otherwise, 'uninterruptibleMask' is a good way to
<a name="line-331"></a>   make your program deadlock and be unresponsive to user interrupts.
<a name="line-332"></a>
<a name="line-333"></a>The following operations are guaranteed not to be interruptible:
<a name="line-334"></a>
<a name="line-335"></a> * operations on 'Data.IORef.IORef' from "Data.IORef"
<a name="line-336"></a>
<a name="line-337"></a> * STM transactions that do not use 'GHC.Conc.retry'
<a name="line-338"></a>
<a name="line-339"></a> * everything from the @Foreign@ modules
<a name="line-340"></a>
<a name="line-341"></a> * everything from "Control.Exception" except for 'throwTo'
<a name="line-342"></a>
<a name="line-343"></a> * 'Control.Concurrent.MVar.tryTakeMVar', 'Control.Concurrent.MVar.tryPutMVar',
<a name="line-344"></a>   'Control.Concurrent.MVar.isEmptyMVar'
<a name="line-345"></a>
<a name="line-346"></a> * 'Control.Concurrent.MVar.takeMVar' if the 'Control.Concurrent.MVar.MVar' is
<a name="line-347"></a>   definitely full, and conversely 'Control.Concurrent.MVar.putMVar' if the
<a name="line-348"></a>   'Control.Concurrent.MVar.MVar' is definitely empty
<a name="line-349"></a>
<a name="line-350"></a> * 'Control.Concurrent.MVar.newEmptyMVar', 'Control.Concurrent.MVar.newMVar'
<a name="line-351"></a>
<a name="line-352"></a> * 'Control.Concurrent.forkIO', 'Control.Concurrent.myThreadId'
<a name="line-353"></a>
<a name="line-354"></a>-}</span>
<a name="line-355"></a>
<a name="line-356"></a><span class='hs-comment'>{- $catchall
<a name="line-357"></a>
<a name="line-358"></a>It is possible to catch all exceptions, by using the type 'SomeException':
<a name="line-359"></a>
<a name="line-360"></a>&gt; catch f (\e -&gt; ... (e :: SomeException) ...)
<a name="line-361"></a>
<a name="line-362"></a>HOWEVER, this is normally not what you want to do!
<a name="line-363"></a>
<a name="line-364"></a>For example, suppose you want to read a file, but if it doesn't exist
<a name="line-365"></a>then continue as if it contained \"\".  You might be tempted to just
<a name="line-366"></a>catch all exceptions and return \"\" in the handler. However, this has
<a name="line-367"></a>all sorts of undesirable consequences.  For example, if the user
<a name="line-368"></a>presses control-C at just the right moment then the 'UserInterrupt'
<a name="line-369"></a>exception will be caught, and the program will continue running under
<a name="line-370"></a>the belief that the file contains \"\".  Similarly, if another thread
<a name="line-371"></a>tries to kill the thread reading the file then the 'ThreadKilled'
<a name="line-372"></a>exception will be ignored.
<a name="line-373"></a>
<a name="line-374"></a>Instead, you should only catch exactly the exceptions that you really
<a name="line-375"></a>want. In this case, this would likely be more specific than even
<a name="line-376"></a>\"any IO exception\"; a permissions error would likely also want to be
<a name="line-377"></a>handled differently. Instead, you would probably want something like:
<a name="line-378"></a>
<a name="line-379"></a>&gt; e &lt;- tryJust (guard . isDoesNotExistError) (readFile f)
<a name="line-380"></a>&gt; let str = either (const "") id e
<a name="line-381"></a>
<a name="line-382"></a>There are occasions when you really do need to catch any sort of
<a name="line-383"></a>exception. However, in most cases this is just so you can do some
<a name="line-384"></a>cleaning up; you aren't actually interested in the exception itself.
<a name="line-385"></a>For example, if you open a file then you want to close it again,
<a name="line-386"></a>whether processing the file executes normally or throws an exception.
<a name="line-387"></a>However, in these cases you can use functions like 'bracket', 'finally'
<a name="line-388"></a>and 'onException', which never actually pass you the exception, but
<a name="line-389"></a>just call the cleanup functions at the appropriate points.
<a name="line-390"></a>
<a name="line-391"></a>But sometimes you really do need to catch any exception, and actually
<a name="line-392"></a>see what the exception is. One example is at the very top-level of a
<a name="line-393"></a>program, you may wish to catch any exception, print it to a logfile or
<a name="line-394"></a>the screen, and then exit gracefully. For these cases, you can use
<a name="line-395"></a>'catch' (or one of the other exception-catching functions) with the
<a name="line-396"></a>'SomeException' type.
<a name="line-397"></a>-}</span>
<a name="line-398"></a>
</pre></body>
</html>
