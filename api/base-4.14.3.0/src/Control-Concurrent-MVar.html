<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Control/Concurrent/MVar.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE Trustworthy #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE NoImplicitPrelude, UnboxedTuples, MagicHash #-}</span>
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-5"></a><span class='hs-comment'>-- |</span>
<a name="line-6"></a><span class='hs-comment'>-- Module      :  Control.Concurrent.MVar</span>
<a name="line-7"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow 2001</span>
<a name="line-8"></a><span class='hs-comment'>-- License     :  BSD-style (see the file libraries/base/LICENSE)</span>
<a name="line-9"></a><span class='hs-comment'>-- </span>
<a name="line-10"></a><span class='hs-comment'>-- Maintainer  :  libraries@haskell.org</span>
<a name="line-11"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-12"></a><span class='hs-comment'>-- Portability :  non-portable (concurrency)</span>
<a name="line-13"></a><span class='hs-comment'>--</span>
<a name="line-14"></a><span class='hs-comment'>-- An @'MVar' t@ is mutable location that is either empty or contains a</span>
<a name="line-15"></a><span class='hs-comment'>-- value of type @t@.  It has two fundamental operations: 'putMVar'</span>
<a name="line-16"></a><span class='hs-comment'>-- which fills an 'MVar' if it is empty and blocks otherwise, and</span>
<a name="line-17"></a><span class='hs-comment'>-- 'takeMVar' which empties an 'MVar' if it is full and blocks</span>
<a name="line-18"></a><span class='hs-comment'>-- otherwise.  They can be used in multiple different ways:</span>
<a name="line-19"></a><span class='hs-comment'>--</span>
<a name="line-20"></a><span class='hs-comment'>--   1. As synchronized mutable variables,</span>
<a name="line-21"></a><span class='hs-comment'>--</span>
<a name="line-22"></a><span class='hs-comment'>--   2. As channels, with 'takeMVar' and 'putMVar' as receive and send, and</span>
<a name="line-23"></a><span class='hs-comment'>--</span>
<a name="line-24"></a><span class='hs-comment'>--   3. As a binary semaphore @'MVar' ()@, with 'takeMVar' and 'putMVar' as</span>
<a name="line-25"></a><span class='hs-comment'>--      wait and signal.</span>
<a name="line-26"></a><span class='hs-comment'>--</span>
<a name="line-27"></a><span class='hs-comment'>-- They were introduced in the paper</span>
<a name="line-28"></a><span class='hs-comment'>-- &lt;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz "Concurrent Haskell"&gt;</span>
<a name="line-29"></a><span class='hs-comment'>-- by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though</span>
<a name="line-30"></a><span class='hs-comment'>-- some details of their implementation have since then changed (in</span>
<a name="line-31"></a><span class='hs-comment'>-- particular, a put on a full 'MVar' used to error, but now merely</span>
<a name="line-32"></a><span class='hs-comment'>-- blocks.)</span>
<a name="line-33"></a><span class='hs-comment'>--</span>
<a name="line-34"></a><span class='hs-comment'>-- === Applicability</span>
<a name="line-35"></a><span class='hs-comment'>--</span>
<a name="line-36"></a><span class='hs-comment'>-- 'MVar's offer more flexibility than 'Data.IORef.IORef's, but less flexibility</span>
<a name="line-37"></a><span class='hs-comment'>-- than 'GHC.Conc.STM'.  They are appropriate for building synchronization</span>
<a name="line-38"></a><span class='hs-comment'>-- primitives and performing simple interthread communication; however</span>
<a name="line-39"></a><span class='hs-comment'>-- they are very simple and susceptible to race conditions, deadlocks or</span>
<a name="line-40"></a><span class='hs-comment'>-- uncaught exceptions.  Do not use them if you need perform larger</span>
<a name="line-41"></a><span class='hs-comment'>-- atomic operations such as reading from multiple variables: use 'GHC.Conc.STM'</span>
<a name="line-42"></a><span class='hs-comment'>-- instead.</span>
<a name="line-43"></a><span class='hs-comment'>--</span>
<a name="line-44"></a><span class='hs-comment'>-- In particular, the "bigger" functions in this module ('swapMVar',</span>
<a name="line-45"></a><span class='hs-comment'>-- 'withMVar', 'modifyMVar_' and 'modifyMVar') are simply</span>
<a name="line-46"></a><span class='hs-comment'>-- the composition of a 'takeMVar' followed by a 'putMVar' with</span>
<a name="line-47"></a><span class='hs-comment'>-- exception safety.</span>
<a name="line-48"></a><span class='hs-comment'>-- These only have atomicity guarantees if all other threads</span>
<a name="line-49"></a><span class='hs-comment'>-- perform a 'takeMVar' before a 'putMVar' as well;  otherwise, they may</span>
<a name="line-50"></a><span class='hs-comment'>-- block.</span>
<a name="line-51"></a><span class='hs-comment'>--</span>
<a name="line-52"></a><span class='hs-comment'>-- === Fairness</span>
<a name="line-53"></a><span class='hs-comment'>--</span>
<a name="line-54"></a><span class='hs-comment'>-- No thread can be blocked indefinitely on an 'MVar' unless another</span>
<a name="line-55"></a><span class='hs-comment'>-- thread holds that 'MVar' indefinitely.  One usual implementation of</span>
<a name="line-56"></a><span class='hs-comment'>-- this fairness guarantee is that threads blocked on an 'MVar' are</span>
<a name="line-57"></a><span class='hs-comment'>-- served in a first-in-first-out fashion, but this is not guaranteed</span>
<a name="line-58"></a><span class='hs-comment'>-- in the semantics.</span>
<a name="line-59"></a><span class='hs-comment'>--</span>
<a name="line-60"></a><span class='hs-comment'>-- === Gotchas</span>
<a name="line-61"></a><span class='hs-comment'>--</span>
<a name="line-62"></a><span class='hs-comment'>-- Like many other Haskell data structures, 'MVar's are lazy.  This</span>
<a name="line-63"></a><span class='hs-comment'>-- means that if you place an expensive unevaluated thunk inside an</span>
<a name="line-64"></a><span class='hs-comment'>-- 'MVar', it will be evaluated by the thread that consumes it, not the</span>
<a name="line-65"></a><span class='hs-comment'>-- thread that produced it.  Be sure to 'evaluate' values to be placed</span>
<a name="line-66"></a><span class='hs-comment'>-- in an 'MVar' to the appropriate normal form, or utilize a strict</span>
<a name="line-67"></a><span class='hs-comment'>-- MVar provided by the strict-concurrency package.</span>
<a name="line-68"></a><span class='hs-comment'>--</span>
<a name="line-69"></a><span class='hs-comment'>-- === Ordering</span>
<a name="line-70"></a><span class='hs-comment'>--</span>
<a name="line-71"></a><span class='hs-comment'>-- 'MVar' operations are always observed to take place in the order</span>
<a name="line-72"></a><span class='hs-comment'>-- they are written in the program, regardless of the memory model of</span>
<a name="line-73"></a><span class='hs-comment'>-- the underlying machine.  This is in contrast to 'Data.IORef.IORef' operations</span>
<a name="line-74"></a><span class='hs-comment'>-- which may appear out-of-order to another thread in some cases.</span>
<a name="line-75"></a><span class='hs-comment'>--</span>
<a name="line-76"></a><span class='hs-comment'>-- === Example</span>
<a name="line-77"></a><span class='hs-comment'>--</span>
<a name="line-78"></a><span class='hs-comment'>-- Consider the following concurrent data structure, a skip channel.</span>
<a name="line-79"></a><span class='hs-comment'>-- This is a channel for an intermittent source of high bandwidth</span>
<a name="line-80"></a><span class='hs-comment'>-- information (for example, mouse movement events.)  Writing to the</span>
<a name="line-81"></a><span class='hs-comment'>-- channel never blocks, and reading from the channel only returns the</span>
<a name="line-82"></a><span class='hs-comment'>-- most recent value, or blocks if there are no new values.  Multiple</span>
<a name="line-83"></a><span class='hs-comment'>-- readers are supported with a @dupSkipChan@ operation.</span>
<a name="line-84"></a><span class='hs-comment'>--</span>
<a name="line-85"></a><span class='hs-comment'>-- A skip channel is a pair of 'MVar's. The first 'MVar' contains the</span>
<a name="line-86"></a><span class='hs-comment'>-- current value, and a list of semaphores that need to be notified</span>
<a name="line-87"></a><span class='hs-comment'>-- when it changes. The second 'MVar' is a semaphore for this particular</span>
<a name="line-88"></a><span class='hs-comment'>-- reader: it is full if there is a value in the channel that this</span>
<a name="line-89"></a><span class='hs-comment'>-- reader has not read yet, and empty otherwise.</span>
<a name="line-90"></a><span class='hs-comment'>--</span>
<a name="line-91"></a><span class='hs-comment'>-- @</span>
<a name="line-92"></a><span class='hs-comment'>--     data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())</span>
<a name="line-93"></a><span class='hs-comment'>--</span>
<a name="line-94"></a><span class='hs-comment'>--     newSkipChan :: IO (SkipChan a)</span>
<a name="line-95"></a><span class='hs-comment'>--     newSkipChan = do</span>
<a name="line-96"></a><span class='hs-comment'>--         sem &lt;- newEmptyMVar</span>
<a name="line-97"></a><span class='hs-comment'>--         main &lt;- newMVar (undefined, [sem])</span>
<a name="line-98"></a><span class='hs-comment'>--         return (SkipChan main sem)</span>
<a name="line-99"></a><span class='hs-comment'>--</span>
<a name="line-100"></a><span class='hs-comment'>--     putSkipChan :: SkipChan a -&gt; a -&gt; IO ()</span>
<a name="line-101"></a><span class='hs-comment'>--     putSkipChan (SkipChan main _) v = do</span>
<a name="line-102"></a><span class='hs-comment'>--         (_, sems) &lt;- takeMVar main</span>
<a name="line-103"></a><span class='hs-comment'>--         putMVar main (v, [])</span>
<a name="line-104"></a><span class='hs-comment'>--         mapM_ (\sem -&gt; putMVar sem ()) sems</span>
<a name="line-105"></a><span class='hs-comment'>--</span>
<a name="line-106"></a><span class='hs-comment'>--     getSkipChan :: SkipChan a -&gt; IO a</span>
<a name="line-107"></a><span class='hs-comment'>--     getSkipChan (SkipChan main sem) = do</span>
<a name="line-108"></a><span class='hs-comment'>--         takeMVar sem</span>
<a name="line-109"></a><span class='hs-comment'>--         (v, sems) &lt;- takeMVar main</span>
<a name="line-110"></a><span class='hs-comment'>--         putMVar main (v, sem:sems)</span>
<a name="line-111"></a><span class='hs-comment'>--         return v</span>
<a name="line-112"></a><span class='hs-comment'>--</span>
<a name="line-113"></a><span class='hs-comment'>--     dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)</span>
<a name="line-114"></a><span class='hs-comment'>--     dupSkipChan (SkipChan main _) = do</span>
<a name="line-115"></a><span class='hs-comment'>--         sem &lt;- newEmptyMVar</span>
<a name="line-116"></a><span class='hs-comment'>--         (v, sems) &lt;- takeMVar main</span>
<a name="line-117"></a><span class='hs-comment'>--         putMVar main (v, sem:sems)</span>
<a name="line-118"></a><span class='hs-comment'>--         return (SkipChan main sem)</span>
<a name="line-119"></a><span class='hs-comment'>-- @</span>
<a name="line-120"></a><span class='hs-comment'>--</span>
<a name="line-121"></a><span class='hs-comment'>-- This example was adapted from the original Concurrent Haskell paper.</span>
<a name="line-122"></a><span class='hs-comment'>-- For more examples of 'MVar's being used to build higher-level</span>
<a name="line-123"></a><span class='hs-comment'>-- synchronization primitives, see 'Control.Concurrent.Chan' and</span>
<a name="line-124"></a><span class='hs-comment'>-- 'Control.Concurrent.QSem'.</span>
<a name="line-125"></a><span class='hs-comment'>--</span>
<a name="line-126"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-127"></a>
<a name="line-128"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Control.Concurrent.MVar</span>
<a name="line-129"></a>        <span class='hs-layout'>(</span>
<a name="line-130"></a>          <span class='hs-comment'>-- * @MVar@s</span>
<a name="line-131"></a>          <span class='hs-conid'>MVar</span>
<a name="line-132"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>newEmptyMVar</span>
<a name="line-133"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>newMVar</span>
<a name="line-134"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>takeMVar</span>
<a name="line-135"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>putMVar</span>
<a name="line-136"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>readMVar</span>
<a name="line-137"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>swapMVar</span>
<a name="line-138"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>tryTakeMVar</span>
<a name="line-139"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>tryPutMVar</span>
<a name="line-140"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>isEmptyMVar</span>
<a name="line-141"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>withMVar</span>
<a name="line-142"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>withMVarMasked</span>
<a name="line-143"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>modifyMVar_</span>
<a name="line-144"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>modifyMVar</span>
<a name="line-145"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>modifyMVarMasked_</span>
<a name="line-146"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>modifyMVarMasked</span>
<a name="line-147"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>tryReadMVar</span>
<a name="line-148"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>mkWeakMVar</span>
<a name="line-149"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>addMVarFinalizer</span>
<a name="line-150"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-151"></a>
<a name="line-152"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.MVar</span> <span class='hs-layout'>(</span> <span class='hs-conid'>MVar</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>newEmptyMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>newMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>takeMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>putMVar</span><span class='hs-layout'>,</span>
<a name="line-153"></a>                  <span class='hs-varid'>tryTakeMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>tryPutMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>isEmptyMVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>readMVar</span><span class='hs-layout'>,</span>
<a name="line-154"></a>                  <span class='hs-varid'>tryReadMVar</span>
<a name="line-155"></a>                <span class='hs-layout'>)</span>
<a name="line-156"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.MVar</span>
<a name="line-157"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Weak</span>
<a name="line-158"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Base</span>
<a name="line-159"></a>
<a name="line-160"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Exception.Base</span>
<a name="line-161"></a>
<a name="line-162"></a><a name="swapMVar"></a><span class='hs-comment'>{-|
<a name="line-163"></a>  Take a value from an 'MVar', put a new value into the 'MVar' and
<a name="line-164"></a>  return the value taken. This function is atomic only if there are
<a name="line-165"></a>  no other producers for this 'MVar'.
<a name="line-166"></a>-}</span>
<a name="line-167"></a><span class='hs-definition'>swapMVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-168"></a><span class='hs-definition'>swapMVar</span> <span class='hs-varid'>mvar</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>=</span>
<a name="line-169"></a>  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-170"></a>    <span class='hs-varid'>old</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>mvar</span>
<a name="line-171"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>mvar</span> <span class='hs-varid'>new</span>
<a name="line-172"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>old</span>
<a name="line-173"></a>
<a name="line-174"></a><a name="withMVar"></a><span class='hs-comment'>{-|
<a name="line-175"></a>  'withMVar' is an exception-safe wrapper for operating on the contents
<a name="line-176"></a>  of an 'MVar'.  This operation is exception-safe: it will replace the
<a name="line-177"></a>  original contents of the 'MVar' if an exception is raised (see
<a name="line-178"></a>  "Control.Exception").  However, it is only atomic if there are no
<a name="line-179"></a>  other producers for this 'MVar'.
<a name="line-180"></a>-}</span>
<a name="line-181"></a><span class='hs-comment'>{-# INLINE withMVar #-}</span>
<a name="line-182"></a><span class='hs-comment'>-- inlining has been reported to have dramatic effects; see</span>
<a name="line-183"></a><span class='hs-comment'>-- <a href="http://www.haskell.org//pipermail/haskell/2006-May/017907.html">http://www.haskell.org//pipermail/haskell/2006-May/017907.html</a></span>
<a name="line-184"></a><span class='hs-definition'>withMVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-185"></a><span class='hs-definition'>withMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-186"></a>  <span class='hs-varid'>mask</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>restore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-187"></a>    <span class='hs-varid'>a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-188"></a>    <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>restore</span> <span class='hs-layout'>(</span><span class='hs-varid'>io</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-189"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-190"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>b</span>
<a name="line-191"></a>
<a name="line-192"></a><a name="withMVarMasked"></a><span class='hs-comment'>{-|
<a name="line-193"></a>  Like 'withMVar', but the @IO@ action in the second argument is executed
<a name="line-194"></a>  with asynchronous exceptions masked.
<a name="line-195"></a>
<a name="line-196"></a>  @since 4.7.0.0
<a name="line-197"></a>-}</span>
<a name="line-198"></a><span class='hs-comment'>{-# INLINE withMVarMasked #-}</span>
<a name="line-199"></a><span class='hs-definition'>withMVarMasked</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-200"></a><span class='hs-definition'>withMVarMasked</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-201"></a>  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-202"></a>    <span class='hs-varid'>a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-203"></a>    <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>io</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-204"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-205"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>b</span>
<a name="line-206"></a>
<a name="line-207"></a><a name="modifyMVar_"></a><span class='hs-comment'>{-|
<a name="line-208"></a>  An exception-safe wrapper for modifying the contents of an 'MVar'.
<a name="line-209"></a>  Like 'withMVar', 'modifyMVar' will replace the original contents of
<a name="line-210"></a>  the 'MVar' if an exception is raised during the operation.  This
<a name="line-211"></a>  function is only atomic if there are no other producers for this
<a name="line-212"></a>  'MVar'.
<a name="line-213"></a>-}</span>
<a name="line-214"></a><span class='hs-comment'>{-# INLINE modifyMVar_ #-}</span>
<a name="line-215"></a><span class='hs-definition'>modifyMVar_</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-216"></a><span class='hs-definition'>modifyMVar_</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-217"></a>  <span class='hs-varid'>mask</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>restore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-218"></a>    <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-219"></a>    <span class='hs-varid'>a'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>restore</span> <span class='hs-layout'>(</span><span class='hs-varid'>io</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-220"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a'</span>
<a name="line-221"></a>
<a name="line-222"></a><a name="modifyMVar"></a><span class='hs-comment'>{-|
<a name="line-223"></a>  A slight variation on 'modifyMVar_' that allows a value to be
<a name="line-224"></a>  returned (@b@) in addition to the modified value of the 'MVar'.
<a name="line-225"></a>-}</span>
<a name="line-226"></a><span class='hs-comment'>{-# INLINE modifyMVar #-}</span>
<a name="line-227"></a><span class='hs-definition'>modifyMVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-228"></a><span class='hs-definition'>modifyMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-229"></a>  <span class='hs-varid'>mask</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>restore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-230"></a>    <span class='hs-varid'>a</span>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-231"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>restore</span> <span class='hs-layout'>(</span><span class='hs-varid'>io</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>evaluate</span><span class='hs-layout'>)</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-232"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a'</span>
<a name="line-233"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>b</span>
<a name="line-234"></a>
<a name="line-235"></a><a name="modifyMVarMasked_"></a><span class='hs-comment'>{-|
<a name="line-236"></a>  Like 'modifyMVar_', but the @IO@ action in the second argument is executed with
<a name="line-237"></a>  asynchronous exceptions masked.
<a name="line-238"></a>
<a name="line-239"></a>  @since 4.6.0.0
<a name="line-240"></a>-}</span>
<a name="line-241"></a><span class='hs-comment'>{-# INLINE modifyMVarMasked_ #-}</span>
<a name="line-242"></a><span class='hs-definition'>modifyMVarMasked_</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-243"></a><span class='hs-definition'>modifyMVarMasked_</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-244"></a>  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-245"></a>    <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-246"></a>    <span class='hs-varid'>a'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>io</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-247"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a'</span>
<a name="line-248"></a>
<a name="line-249"></a><a name="modifyMVarMasked"></a><span class='hs-comment'>{-|
<a name="line-250"></a>  Like 'modifyMVar', but the @IO@ action in the second argument is executed with
<a name="line-251"></a>  asynchronous exceptions masked.
<a name="line-252"></a>
<a name="line-253"></a>  @since 4.6.0.0
<a name="line-254"></a>-}</span>
<a name="line-255"></a><span class='hs-comment'>{-# INLINE modifyMVarMasked #-}</span>
<a name="line-256"></a><span class='hs-definition'>modifyMVarMasked</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-257"></a><span class='hs-definition'>modifyMVarMasked</span> <span class='hs-varid'>m</span> <span class='hs-varid'>io</span> <span class='hs-keyglyph'>=</span>
<a name="line-258"></a>  <span class='hs-varid'>mask_</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-259"></a>    <span class='hs-varid'>a</span>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>takeMVar</span> <span class='hs-varid'>m</span>
<a name="line-260"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-layout'>(</span><span class='hs-varid'>io</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>evaluate</span><span class='hs-layout'>)</span> <span class='hs-varop'>`onException`</span> <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-261"></a>    <span class='hs-varid'>putMVar</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a'</span>
<a name="line-262"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>b</span>
<a name="line-263"></a>
<a name="line-264"></a><span class='hs-comment'>{-# DEPRECATED addMVarFinalizer "use 'mkWeakMVar' instead" #-}</span> <span class='hs-comment'>-- deprecated in 7.6</span>
<a name="line-265"></a><a name="addMVarFinalizer"></a><span class='hs-definition'>addMVarFinalizer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-266"></a><span class='hs-definition'>addMVarFinalizer</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GHC.MVar.addMVarFinalizer</span>
<a name="line-267"></a>
<a name="line-268"></a><a name="mkWeakMVar"></a><span class='hs-comment'>-- | Make a 'Weak' pointer to an 'MVar', using the second argument as</span>
<a name="line-269"></a><span class='hs-comment'>-- a finalizer to run when 'MVar' is garbage-collected</span>
<a name="line-270"></a><span class='hs-comment'>--</span>
<a name="line-271"></a><span class='hs-comment'>-- @since 4.6.0.0</span>
<a name="line-272"></a><span class='hs-definition'>mkWeakMVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Weak</span> <span class='hs-layout'>(</span><span class='hs-conid'>MVar</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-273"></a><span class='hs-definition'>mkWeakMVar</span> <span class='hs-varid'>m</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>MVar</span> <span class='hs-varid'>m</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-274"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>mkWeak</span><span class='hs-cpp'>#</span> <span class='hs-varid'>m</span><span class='hs-cpp'>#</span> <span class='hs-varid'>m</span> <span class='hs-varid'>f</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>w</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-conid'>Weak</span> <span class='hs-varid'>w</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
</pre></body>
</html>
