<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Base.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>
<a name="line-3"></a>NOTA BENE: Do NOT use ($) anywhere in this module! The type of ($) is
<a name="line-4"></a>slightly magical (it can return unlifted types), and it is wired in.
<a name="line-5"></a>But, it is also *defined* in this module, with a non-magical type.
<a name="line-6"></a>GHC gets terribly confused (and *hangs*) if you try to use ($) in this
<a name="line-7"></a>module, because it has different types in different scenarios.
<a name="line-8"></a>
<a name="line-9"></a>This is not a problem in general, because the type ($), being wired in, is not
<a name="line-10"></a>written out to the interface file, so importing files don't get confused.
<a name="line-11"></a>The problem is only if ($) is used here. So don't!
<a name="line-12"></a>
<a name="line-13"></a>---------------------------------------------
<a name="line-14"></a>
<a name="line-15"></a>The overall structure of the GHC Prelude is a bit tricky.
<a name="line-16"></a>
<a name="line-17"></a>  a) We want to avoid "orphan modules", i.e. ones with instance
<a name="line-18"></a>        decls that don't belong either to a tycon or a class
<a name="line-19"></a>        defined in the same module
<a name="line-20"></a>
<a name="line-21"></a>  b) We want to avoid giant modules
<a name="line-22"></a>
<a name="line-23"></a>So the rough structure is as follows, in (linearised) dependency order
<a name="line-24"></a>
<a name="line-25"></a>
<a name="line-26"></a>GHC.Prim        Has no implementation.  It defines built-in things, and
<a name="line-27"></a>                by importing it you bring them into scope.
<a name="line-28"></a>                The source file is GHC.Prim.hi-boot, which is just
<a name="line-29"></a>                copied to make GHC.Prim.hi
<a name="line-30"></a>
<a name="line-31"></a>GHC.Base        Classes: Eq, Ord, Functor, Monad
<a name="line-32"></a>                Types:   list, (), Int, Bool, Ordering, Char, String
<a name="line-33"></a>
<a name="line-34"></a>Data.Tuple      Types: tuples, plus instances for GHC.Base classes
<a name="line-35"></a>
<a name="line-36"></a>GHC.Show        Class: Show, plus instances for GHC.Base/GHC.Tup types
<a name="line-37"></a>
<a name="line-38"></a>GHC.Enum        Class: Enum,  plus instances for GHC.Base/GHC.Tup types
<a name="line-39"></a>
<a name="line-40"></a>Data.Maybe      Type: Maybe, plus instances for GHC.Base classes
<a name="line-41"></a>
<a name="line-42"></a>GHC.List        List functions
<a name="line-43"></a>
<a name="line-44"></a>GHC.Num         Class: Num, plus instances for Int
<a name="line-45"></a>                Type:  Integer, plus instances for all classes so far (Eq, Ord, Num, Show)
<a name="line-46"></a>
<a name="line-47"></a>                Integer is needed here because it is mentioned in the signature
<a name="line-48"></a>                of 'fromInteger' in class Num
<a name="line-49"></a>
<a name="line-50"></a>GHC.Real        Classes: Real, Integral, Fractional, RealFrac
<a name="line-51"></a>                         plus instances for Int, Integer
<a name="line-52"></a>                Types:  Ratio, Rational
<a name="line-53"></a>                        plus instances for classes so far
<a name="line-54"></a>
<a name="line-55"></a>                Rational is needed here because it is mentioned in the signature
<a name="line-56"></a>                of 'toRational' in class Real
<a name="line-57"></a>
<a name="line-58"></a>GHC.ST  The ST monad, instances and a few helper functions
<a name="line-59"></a>
<a name="line-60"></a>Ix              Classes: Ix, plus instances for Int, Bool, Char, Integer, Ordering, tuples
<a name="line-61"></a>
<a name="line-62"></a>GHC.Arr         Types: Array, MutableArray, MutableVar
<a name="line-63"></a>
<a name="line-64"></a>                Arrays are used by a function in GHC.Float
<a name="line-65"></a>
<a name="line-66"></a>GHC.Float       Classes: Floating, RealFloat
<a name="line-67"></a>                Types:   Float, Double, plus instances of all classes so far
<a name="line-68"></a>
<a name="line-69"></a>                This module contains everything to do with floating point.
<a name="line-70"></a>                It is a big module (900 lines)
<a name="line-71"></a>                With a bit of luck, many modules can be compiled without ever reading GHC.Float.hi
<a name="line-72"></a>
<a name="line-73"></a>
<a name="line-74"></a>Other Prelude modules are much easier with fewer complex dependencies.
<a name="line-75"></a>-}</span>
<a name="line-76"></a>
<a name="line-77"></a><span class='hs-comment'>{-# LANGUAGE Unsafe #-}</span>
<a name="line-78"></a><span class='hs-comment'>{-# LANGUAGE CPP
<a name="line-79"></a>           , NoImplicitPrelude
<a name="line-80"></a>           , BangPatterns
<a name="line-81"></a>           , ExplicitForAll
<a name="line-82"></a>           , MagicHash
<a name="line-83"></a>           , UnboxedTuples
<a name="line-84"></a>           , ExistentialQuantification
<a name="line-85"></a>           , RankNTypes
<a name="line-86"></a>           , KindSignatures
<a name="line-87"></a>           , PolyKinds
<a name="line-88"></a>           , DataKinds
<a name="line-89"></a>  #-}</span>
<a name="line-90"></a><span class='hs-comment'>-- -Wno-orphans is needed for things like:</span>
<a name="line-91"></a><span class='hs-comment'>-- Orphan rule: "x# -# x#" ALWAYS forall x# :: Int# -# x# x# = 0</span>
<a name="line-92"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-orphans #-}</span>
<a name="line-93"></a><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<a name="line-94"></a>
<a name="line-95"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-96"></a><span class='hs-comment'>-- |</span>
<a name="line-97"></a><span class='hs-comment'>-- Module      :  GHC.Base</span>
<a name="line-98"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow, 1992-2002</span>
<a name="line-99"></a><span class='hs-comment'>-- License     :  see libraries/base/LICENSE</span>
<a name="line-100"></a><span class='hs-comment'>--</span>
<a name="line-101"></a><span class='hs-comment'>-- Maintainer  :  cvs-ghc@haskell.org</span>
<a name="line-102"></a><span class='hs-comment'>-- Stability   :  internal</span>
<a name="line-103"></a><span class='hs-comment'>-- Portability :  non-portable (GHC extensions)</span>
<a name="line-104"></a><span class='hs-comment'>--</span>
<a name="line-105"></a><span class='hs-comment'>-- Basic data types and classes.</span>
<a name="line-106"></a><span class='hs-comment'>--</span>
<a name="line-107"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-108"></a>
<a name="line-109"></a><span class='hs-cpp'>#include "MachDeps.h"</span>
<a name="line-110"></a>
<a name="line-111"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Base</span>
<a name="line-112"></a>        <span class='hs-layout'>(</span>
<a name="line-113"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Base</span><span class='hs-layout'>,</span>
<a name="line-114"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Classes</span><span class='hs-layout'>,</span>
<a name="line-115"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.CString</span><span class='hs-layout'>,</span>
<a name="line-116"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Magic</span><span class='hs-layout'>,</span>
<a name="line-117"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Types</span><span class='hs-layout'>,</span>
<a name="line-118"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Prim</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Re-export GHC.Prim and [boot] GHC.Err,</span>
<a name="line-119"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Prim.Ext</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- to avoid lots of people having to</span>
<a name="line-120"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Err</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- import it explicitly</span>
<a name="line-121"></a>        <span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Maybe</span>
<a name="line-122"></a>  <span class='hs-layout'>)</span>
<a name="line-123"></a>        <span class='hs-keyword'>where</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types</span>
<a name="line-126"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Classes</span>
<a name="line-127"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.CString</span>
<a name="line-128"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Magic</span>
<a name="line-129"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>
<a name="line-130"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim.Ext</span>
<a name="line-131"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Err</span>
<a name="line-132"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Maybe</span>
<a name="line-133"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUserError</span><span class='hs-layout'>,</span> <span class='hs-varid'>mplusIO</span><span class='hs-layout'>)</span>
<a name="line-134"></a>
<a name="line-135"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tuple</span> <span class='hs-conid'>()</span>              <span class='hs-comment'>-- Note [Depend on GHC.Tuple]</span>
<a name="line-136"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Integer</span> <span class='hs-conid'>()</span>            <span class='hs-comment'>-- Note [Depend on GHC.Integer]</span>
<a name="line-137"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Natural</span> <span class='hs-conid'>()</span>            <span class='hs-comment'>-- Note [Depend on GHC.Natural]</span>
<a name="line-138"></a>
<a name="line-139"></a><span class='hs-comment'>-- for 'class Semigroup'</span>
<a name="line-140"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Real</span> <span class='hs-layout'>(</span><span class='hs-conid'>Integral</span><span class='hs-layout'>)</span>
<a name="line-141"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>Data.Semigroup.Internal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>stimesDefault</span>
<a name="line-142"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesMaybe</span>
<a name="line-143"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesList</span>
<a name="line-144"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>stimesIdempotentMonoid</span>
<a name="line-145"></a>                                              <span class='hs-layout'>)</span>
<a name="line-146"></a>
<a name="line-147"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span>  <span class='hs-varop'>.</span>
<a name="line-148"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span>  <span class='hs-varop'>++</span>
<a name="line-149"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span>  <span class='hs-varop'>&lt;$</span>
<a name="line-150"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>1</span>  <span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&gt;&gt;=</span>
<a name="line-151"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>1</span>  <span class='hs-varop'>=&lt;&lt;</span>
<a name="line-152"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>0</span>  <span class='hs-varop'>$</span><span class='hs-layout'>,</span> <span class='hs-varop'>$!</span>
<a name="line-153"></a>
<a name="line-154"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;*</span><span class='hs-layout'>,</span> <span class='hs-varop'>*&gt;</span><span class='hs-layout'>,</span> <span class='hs-varop'>&lt;**&gt;</span>
<a name="line-155"></a>
<a name="line-156"></a><span class='hs-keyword'>default</span> <span class='hs-conid'>()</span>              <span class='hs-comment'>-- Double isn't available yet</span>
<a name="line-157"></a>
<a name="line-158"></a><span class='hs-comment'>{-
<a name="line-159"></a>Note [Depend on GHC.Integer]
<a name="line-160"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-161"></a>The Integer type is special because TidyPgm uses
<a name="line-162"></a>GHC.Integer.Type.mkInteger to construct Integer literal values
<a name="line-163"></a>Currently it reads the interface file whether or not the current
<a name="line-164"></a>module *has* any Integer literals, so it's important that
<a name="line-165"></a>GHC.Integer.Type (in package integer-gmp or integer-simple) is
<a name="line-166"></a>compiled before any other module.  (There's a hack in GHC to disable
<a name="line-167"></a>this for packages ghc-prim, integer-gmp, integer-simple, which aren't
<a name="line-168"></a>allowed to contain any Integer literals.)
<a name="line-169"></a>
<a name="line-170"></a>Likewise we implicitly need Integer when deriving things like Eq
<a name="line-171"></a>instances.
<a name="line-172"></a>
<a name="line-173"></a>The danger is that if the build system doesn't know about the dependency
<a name="line-174"></a>on Integer, it'll compile some base module before GHC.Integer.Type,
<a name="line-175"></a>resulting in:
<a name="line-176"></a>  Failed to load interface for ‘GHC.Integer.Type’
<a name="line-177"></a>    There are files missing in the ‘integer-gmp’ package,
<a name="line-178"></a>
<a name="line-179"></a>Bottom line: we make GHC.Base depend on GHC.Integer; and everything
<a name="line-180"></a>else either depends on GHC.Base, or does not have NoImplicitPrelude
<a name="line-181"></a>(and hence depends on Prelude).
<a name="line-182"></a>
<a name="line-183"></a>Note [Depend on GHC.Tuple]
<a name="line-184"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-185"></a>Similarly, tuple syntax (or ()) creates an implicit dependency on
<a name="line-186"></a>GHC.Tuple, so we use the same rule as for Integer --- see Note [Depend on
<a name="line-187"></a>GHC.Integer] --- to explain this to the build system.  We make GHC.Base
<a name="line-188"></a>depend on GHC.Tuple, and everything else depends on GHC.Base or Prelude.
<a name="line-189"></a>
<a name="line-190"></a>Note [Depend on GHC.Natural]
<a name="line-191"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-192"></a>Similar to GHC.Integer.
<a name="line-193"></a>-}</span>
<a name="line-194"></a>
<a name="line-195"></a><span class='hs-cpp'>#if 0</span>
<a name="line-196"></a><a name="Bool"></a><span class='hs-comment'>-- for use when compiling GHC.Base itself doesn't work</span>
<a name="line-197"></a><a name="Bool"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>Bool</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>False</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>
<a name="line-198"></a><a name="Ordering"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EQ</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GT</span>
<a name="line-199"></a><a name="Char"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Char</span><span class='hs-cpp'>#</span>
<a name="line-200"></a><a name="String"></a><span class='hs-keyword'>type</span>  <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-201"></a><a name="Int"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-202"></a><a name="()"></a><span class='hs-keyword'>data</span>  <span class='hs-conid'>()</span>  <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>()</span>
<a name="line-203"></a><a name="%5b%5d"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkNil</span>
<a name="line-204"></a>
<a name="line-205"></a><a name="not"></a><span class='hs-definition'>not</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-206"></a><a name="&&"></a><span class='hs-layout'>(</span><span class='hs-varop'>&amp;&amp;</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-207"></a><a name="otherwise"></a><span class='hs-definition'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-208"></a>
<a name="line-209"></a><a name="build"></a><span class='hs-definition'>build</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"urk"</span>
<a name="line-210"></a><a name="foldr"></a><span class='hs-definition'>foldr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>errorWithoutStackTrace</span> <span class='hs-str'>"urk"</span>
<a name="line-211"></a><span class='hs-cpp'>#endif</span>
<a name="line-212"></a>
<a name="line-213"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>6</span> <span class='hs-varop'>&lt;&gt;</span>
<a name="line-214"></a>
<a name="line-215"></a><a name="Semigroup"></a><span class='hs-comment'>-- | The class of semigroups (types with an associative binary operation).</span>
<a name="line-216"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-217"></a><a name="Semigroup"></a><span class='hs-comment'>-- Instances should satisfy the following:</span>
<a name="line-218"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-219"></a><a name="Semigroup"></a><span class='hs-comment'>-- [Associativity] @x '&lt;&gt;' (y '&lt;&gt;' z) = (x '&lt;&gt;' y) '&lt;&gt;' z@</span>
<a name="line-220"></a><a name="Semigroup"></a><span class='hs-comment'>--</span>
<a name="line-221"></a><a name="Semigroup"></a><span class='hs-comment'>-- @since 4.9.0.0</span>
<a name="line-222"></a><a name="Semigroup"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-223"></a>        <span class='hs-comment'>-- | An associative operation.</span>
<a name="line-224"></a>        <span class='hs-comment'>--</span>
<a name="line-225"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]</span>
<a name="line-226"></a>        <span class='hs-comment'>-- [1,2,3,4,5,6]</span>
<a name="line-227"></a>        <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-228"></a>
<a name="line-229"></a>        <span class='hs-comment'>-- | Reduce a non-empty list with '&lt;&gt;'</span>
<a name="line-230"></a>        <span class='hs-comment'>--</span>
<a name="line-231"></a>        <span class='hs-comment'>-- The default definition should be sufficient, but this can be</span>
<a name="line-232"></a>        <span class='hs-comment'>-- overridden for efficiency.</span>
<a name="line-233"></a>        <span class='hs-comment'>--</span>
<a name="line-234"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; import Data.List.NonEmpty</span>
<a name="line-235"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]</span>
<a name="line-236"></a>        <span class='hs-comment'>-- "Hello Haskell!"</span>
<a name="line-237"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-238"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>as</span> <span class='hs-keyword'>where</span>
<a name="line-239"></a>          <span class='hs-varid'>go</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>c</span> <span class='hs-varid'>cs</span>
<a name="line-240"></a>          <span class='hs-varid'>go</span> <span class='hs-varid'>b</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<a name="line-241"></a>
<a name="line-242"></a>        <span class='hs-comment'>-- | Repeat a value @n@ times.</span>
<a name="line-243"></a>        <span class='hs-comment'>--</span>
<a name="line-244"></a>        <span class='hs-comment'>-- Given that this works on a 'Semigroup' it is allowed to fail if</span>
<a name="line-245"></a>        <span class='hs-comment'>-- you request 0 or fewer repetitions, and the default definition</span>
<a name="line-246"></a>        <span class='hs-comment'>-- will do so.</span>
<a name="line-247"></a>        <span class='hs-comment'>--</span>
<a name="line-248"></a>        <span class='hs-comment'>-- By making this a member of the class, idempotent semigroups</span>
<a name="line-249"></a>        <span class='hs-comment'>-- and monoids can upgrade this to execute in \(\mathcal{O}(1)\) by</span>
<a name="line-250"></a>        <span class='hs-comment'>-- picking @stimes = 'Data.Semigroup.stimesIdempotent'@ or @stimes =</span>
<a name="line-251"></a>        <span class='hs-comment'>-- 'stimesIdempotentMonoid'@ respectively.</span>
<a name="line-252"></a>        <span class='hs-comment'>--</span>
<a name="line-253"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; stimes 4 [1]</span>
<a name="line-254"></a>        <span class='hs-comment'>-- [1,1,1,1]</span>
<a name="line-255"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integral</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-256"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesDefault</span>
<a name="line-257"></a>
<a name="line-258"></a>
<a name="line-259"></a><a name="Monoid"></a><span class='hs-comment'>-- | The class of monoids (types with an associative binary operation that</span>
<a name="line-260"></a><a name="Monoid"></a><span class='hs-comment'>-- has an identity).  Instances should satisfy the following:</span>
<a name="line-261"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-262"></a><a name="Monoid"></a><span class='hs-comment'>-- [Right identity] @x '&lt;&gt;' 'mempty' = x@</span>
<a name="line-263"></a><a name="Monoid"></a><span class='hs-comment'>-- [Left identity]  @'mempty' '&lt;&gt;' x = x@</span>
<a name="line-264"></a><a name="Monoid"></a><span class='hs-comment'>-- [Associativity]  @x '&lt;&gt;' (y '&lt;&gt;' z) = (x '&lt;&gt;' y) '&lt;&gt;' z@ ('Semigroup' law)</span>
<a name="line-265"></a><a name="Monoid"></a><span class='hs-comment'>-- [Concatenation]  @'mconcat' = 'foldr' ('&lt;&gt;') 'mempty'@</span>
<a name="line-266"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-267"></a><a name="Monoid"></a><span class='hs-comment'>-- The method names refer to the monoid of lists under concatenation,</span>
<a name="line-268"></a><a name="Monoid"></a><span class='hs-comment'>-- but there are many other instances.</span>
<a name="line-269"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-270"></a><a name="Monoid"></a><span class='hs-comment'>-- Some types can be viewed as a monoid in more than one way,</span>
<a name="line-271"></a><a name="Monoid"></a><span class='hs-comment'>-- e.g. both addition and multiplication on numbers.</span>
<a name="line-272"></a><a name="Monoid"></a><span class='hs-comment'>-- In such cases we often define @newtype@s and make those instances</span>
<a name="line-273"></a><a name="Monoid"></a><span class='hs-comment'>-- of 'Monoid', e.g. 'Data.Semigroup.Sum' and 'Data.Semigroup.Product'.</span>
<a name="line-274"></a><a name="Monoid"></a><span class='hs-comment'>--</span>
<a name="line-275"></a><a name="Monoid"></a><span class='hs-comment'>-- __NOTE__: 'Semigroup' is a superclass of 'Monoid' since /base-4.11.0.0/.</span>
<a name="line-276"></a><a name="Monoid"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-277"></a>        <span class='hs-comment'>-- | Identity of 'mappend'</span>
<a name="line-278"></a>        <span class='hs-comment'>--</span>
<a name="line-279"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; "Hello world" &lt;&gt; mempty</span>
<a name="line-280"></a>        <span class='hs-comment'>-- "Hello world"</span>
<a name="line-281"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span>
<a name="line-282"></a>
<a name="line-283"></a>        <span class='hs-comment'>-- | An associative operation</span>
<a name="line-284"></a>        <span class='hs-comment'>--</span>
<a name="line-285"></a>        <span class='hs-comment'>-- __NOTE__: This method is redundant and has the default</span>
<a name="line-286"></a>        <span class='hs-comment'>-- implementation @'mappend' = ('&lt;&gt;')@ since /base-4.11.0.0/.</span>
<a name="line-287"></a>        <span class='hs-comment'>-- Should it be implemented manually, since 'mappend' is a synonym for</span>
<a name="line-288"></a>        <span class='hs-comment'>-- ('&lt;&gt;'), it is expected that the two functions are defined the same</span>
<a name="line-289"></a>        <span class='hs-comment'>-- way. In a future GHC release 'mappend' will be removed from 'Monoid'.</span>
<a name="line-290"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-291"></a>        <span class='hs-varid'>mappend</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<a name="line-292"></a>        <span class='hs-comment'>{-# INLINE mappend #-}</span>
<a name="line-293"></a>
<a name="line-294"></a>        <span class='hs-comment'>-- | Fold a list using the monoid.</span>
<a name="line-295"></a>        <span class='hs-comment'>--</span>
<a name="line-296"></a>        <span class='hs-comment'>-- For most types, the default definition for 'mconcat' will be</span>
<a name="line-297"></a>        <span class='hs-comment'>-- used, but the function is included in the class definition so</span>
<a name="line-298"></a>        <span class='hs-comment'>-- that an optimized version can be provided for specific types.</span>
<a name="line-299"></a>        <span class='hs-comment'>--</span>
<a name="line-300"></a>        <span class='hs-comment'>-- &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]</span>
<a name="line-301"></a>        <span class='hs-comment'>-- "Hello Haskell!"</span>
<a name="line-302"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-303"></a>        <span class='hs-comment'>{-# INLINE mconcat #-}</span>
<a name="line-304"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mappend</span> <span class='hs-varid'>mempty</span>
<a name="line-305"></a>
<a name="line-306"></a><a name="instance%20Semigroup%20%5ba%5d"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-307"></a><a name="instance%20Semigroup%20%5ba%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-308"></a>        <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-309"></a>        <span class='hs-comment'>{-# INLINE (&lt;&gt;) #-}</span>
<a name="line-310"></a>
<a name="line-311"></a>        <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesList</span>
<a name="line-312"></a>
<a name="line-313"></a><a name="instance%20Monoid%20%5ba%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-314"></a><a name="instance%20Monoid%20%5ba%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>where</span>
<a name="line-315"></a>        <span class='hs-comment'>{-# INLINE mempty #-}</span>
<a name="line-316"></a>        <span class='hs-varid'>mempty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-317"></a>        <span class='hs-comment'>{-# INLINE mconcat #-}</span>
<a name="line-318"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-varid'>xss</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xss</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-319"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-320"></a>
<a name="line-321"></a><span class='hs-comment'>{-
<a name="line-322"></a>Note: [List comprehensions and inlining]
<a name="line-323"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-324"></a>The list monad operations are traditionally described in terms of concatMap:
<a name="line-325"></a>
<a name="line-326"></a>xs &gt;&gt;= f = concatMap f xs
<a name="line-327"></a>
<a name="line-328"></a>Similarly, mconcat for lists is just concat. Here in Base, however, we don't
<a name="line-329"></a>have concatMap, and we'll refrain from adding it here so it won't have to be
<a name="line-330"></a>hidden in imports. Instead, we use GHC's list comprehension desugaring
<a name="line-331"></a>mechanism to define mconcat and the Applicative and Monad instances for lists.
<a name="line-332"></a>We mark them INLINE because the inliner is not generally too keen to inline
<a name="line-333"></a>build forms such as the ones these desugar to without our insistence.  Defining
<a name="line-334"></a>these using list comprehensions instead of foldr has an additional potential
<a name="line-335"></a>benefit, as described in compiler/deSugar/DsListComp.hs: if optimizations
<a name="line-336"></a>needed to make foldr/build forms efficient are turned off, we'll get reasonably
<a name="line-337"></a>efficient translations anyway.
<a name="line-338"></a>-}</span>
<a name="line-339"></a>
<a name="line-340"></a><a name="instance%20Semigroup%20(NonEmpty%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-341"></a><a name="instance%20Semigroup%20(NonEmpty%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-342"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span> <span class='hs-varop'>++</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-343"></a>
<a name="line-344"></a><a name="instance%20Semigroup%20(a%20-%3e%20b)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-345"></a><a name="instance%20Semigroup%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-346"></a>        <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span>
<a name="line-347"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-348"></a>
<a name="line-349"></a><a name="instance%20Monoid%20(a%20-%3e%20b)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-350"></a><a name="instance%20Monoid%20(a%20-%3e%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-351"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-352"></a>
<a name="line-353"></a><a name="instance%20Semigroup%20()"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-354"></a><a name="instance%20Semigroup%20()"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>where</span>
<a name="line-355"></a>        <span class='hs-keyword'>_</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-356"></a>        <span class='hs-varid'>sconcat</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-357"></a>        <span class='hs-varid'>stimes</span>  <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-358"></a>
<a name="line-359"></a><a name="instance%20Monoid%20()"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-360"></a><a name="instance%20Monoid%20()"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>where</span>
<a name="line-361"></a>        <span class='hs-comment'>-- Should it be strict?</span>
<a name="line-362"></a>        <span class='hs-varid'>mempty</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-363"></a>        <span class='hs-varid'>mconcat</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<a name="line-364"></a>
<a name="line-365"></a><a name="instance%20Semigroup%20(a,%20b)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-366"></a><a name="instance%20Semigroup%20(a,%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-367"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>)</span>
<a name="line-368"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-369"></a>
<a name="line-370"></a><a name="instance%20Monoid%20(a,b)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-371"></a><a name="instance%20Monoid%20(a,b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-372"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-373"></a>
<a name="line-374"></a><a name="instance%20Semigroup%20(a,%20b,%20c)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-375"></a><a name="instance%20Semigroup%20(a,%20b,%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-376"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>)</span>
<a name="line-377"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-378"></a>
<a name="line-379"></a><a name="instance%20Monoid%20(a,b,c)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-380"></a><a name="instance%20Monoid%20(a,b,c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-381"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-382"></a>
<a name="line-383"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-384"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-385"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-386"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>d'</span><span class='hs-layout'>)</span>
<a name="line-387"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-388"></a>
<a name="line-389"></a><a name="instance%20Monoid%20(a,b,c,d)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-390"></a><a name="instance%20Monoid%20(a,b,c,d)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-391"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-392"></a>
<a name="line-393"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d,%20e)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-394"></a><a name="instance%20Semigroup%20(a,%20b,%20c,%20d,%20e)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-395"></a>         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-396"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d'</span><span class='hs-layout'>,</span><span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>c'</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>d'</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-397"></a>        <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-398"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-varid'>stimes</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-399"></a>
<a name="line-400"></a><a name="instance%20Monoid%20(a,b,c,d,e)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-401"></a><a name="instance%20Monoid%20(a,b,c,d,e)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>d</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<a name="line-402"></a>                <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>c</span><span class='hs-layout'>,</span><span class='hs-varid'>d</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-403"></a>        <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>)</span>
<a name="line-404"></a>
<a name="line-405"></a>
<a name="line-406"></a><a name="instance%20Semigroup%20Ordering"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-407"></a><a name="instance%20Semigroup%20Ordering"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyword'>where</span>
<a name="line-408"></a>    <span class='hs-conid'>LT</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-409"></a>    <span class='hs-conid'>EQ</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span>
<a name="line-410"></a>    <span class='hs-conid'>GT</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-411"></a>
<a name="line-412"></a>    <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesIdempotentMonoid</span>
<a name="line-413"></a>
<a name="line-414"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-comment'>-- lexicographical ordering</span>
<a name="line-415"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-416"></a><a name="instance%20Monoid%20Ordering"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-conid'>Ordering</span> <span class='hs-keyword'>where</span>
<a name="line-417"></a>    <span class='hs-varid'>mempty</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-418"></a>
<a name="line-419"></a><a name="instance%20Semigroup%20(Maybe%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-420"></a><a name="instance%20Semigroup%20(Maybe%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-421"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<a name="line-422"></a>    <span class='hs-varid'>a</span>       <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-423"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>a</span>  <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-424"></a>
<a name="line-425"></a>    <span class='hs-varid'>stimes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stimesMaybe</span>
<a name="line-426"></a>
<a name="line-427"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- | Lift a semigroup into 'Maybe' forming a 'Monoid' according to</span>
<a name="line-428"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- &lt;<a href="http://en.wikipedia.org/wiki/Monoid">http://en.wikipedia.org/wiki/Monoid</a>&gt;: \"Any semigroup @S@ may be</span>
<a name="line-429"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- turned into a monoid simply by adjoining an element @e@ not in @S@</span>
<a name="line-430"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- and defining @e*e = e@ and @e*s = s = s*e@ for all @s ∈ S@.\"</span>
<a name="line-431"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>--</span>
<a name="line-432"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- /Since 4.11.0/: constraint on inner @a@ value generalised from</span>
<a name="line-433"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- 'Monoid' to 'Semigroup'.</span>
<a name="line-434"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>--</span>
<a name="line-435"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-comment'>-- @since 2.01</span>
<a name="line-436"></a><a name="instance%20Monoid%20(Maybe%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-437"></a>    <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-438"></a>
<a name="line-439"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- | For tuples, the 'Monoid' constraint on @a@ determines</span>
<a name="line-440"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- how the first values merge.</span>
<a name="line-441"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- For example, 'String's concatenate:</span>
<a name="line-442"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>--</span>
<a name="line-443"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- &gt; ("hello ", (+15)) &lt;*&gt; ("world!", 2002)</span>
<a name="line-444"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- &gt; ("hello world!",2017)</span>
<a name="line-445"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>--</span>
<a name="line-446"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-comment'>-- @since 2.01</span>
<a name="line-447"></a><a name="instance%20Applicative%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-448"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-449"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-450"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-451"></a>
<a name="line-452"></a><a name="instance%20Monad%20((,)%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-453"></a><a name="instance%20Monad%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-454"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-455"></a>
<a name="line-456"></a><a name="instance%20Functor%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-457"></a><a name="instance%20Functor%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-458"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-459"></a>
<a name="line-460"></a><a name="instance%20Applicative%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-461"></a><a name="instance%20Applicative%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-462"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-463"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-464"></a>
<a name="line-465"></a><a name="instance%20Monad%20((,,)%20a%20b)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-466"></a><a name="instance%20Monad%20((,,)%20a%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-467"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-468"></a>
<a name="line-469"></a><a name="instance%20Functor%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-470"></a><a name="instance%20Functor%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-471"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-472"></a>
<a name="line-473"></a><a name="instance%20Applicative%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-474"></a><a name="instance%20Applicative%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-475"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mempty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-476"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>c'</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>a'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>c</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>c'</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-477"></a>
<a name="line-478"></a><a name="instance%20Monad%20((,,,)%20a%20b%20c)"></a><span class='hs-comment'>-- | @since 4.14.0.0</span>
<a name="line-479"></a><a name="instance%20Monad%20((,,,)%20a%20b%20c)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,,,)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-480"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>u</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>w'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>u</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>u'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>v'</span><span class='hs-layout'>,</span> <span class='hs-varid'>w</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>w'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-481"></a>
<a name="line-482"></a><a name="instance%20Semigroup%20(IO%20a)"></a><span class='hs-comment'>-- | @since 4.10.0.0</span>
<a name="line-483"></a><a name="instance%20Semigroup%20(IO%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Semigroup</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Semigroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-484"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>
<a name="line-485"></a>
<a name="line-486"></a><a name="instance%20Monoid%20(IO%20a)"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-487"></a><a name="instance%20Monoid%20(IO%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monoid</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-488"></a>    <span class='hs-varid'>mempty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>mempty</span>
<a name="line-489"></a>
<a name="line-490"></a><span class='hs-comment'>{- | A type @f@ is a Functor if it provides a function @fmap@ which, given any types @a@ and @b@
<a name="line-491"></a>lets you apply any function from @(a -&gt; b)@ to turn an @f a@ into an @f b@, preserving the
<a name="line-492"></a>structure of @f@. Furthermore @f@ needs to adhere to the following:
<a name="line-493"></a>
<a name="line-494"></a>[Identity]    @'fmap' 'id' == 'id'@
<a name="line-495"></a>[Composition] @'fmap' (f . g) == 'fmap' f . 'fmap' g@
<a name="line-496"></a>
<a name="line-497"></a>Note, that the second law follows from the free theorem of the type 'fmap' and
<a name="line-498"></a>the first law, so you need only check that the former condition holds.
<a name="line-499"></a>-}</span>
<a name="line-500"></a>
<a name="line-501"></a><a name="Functor"></a><span class='hs-keyword'>class</span>  <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span>  <span class='hs-keyword'>where</span>
<a name="line-502"></a>    <span class='hs-comment'>-- | Using @ApplicativeDo@: \'@'fmap' f as@\' can be understood as</span>
<a name="line-503"></a>    <span class='hs-comment'>-- the @do@ expression</span>
<a name="line-504"></a>    <span class='hs-comment'>--</span>
<a name="line-505"></a>    <span class='hs-comment'>-- @</span>
<a name="line-506"></a>    <span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-507"></a>    <span class='hs-comment'>--    pure (f a)</span>
<a name="line-508"></a>    <span class='hs-comment'>-- @</span>
<a name="line-509"></a>    <span class='hs-comment'>--</span>
<a name="line-510"></a>    <span class='hs-comment'>-- with an inferred @Functor@ constraint.</span>
<a name="line-511"></a>    <span class='hs-varid'>fmap</span>        <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-512"></a>
<a name="line-513"></a>    <span class='hs-comment'>-- | Replace all locations in the input with the same value.</span>
<a name="line-514"></a>    <span class='hs-comment'>-- The default definition is @'fmap' . 'const'@, but this may be</span>
<a name="line-515"></a>    <span class='hs-comment'>-- overridden with a more efficient version.</span>
<a name="line-516"></a>    <span class='hs-comment'>--</span>
<a name="line-517"></a>    <span class='hs-comment'>-- Using @ApplicativeDo@: \'@a '&lt;$' bs@\' can be understood as the</span>
<a name="line-518"></a>    <span class='hs-comment'>-- @do@ expression</span>
<a name="line-519"></a>    <span class='hs-comment'>--</span>
<a name="line-520"></a>    <span class='hs-comment'>-- @</span>
<a name="line-521"></a>    <span class='hs-comment'>-- do bs</span>
<a name="line-522"></a>    <span class='hs-comment'>--    pure a</span>
<a name="line-523"></a>    <span class='hs-comment'>-- @</span>
<a name="line-524"></a>    <span class='hs-comment'>--</span>
<a name="line-525"></a>    <span class='hs-comment'>-- with an inferred @Functor@ constraint.</span>
<a name="line-526"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-527"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;$</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>fmap</span> <span class='hs-varop'>.</span> <span class='hs-varid'>const</span>
<a name="line-528"></a>
<a name="line-529"></a><span class='hs-comment'>-- | A functor with application, providing operations to</span>
<a name="line-530"></a><span class='hs-comment'>--</span>
<a name="line-531"></a><span class='hs-comment'>-- * embed pure expressions ('pure'), and</span>
<a name="line-532"></a><span class='hs-comment'>--</span>
<a name="line-533"></a><span class='hs-comment'>-- * sequence computations and combine their results ('&lt;*&gt;' and 'liftA2').</span>
<a name="line-534"></a><span class='hs-comment'>--</span>
<a name="line-535"></a><span class='hs-comment'>-- A minimal complete definition must include implementations of 'pure'</span>
<a name="line-536"></a><span class='hs-comment'>-- and of either '&lt;*&gt;' or 'liftA2'. If it defines both, then they must behave</span>
<a name="line-537"></a><span class='hs-comment'>-- the same as their default definitions:</span>
<a name="line-538"></a><span class='hs-comment'>--</span>
<a name="line-539"></a><span class='hs-comment'>--      @('&lt;*&gt;') = 'liftA2' 'id'@</span>
<a name="line-540"></a><span class='hs-comment'>--</span>
<a name="line-541"></a><span class='hs-comment'>--      @'liftA2' f x y = f 'Prelude.&lt;$&gt;' x '&lt;*&gt;' y@</span>
<a name="line-542"></a><span class='hs-comment'>--</span>
<a name="line-543"></a><span class='hs-comment'>-- Further, any definition must satisfy the following:</span>
<a name="line-544"></a><span class='hs-comment'>--</span>
<a name="line-545"></a><span class='hs-comment'>-- [Identity]</span>
<a name="line-546"></a><span class='hs-comment'>--</span>
<a name="line-547"></a><span class='hs-comment'>--      @'pure' 'id' '&lt;*&gt;' v = v@</span>
<a name="line-548"></a><span class='hs-comment'>--</span>
<a name="line-549"></a><span class='hs-comment'>-- [Composition]</span>
<a name="line-550"></a><span class='hs-comment'>--</span>
<a name="line-551"></a><span class='hs-comment'>--      @'pure' (.) '&lt;*&gt;' u '&lt;*&gt;' v '&lt;*&gt;' w = u '&lt;*&gt;' (v '&lt;*&gt;' w)@</span>
<a name="line-552"></a><span class='hs-comment'>--</span>
<a name="line-553"></a><span class='hs-comment'>-- [Homomorphism]</span>
<a name="line-554"></a><span class='hs-comment'>--</span>
<a name="line-555"></a><span class='hs-comment'>--      @'pure' f '&lt;*&gt;' 'pure' x = 'pure' (f x)@</span>
<a name="line-556"></a><span class='hs-comment'>--</span>
<a name="line-557"></a><span class='hs-comment'>-- [Interchange]</span>
<a name="line-558"></a><span class='hs-comment'>--</span>
<a name="line-559"></a><span class='hs-comment'>--      @u '&lt;*&gt;' 'pure' y = 'pure' ('$' y) '&lt;*&gt;' u@</span>
<a name="line-560"></a><span class='hs-comment'>--</span>
<a name="line-561"></a><span class='hs-comment'>--</span>
<a name="line-562"></a><span class='hs-comment'>-- The other methods have the following default definitions, which may</span>
<a name="line-563"></a><span class='hs-comment'>-- be overridden with equivalent specialized implementations:</span>
<a name="line-564"></a><span class='hs-comment'>--</span>
<a name="line-565"></a><span class='hs-comment'>--   * @u '*&gt;' v = ('id' '&lt;$' u) '&lt;*&gt;' v@</span>
<a name="line-566"></a><span class='hs-comment'>--</span>
<a name="line-567"></a><span class='hs-comment'>--   * @u '&lt;*' v = 'liftA2' 'const' u v@</span>
<a name="line-568"></a><span class='hs-comment'>--</span>
<a name="line-569"></a><span class='hs-comment'>-- As a consequence of these laws, the 'Functor' instance for @f@ will satisfy</span>
<a name="line-570"></a><span class='hs-comment'>--</span>
<a name="line-571"></a><span class='hs-comment'>--   * @'fmap' f x = 'pure' f '&lt;*&gt;' x@</span>
<a name="line-572"></a><span class='hs-comment'>--</span>
<a name="line-573"></a><span class='hs-comment'>--</span>
<a name="line-574"></a><span class='hs-comment'>-- It may be useful to note that supposing</span>
<a name="line-575"></a><span class='hs-comment'>--</span>
<a name="line-576"></a><span class='hs-comment'>--      @forall x y. p (q x y) = f x . g y@</span>
<a name="line-577"></a><span class='hs-comment'>--</span>
<a name="line-578"></a><span class='hs-comment'>-- it follows from the above that</span>
<a name="line-579"></a><span class='hs-comment'>--</span>
<a name="line-580"></a><span class='hs-comment'>--      @'liftA2' p ('liftA2' q u v) = 'liftA2' f u . 'liftA2' g v@</span>
<a name="line-581"></a><span class='hs-comment'>--</span>
<a name="line-582"></a><span class='hs-comment'>--</span>
<a name="line-583"></a><span class='hs-comment'>-- If @f@ is also a 'Monad', it should satisfy</span>
<a name="line-584"></a><span class='hs-comment'>--</span>
<a name="line-585"></a><span class='hs-comment'>--   * @'pure' = 'return'@</span>
<a name="line-586"></a><span class='hs-comment'>--</span>
<a name="line-587"></a><span class='hs-comment'>--   * @m1 '&lt;*&gt;' m2 = m1 '&gt;&gt;=' (\x1 -&gt; m2 '&gt;&gt;=' (\x2 -&gt; 'return' (x1 x2)))@</span>
<a name="line-588"></a><span class='hs-comment'>--</span>
<a name="line-589"></a><span class='hs-comment'>--   * @('*&gt;') = ('&gt;&gt;')@</span>
<a name="line-590"></a><span class='hs-comment'>--</span>
<a name="line-591"></a><span class='hs-comment'>-- (which implies that 'pure' and '&lt;*&gt;' satisfy the applicative functor laws).</span>
<a name="line-592"></a>
<a name="line-593"></a><a name="Applicative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Functor</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-594"></a>    <span class='hs-comment'>{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>
<a name="line-595"></a>    <span class='hs-comment'>-- | Lift a value.</span>
<a name="line-596"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-597"></a>
<a name="line-598"></a>    <span class='hs-comment'>-- | Sequential application.</span>
<a name="line-599"></a>    <span class='hs-comment'>--</span>
<a name="line-600"></a>    <span class='hs-comment'>-- A few functors support an implementation of '&lt;*&gt;' that is more</span>
<a name="line-601"></a>    <span class='hs-comment'>-- efficient than the default one.</span>
<a name="line-602"></a>    <span class='hs-comment'>--</span>
<a name="line-603"></a>    <span class='hs-comment'>-- Using @ApplicativeDo@: \'@fs '&lt;*&gt;' as@\' can be understood as</span>
<a name="line-604"></a>    <span class='hs-comment'>-- the @do@ expression</span>
<a name="line-605"></a>    <span class='hs-comment'>--</span>
<a name="line-606"></a>    <span class='hs-comment'>-- @</span>
<a name="line-607"></a>    <span class='hs-comment'>-- do f &lt;- fs</span>
<a name="line-608"></a>    <span class='hs-comment'>--    a &lt;- as</span>
<a name="line-609"></a>    <span class='hs-comment'>--    pure (f a)</span>
<a name="line-610"></a>    <span class='hs-comment'>-- @</span>
<a name="line-611"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-612"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>id</span>
<a name="line-613"></a>
<a name="line-614"></a>    <span class='hs-comment'>-- | Lift a binary function to actions.</span>
<a name="line-615"></a>    <span class='hs-comment'>--</span>
<a name="line-616"></a>    <span class='hs-comment'>-- Some functors support an implementation of 'liftA2' that is more</span>
<a name="line-617"></a>    <span class='hs-comment'>-- efficient than the default one. In particular, if 'fmap' is an</span>
<a name="line-618"></a>    <span class='hs-comment'>-- expensive operation, it is likely better to use 'liftA2' than to</span>
<a name="line-619"></a>    <span class='hs-comment'>-- 'fmap' over the structure and then use '&lt;*&gt;'.</span>
<a name="line-620"></a>    <span class='hs-comment'>--</span>
<a name="line-621"></a>    <span class='hs-comment'>-- This became a typeclass method in 4.10.0.0. Prior to that, it was</span>
<a name="line-622"></a>    <span class='hs-comment'>-- a function defined in terms of '&lt;*&gt;' and 'fmap'.</span>
<a name="line-623"></a>    <span class='hs-comment'>--</span>
<a name="line-624"></a>    <span class='hs-comment'>-- Using @ApplicativeDo@: \'@'liftA2' f as bs@\' can be understood</span>
<a name="line-625"></a>    <span class='hs-comment'>-- as the @do@ expression</span>
<a name="line-626"></a>    <span class='hs-comment'>--</span>
<a name="line-627"></a>    <span class='hs-comment'>-- @</span>
<a name="line-628"></a>    <span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-629"></a>    <span class='hs-comment'>--    b &lt;- bs</span>
<a name="line-630"></a>    <span class='hs-comment'>--    pure (f a b)</span>
<a name="line-631"></a>    <span class='hs-comment'>-- @</span>
<a name="line-632"></a>
<a name="line-633"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span>
<a name="line-634"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-635"></a>
<a name="line-636"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the first argument.</span>
<a name="line-637"></a>    <span class='hs-comment'>--</span>
<a name="line-638"></a>    <span class='hs-comment'>-- \'@as '*&gt;' bs@\' can be understood as the @do@ expression</span>
<a name="line-639"></a>    <span class='hs-comment'>--</span>
<a name="line-640"></a>    <span class='hs-comment'>-- @</span>
<a name="line-641"></a>    <span class='hs-comment'>-- do as</span>
<a name="line-642"></a>    <span class='hs-comment'>--    bs</span>
<a name="line-643"></a>    <span class='hs-comment'>-- @</span>
<a name="line-644"></a>    <span class='hs-comment'>--</span>
<a name="line-645"></a>    <span class='hs-comment'>-- This is a tad complicated for our @ApplicativeDo@ extension</span>
<a name="line-646"></a>    <span class='hs-comment'>-- which will give it a @Monad@ constraint. For an @Applicative@</span>
<a name="line-647"></a>    <span class='hs-comment'>-- constraint we write it of the form</span>
<a name="line-648"></a>    <span class='hs-comment'>--</span>
<a name="line-649"></a>    <span class='hs-comment'>-- @</span>
<a name="line-650"></a>    <span class='hs-comment'>-- do _ &lt;- as</span>
<a name="line-651"></a>    <span class='hs-comment'>--    b &lt;- bs</span>
<a name="line-652"></a>    <span class='hs-comment'>--    pure b</span>
<a name="line-653"></a>    <span class='hs-comment'>-- @</span>
<a name="line-654"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-655"></a>    <span class='hs-varid'>a1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span> <span class='hs-varop'>&lt;$</span> <span class='hs-varid'>a1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a2</span>
<a name="line-656"></a>    <span class='hs-comment'>-- This is essentially the same as liftA2 (flip const), but if the</span>
<a name="line-657"></a>    <span class='hs-comment'>-- Functor instance has an optimized (&lt;$), it may be better to use</span>
<a name="line-658"></a>    <span class='hs-comment'>-- that instead. Before liftA2 became a method, this definition</span>
<a name="line-659"></a>    <span class='hs-comment'>-- was strictly better, but now it depends on the functor. For a</span>
<a name="line-660"></a>    <span class='hs-comment'>-- functor supporting a sharing-enhancing (&lt;$), this definition</span>
<a name="line-661"></a>    <span class='hs-comment'>-- may reduce allocation by preventing a1 from ever being fully</span>
<a name="line-662"></a>    <span class='hs-comment'>-- realized. In an implementation with a boring (&lt;$) but an optimizing</span>
<a name="line-663"></a>    <span class='hs-comment'>-- liftA2, it would likely be better to define (*&gt;) using liftA2.</span>
<a name="line-664"></a>
<a name="line-665"></a>    <span class='hs-comment'>-- | Sequence actions, discarding the value of the second argument.</span>
<a name="line-666"></a>    <span class='hs-comment'>--</span>
<a name="line-667"></a>    <span class='hs-comment'>-- Using @ApplicativeDo@: \'@as '&lt;*' bs@\' can be understood as</span>
<a name="line-668"></a>    <span class='hs-comment'>-- the @do@ expression</span>
<a name="line-669"></a>    <span class='hs-comment'>--</span>
<a name="line-670"></a>    <span class='hs-comment'>-- @</span>
<a name="line-671"></a>    <span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-672"></a>    <span class='hs-comment'>--    bs</span>
<a name="line-673"></a>    <span class='hs-comment'>--    pure a</span>
<a name="line-674"></a>    <span class='hs-comment'>-- @</span>
<a name="line-675"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-676"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>const</span>
<a name="line-677"></a>
<a name="line-678"></a><a name="%3c**%3e"></a><span class='hs-comment'>-- | A variant of '&lt;*&gt;' with the arguments reversed.</span>
<a name="line-679"></a><span class='hs-comment'>--</span>
<a name="line-680"></a><span class='hs-comment'>-- Using @ApplicativeDo@: \'@as '&lt;**&gt;' fs@\' can be understood as the</span>
<a name="line-681"></a><span class='hs-comment'>-- @do@ expression</span>
<a name="line-682"></a><span class='hs-comment'>--</span>
<a name="line-683"></a><span class='hs-comment'>-- @</span>
<a name="line-684"></a><span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-685"></a><span class='hs-comment'>--    f &lt;- fs</span>
<a name="line-686"></a><span class='hs-comment'>--    pure (f a)</span>
<a name="line-687"></a><span class='hs-comment'>-- @</span>
<a name="line-688"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-689"></a><span class='hs-layout'>(</span><span class='hs-varop'>&lt;**&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-690"></a><span class='hs-comment'>-- Don't use $ here, see the note at the top of the page</span>
<a name="line-691"></a>
<a name="line-692"></a><a name="liftA"></a><span class='hs-comment'>-- | Lift a function to actions.</span>
<a name="line-693"></a><span class='hs-comment'>-- This function may be used as a value for `fmap` in a `Functor` instance.</span>
<a name="line-694"></a><span class='hs-comment'>--</span>
<a name="line-695"></a><span class='hs-comment'>-- | Using @ApplicativeDo@: \'@'liftA' f as@\' can be understood as the</span>
<a name="line-696"></a><span class='hs-comment'>-- @do@ expression</span>
<a name="line-697"></a><span class='hs-comment'>--</span>
<a name="line-698"></a><span class='hs-comment'>--</span>
<a name="line-699"></a><span class='hs-comment'>-- @</span>
<a name="line-700"></a><span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-701"></a><span class='hs-comment'>--    pure (f a)</span>
<a name="line-702"></a><span class='hs-comment'>-- @</span>
<a name="line-703"></a><span class='hs-comment'>--</span>
<a name="line-704"></a><span class='hs-comment'>-- with an inferred @Functor@ constraint, weaker than @Applicative@.</span>
<a name="line-705"></a><span class='hs-definition'>liftA</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span>
<a name="line-706"></a><span class='hs-definition'>liftA</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>a</span>
<a name="line-707"></a><span class='hs-comment'>-- Caution: since this may be used for `fmap`, we can't use the obvious</span>
<a name="line-708"></a><span class='hs-comment'>-- definition of liftA = fmap.</span>
<a name="line-709"></a>
<a name="line-710"></a><a name="liftA3"></a><span class='hs-comment'>-- | Lift a ternary function to actions.</span>
<a name="line-711"></a><span class='hs-comment'>--</span>
<a name="line-712"></a><span class='hs-comment'>-- Using @ApplicativeDo@: \'@'liftA3' f as bs cs@\' can be understood</span>
<a name="line-713"></a><span class='hs-comment'>-- as the @do@ expression</span>
<a name="line-714"></a><span class='hs-comment'>--</span>
<a name="line-715"></a><span class='hs-comment'>-- @</span>
<a name="line-716"></a><span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-717"></a><span class='hs-comment'>--    b &lt;- bs</span>
<a name="line-718"></a><span class='hs-comment'>--    c &lt;- cs</span>
<a name="line-719"></a><span class='hs-comment'>--    pure (f a b c)</span>
<a name="line-720"></a><span class='hs-comment'>-- @</span>
<a name="line-721"></a><span class='hs-definition'>liftA3</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>d</span>
<a name="line-722"></a><span class='hs-definition'>liftA3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>c</span>
<a name="line-723"></a>
<a name="line-724"></a>
<a name="line-725"></a><span class='hs-comment'>{-# INLINABLE liftA #-}</span>
<a name="line-726"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-727"></a><span class='hs-comment'>{-# SPECIALISE liftA :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-728"></a><span class='hs-comment'>{-# INLINABLE liftA3 #-}</span>
<a name="line-729"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-730"></a><span class='hs-comment'>{-# SPECIALISE liftA3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt;
<a name="line-731"></a>                                Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-732"></a>
<a name="line-733"></a><a name="join"></a><span class='hs-comment'>-- | The 'join' function is the conventional monad join operator. It</span>
<a name="line-734"></a><span class='hs-comment'>-- is used to remove one level of monadic structure, projecting its</span>
<a name="line-735"></a><span class='hs-comment'>-- bound argument into the outer level.</span>
<a name="line-736"></a><span class='hs-comment'>--</span>
<a name="line-737"></a><span class='hs-comment'>--</span>
<a name="line-738"></a><span class='hs-comment'>-- \'@'join' bss@\' can be understood as the @do@ expression</span>
<a name="line-739"></a><span class='hs-comment'>--</span>
<a name="line-740"></a><span class='hs-comment'>-- @</span>
<a name="line-741"></a><span class='hs-comment'>-- do bs &lt;- bss</span>
<a name="line-742"></a><span class='hs-comment'>--    bs</span>
<a name="line-743"></a><span class='hs-comment'>-- @</span>
<a name="line-744"></a><span class='hs-comment'>--</span>
<a name="line-745"></a><span class='hs-comment'>-- ==== __Examples__</span>
<a name="line-746"></a><span class='hs-comment'>--</span>
<a name="line-747"></a><span class='hs-comment'>-- A common use of 'join' is to run an 'IO' computation returned from</span>
<a name="line-748"></a><span class='hs-comment'>-- an 'GHC.Conc.STM' transaction, since 'GHC.Conc.STM' transactions</span>
<a name="line-749"></a><span class='hs-comment'>-- can't perform 'IO' directly. Recall that</span>
<a name="line-750"></a><span class='hs-comment'>--</span>
<a name="line-751"></a><span class='hs-comment'>-- @</span>
<a name="line-752"></a><span class='hs-comment'>-- 'GHC.Conc.atomically' :: STM a -&gt; IO a</span>
<a name="line-753"></a><span class='hs-comment'>-- @</span>
<a name="line-754"></a><span class='hs-comment'>--</span>
<a name="line-755"></a><span class='hs-comment'>-- is used to run 'GHC.Conc.STM' transactions atomically. So, by</span>
<a name="line-756"></a><span class='hs-comment'>-- specializing the types of 'GHC.Conc.atomically' and 'join' to</span>
<a name="line-757"></a><span class='hs-comment'>--</span>
<a name="line-758"></a><span class='hs-comment'>-- @</span>
<a name="line-759"></a><span class='hs-comment'>-- 'GHC.Conc.atomically' :: STM (IO b) -&gt; IO (IO b)</span>
<a name="line-760"></a><span class='hs-comment'>-- 'join'       :: IO (IO b)  -&gt; IO b</span>
<a name="line-761"></a><span class='hs-comment'>-- @</span>
<a name="line-762"></a><span class='hs-comment'>--</span>
<a name="line-763"></a><span class='hs-comment'>-- we can compose them as</span>
<a name="line-764"></a><span class='hs-comment'>--</span>
<a name="line-765"></a><span class='hs-comment'>-- @</span>
<a name="line-766"></a><span class='hs-comment'>-- 'join' . 'GHC.Conc.atomically' :: STM (IO b) -&gt; IO b</span>
<a name="line-767"></a><span class='hs-comment'>-- @</span>
<a name="line-768"></a><span class='hs-comment'>--</span>
<a name="line-769"></a><span class='hs-comment'>-- to run an 'GHC.Conc.STM' transaction and the 'IO' action it</span>
<a name="line-770"></a><span class='hs-comment'>-- returns.</span>
<a name="line-771"></a><span class='hs-definition'>join</span>              <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-772"></a><span class='hs-definition'>join</span> <span class='hs-varid'>x</span>            <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>id</span>
<a name="line-773"></a>
<a name="line-774"></a><a name="Monad"></a><span class='hs-comment'>{- | The 'Monad' class defines the basic operations over a /monad/,
<a name="line-775"></a>a concept from a branch of mathematics known as /category theory/.
<a name="line-776"></a>From the perspective of a Haskell programmer, however, it is best to
<a name="line-777"></a>think of a monad as an /abstract datatype/ of actions.
<a name="line-778"></a>Haskell's @do@ expressions provide a convenient syntax for writing
<a name="line-779"></a>monadic expressions.
<a name="line-780"></a>
<a name="line-781"></a>Instances of 'Monad' should satisfy the following:
<a name="line-782"></a>
<a name="line-783"></a>[Left identity]  @'return' a '&gt;&gt;=' k  =  k a@
<a name="line-784"></a>[Right identity] @m '&gt;&gt;=' 'return'  =  m@
<a name="line-785"></a>[Associativity]  @m '&gt;&gt;=' (\\x -&gt; k x '&gt;&gt;=' h)  =  (m '&gt;&gt;=' k) '&gt;&gt;=' h@
<a name="line-786"></a>
<a name="line-787"></a>Furthermore, the 'Monad' and 'Applicative' operations should relate as follows:
<a name="line-788"></a>
<a name="line-789"></a>* @'pure' = 'return'@
<a name="line-790"></a>* @m1 '&lt;*&gt;' m2 = m1 '&gt;&gt;=' (\x1 -&gt; m2 '&gt;&gt;=' (\x2 -&gt; 'return' (x1 x2)))@
<a name="line-791"></a>
<a name="line-792"></a>The above laws imply:
<a name="line-793"></a>
<a name="line-794"></a>* @'fmap' f xs  =  xs '&gt;&gt;=' 'return' . f@
<a name="line-795"></a>* @('&gt;&gt;') = ('*&gt;')@
<a name="line-796"></a>
<a name="line-797"></a>and that 'pure' and ('&lt;*&gt;') satisfy the applicative functor laws.
<a name="line-798"></a>
<a name="line-799"></a>The instances of 'Monad' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
<a name="line-800"></a>defined in the "Prelude" satisfy these laws.
<a name="line-801"></a>-}</span>
<a name="line-802"></a><a name="Monad"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-803"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, passing any value produced</span>
<a name="line-804"></a>    <span class='hs-comment'>-- by the first as an argument to the second.</span>
<a name="line-805"></a>    <span class='hs-comment'>--</span>
<a name="line-806"></a>    <span class='hs-comment'>-- \'@as '&gt;&gt;=' bs@\' can be understood as the @do@ expression</span>
<a name="line-807"></a>    <span class='hs-comment'>--</span>
<a name="line-808"></a>    <span class='hs-comment'>-- @</span>
<a name="line-809"></a>    <span class='hs-comment'>-- do a &lt;- as</span>
<a name="line-810"></a>    <span class='hs-comment'>--    bs a</span>
<a name="line-811"></a>    <span class='hs-comment'>-- @</span>
<a name="line-812"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-813"></a>
<a name="line-814"></a>    <span class='hs-comment'>-- | Sequentially compose two actions, discarding any value produced</span>
<a name="line-815"></a>    <span class='hs-comment'>-- by the first, like sequencing operators (such as the semicolon)</span>
<a name="line-816"></a>    <span class='hs-comment'>-- in imperative languages.</span>
<a name="line-817"></a>    <span class='hs-comment'>--</span>
<a name="line-818"></a>    <span class='hs-comment'>-- \'@as '&gt;&gt;' bs@\' can be understood as the @do@ expression</span>
<a name="line-819"></a>    <span class='hs-comment'>--</span>
<a name="line-820"></a>    <span class='hs-comment'>-- @</span>
<a name="line-821"></a>    <span class='hs-comment'>-- do as</span>
<a name="line-822"></a>    <span class='hs-comment'>--    bs</span>
<a name="line-823"></a>    <span class='hs-comment'>-- @</span>
<a name="line-824"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-825"></a>    <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-comment'>-- See Note [Recursive bindings for Applicative/Monad]</span>
<a name="line-826"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-827"></a>
<a name="line-828"></a>    <span class='hs-comment'>-- | Inject a value into the monadic type.</span>
<a name="line-829"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-830"></a>    <span class='hs-varid'>return</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span>
<a name="line-831"></a>
<a name="line-832"></a><span class='hs-comment'>{- Note [Recursive bindings for Applicative/Monad]
<a name="line-833"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-834"></a>
<a name="line-835"></a>The original Applicative/Monad proposal stated that after
<a name="line-836"></a>implementation, the designated implementation of (&gt;&gt;) would become
<a name="line-837"></a>
<a name="line-838"></a>  (&gt;&gt;) :: forall a b. m a -&gt; m b -&gt; m b
<a name="line-839"></a>  (&gt;&gt;) = (*&gt;)
<a name="line-840"></a>
<a name="line-841"></a>by default. You might be inclined to change this to reflect the stated
<a name="line-842"></a>proposal, but you really shouldn't! Why? Because people tend to define
<a name="line-843"></a>such instances the /other/ way around: in particular, it is perfectly
<a name="line-844"></a>legitimate to define an instance of Applicative (*&gt;) in terms of (&gt;&gt;),
<a name="line-845"></a>which would lead to an infinite loop for the default implementation of
<a name="line-846"></a>Monad! And people do this in the wild.
<a name="line-847"></a>
<a name="line-848"></a>This turned into a nasty bug that was tricky to track down, and rather
<a name="line-849"></a>than eliminate it everywhere upstream, it's easier to just retain the
<a name="line-850"></a>original default.
<a name="line-851"></a>
<a name="line-852"></a>-}</span>
<a name="line-853"></a>
<a name="line-854"></a><a name="=%3c%3c"></a><span class='hs-comment'>-- | Same as '&gt;&gt;=', but with the arguments interchanged.</span>
<a name="line-855"></a><span class='hs-comment'>{-# SPECIALISE (=&lt;&lt;) :: (a -&gt; [b]) -&gt; [a] -&gt; [b] #-}</span>
<a name="line-856"></a><span class='hs-layout'>(</span><span class='hs-varop'>=&lt;&lt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-857"></a><a name="f"></a><span class='hs-definition'>f</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>x</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>
<a name="line-858"></a>
<a name="line-859"></a><a name="when"></a><span class='hs-comment'>-- | Conditional execution of 'Applicative' expressions. For example,</span>
<a name="line-860"></a><span class='hs-comment'>--</span>
<a name="line-861"></a><span class='hs-comment'>-- &gt; when debug (putStrLn "Debugging")</span>
<a name="line-862"></a><span class='hs-comment'>--</span>
<a name="line-863"></a><span class='hs-comment'>-- will output the string @Debugging@ if the Boolean value @debug@</span>
<a name="line-864"></a><span class='hs-comment'>-- is 'True', and otherwise do nothing.</span>
<a name="line-865"></a><span class='hs-definition'>when</span>      <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-conid'>()</span>
<a name="line-866"></a><span class='hs-comment'>{-# INLINABLE when #-}</span>
<a name="line-867"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; IO () -&gt; IO () #-}</span>
<a name="line-868"></a><span class='hs-comment'>{-# SPECIALISE when :: Bool -&gt; Maybe () -&gt; Maybe () #-}</span>
<a name="line-869"></a><span class='hs-definition'>when</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>p</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-870"></a>
<a name="line-871"></a><a name="sequence"></a><span class='hs-comment'>-- | Evaluate each action in the sequence from left to right,</span>
<a name="line-872"></a><span class='hs-comment'>-- and collect the results.</span>
<a name="line-873"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>m</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-874"></a><span class='hs-comment'>{-# INLINE sequence #-}</span>
<a name="line-875"></a><span class='hs-definition'>sequence</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>id</span>
<a name="line-876"></a><span class='hs-comment'>-- Note: [sequence and mapM]</span>
<a name="line-877"></a>
<a name="line-878"></a><a name="mapM"></a><span class='hs-comment'>-- | @'mapM' f@ is equivalent to @'sequence' . 'map' f@.</span>
<a name="line-879"></a><span class='hs-definition'>mapM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-880"></a><span class='hs-comment'>{-# INLINE mapM #-}</span>
<a name="line-881"></a><span class='hs-definition'>mapM</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span>
<a name="line-882"></a>            <span class='hs-keyword'>where</span>
<a name="line-883"></a>              <span class='hs-varid'>k</span> <span class='hs-varid'>a</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>r</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-884"></a>
<a name="line-885"></a><span class='hs-comment'>{-
<a name="line-886"></a>Note: [sequence and mapM]
<a name="line-887"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-888"></a>Originally, we defined
<a name="line-889"></a>
<a name="line-890"></a>mapM f = sequence . map f
<a name="line-891"></a>
<a name="line-892"></a>This relied on list fusion to produce efficient code for mapM, and led to
<a name="line-893"></a>excessive allocation in cryptarithm2. Defining
<a name="line-894"></a>
<a name="line-895"></a>sequence = mapM id
<a name="line-896"></a>
<a name="line-897"></a>relies only on inlining a tiny function (id) and beta reduction, which tends to
<a name="line-898"></a>be a more reliable aspect of simplification. Indeed, this does not lead to
<a name="line-899"></a>similar problems in nofib.
<a name="line-900"></a>-}</span>
<a name="line-901"></a>
<a name="line-902"></a><a name="liftM"></a><span class='hs-comment'>-- | Promote a function to a monad.</span>
<a name="line-903"></a><span class='hs-definition'>liftM</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-904"></a><span class='hs-definition'>liftM</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span>              <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-905"></a>
<a name="line-906"></a><a name="liftM2"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-907"></a><span class='hs-comment'>-- left to right.  For example,</span>
<a name="line-908"></a><span class='hs-comment'>--</span>
<a name="line-909"></a><span class='hs-comment'>-- &gt; liftM2 (+) [0,1] [0,2] = [0,2,1,3]</span>
<a name="line-910"></a><span class='hs-comment'>-- &gt; liftM2 (+) (Just 1) Nothing = Nothing</span>
<a name="line-911"></a><span class='hs-comment'>--</span>
<a name="line-912"></a><span class='hs-definition'>liftM2</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-913"></a><span class='hs-definition'>liftM2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-914"></a><span class='hs-comment'>-- Caution: since this may be used for `liftA2`, we can't use the obvious</span>
<a name="line-915"></a><span class='hs-comment'>-- definition of liftM2 = liftA2.</span>
<a name="line-916"></a>
<a name="line-917"></a><a name="liftM3"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-918"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-919"></a><span class='hs-definition'>liftM3</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-920"></a><span class='hs-definition'>liftM3</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-921"></a>
<a name="line-922"></a><a name="liftM4"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-923"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-924"></a><span class='hs-definition'>liftM4</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-925"></a><span class='hs-definition'>liftM4</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-926"></a>
<a name="line-927"></a><a name="liftM5"></a><span class='hs-comment'>-- | Promote a function to a monad, scanning the monadic arguments from</span>
<a name="line-928"></a><span class='hs-comment'>-- left to right (cf. 'liftM2').</span>
<a name="line-929"></a><span class='hs-definition'>liftM5</span>  <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a4</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a5</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>r</span>
<a name="line-930"></a><span class='hs-definition'>liftM5</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span> <span class='hs-varid'>m3</span> <span class='hs-varid'>m4</span> <span class='hs-varid'>m5</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>x3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m3</span><span class='hs-layout'>;</span> <span class='hs-varid'>x4</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m4</span><span class='hs-layout'>;</span> <span class='hs-varid'>x5</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m5</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span> <span class='hs-varid'>x3</span> <span class='hs-varid'>x4</span> <span class='hs-varid'>x5</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-931"></a>
<a name="line-932"></a><span class='hs-comment'>{-# INLINABLE liftM #-}</span>
<a name="line-933"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; IO a1 -&gt; IO r #-}</span>
<a name="line-934"></a><span class='hs-comment'>{-# SPECIALISE liftM :: (a1-&gt;r) -&gt; Maybe a1 -&gt; Maybe r #-}</span>
<a name="line-935"></a><span class='hs-comment'>{-# INLINABLE liftM2 #-}</span>
<a name="line-936"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO r #-}</span>
<a name="line-937"></a><span class='hs-comment'>{-# SPECIALISE liftM2 :: (a1-&gt;a2-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe r #-}</span>
<a name="line-938"></a><span class='hs-comment'>{-# INLINABLE liftM3 #-}</span>
<a name="line-939"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO r #-}</span>
<a name="line-940"></a><span class='hs-comment'>{-# SPECIALISE liftM3 :: (a1-&gt;a2-&gt;a3-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe r #-}</span>
<a name="line-941"></a><span class='hs-comment'>{-# INLINABLE liftM4 #-}</span>
<a name="line-942"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO r #-}</span>
<a name="line-943"></a><span class='hs-comment'>{-# SPECIALISE liftM4 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe r #-}</span>
<a name="line-944"></a><span class='hs-comment'>{-# INLINABLE liftM5 #-}</span>
<a name="line-945"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; IO a1 -&gt; IO a2 -&gt; IO a3 -&gt; IO a4 -&gt; IO a5 -&gt; IO r #-}</span>
<a name="line-946"></a><span class='hs-comment'>{-# SPECIALISE liftM5 :: (a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;r) -&gt; Maybe a1 -&gt; Maybe a2 -&gt; Maybe a3 -&gt; Maybe a4 -&gt; Maybe a5 -&gt; Maybe r #-}</span>
<a name="line-947"></a>
<a name="line-948"></a><span class='hs-comment'>{- | In many situations, the 'liftM' operations can be replaced by uses of
<a name="line-949"></a>'ap', which promotes function application.
<a name="line-950"></a>
<a name="line-951"></a>&gt; return f `ap` x1 `ap` ... `ap` xn
<a name="line-952"></a>
<a name="line-953"></a>is equivalent to
<a name="line-954"></a>
<a name="line-955"></a>&gt; liftMn f x1 x2 ... xn
<a name="line-956"></a>
<a name="line-957"></a>-}</span>
<a name="line-958"></a>
<a name="line-959"></a><a name="ap"></a><span class='hs-definition'>ap</span>                <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>b</span>
<a name="line-960"></a><span class='hs-definition'>ap</span> <span class='hs-varid'>m1</span> <span class='hs-varid'>m2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>x1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m1</span><span class='hs-layout'>;</span> <span class='hs-varid'>x2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>m2</span><span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span> <span class='hs-varid'>x2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-961"></a><span class='hs-comment'>-- Since many Applicative instances define (&lt;*&gt;) = ap, we</span>
<a name="line-962"></a><span class='hs-comment'>-- cannot define ap = (&lt;*&gt;)</span>
<a name="line-963"></a><span class='hs-comment'>{-# INLINABLE ap #-}</span>
<a name="line-964"></a><span class='hs-comment'>{-# SPECIALISE ap :: IO (a -&gt; b) -&gt; IO a -&gt; IO b #-}</span>
<a name="line-965"></a><span class='hs-comment'>{-# SPECIALISE ap :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b #-}</span>
<a name="line-966"></a>
<a name="line-967"></a><span class='hs-comment'>-- instances for Prelude types</span>
<a name="line-968"></a>
<a name="line-969"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-970"></a><a name="instance%20Functor%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-971"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>
<a name="line-972"></a>
<a name="line-973"></a><a name="instance%20Applicative%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-974"></a><a name="instance%20Applicative%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-975"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>const</span>
<a name="line-976"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-977"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>q</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>q</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-978"></a>
<a name="line-979"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-980"></a><a name="instance%20Monad%20((-%3e)%20r)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-981"></a>    <span class='hs-varid'>f</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>r</span>
<a name="line-982"></a>
<a name="line-983"></a><a name="instance%20Functor%20((,)%20a)"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-984"></a><a name="instance%20Functor%20((,)%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>(,)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-985"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-986"></a>
<a name="line-987"></a><a name="instance%20Functor%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-988"></a><a name="instance%20Functor%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-989"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-990"></a>    <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-991"></a>
<a name="line-992"></a><a name="instance%20Applicative%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-993"></a><a name="instance%20Applicative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-994"></a>    <span class='hs-varid'>pure</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span>
<a name="line-995"></a>
<a name="line-996"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>f</span>  <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>m</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>m</span>
<a name="line-997"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-sel'>_m</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-998"></a>
<a name="line-999"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1000"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1001"></a>
<a name="line-1002"></a>    <span class='hs-conid'>Just</span> <span class='hs-sel'>_m1</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>m2</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m2</span>
<a name="line-1003"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>*&gt;</span> <span class='hs-sel'>_m2</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1004"></a>
<a name="line-1005"></a><a name="instance%20Monad%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1006"></a><a name="instance%20Monad%20Maybe"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>Maybe</span>  <span class='hs-keyword'>where</span>
<a name="line-1007"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-varid'>x</span>
<a name="line-1008"></a>    <span class='hs-conid'>Nothing</span>  <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1009"></a>
<a name="line-1010"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1011"></a>
<a name="line-1012"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-1013"></a><span class='hs-comment'>-- The Alternative class definition</span>
<a name="line-1014"></a>
<a name="line-1015"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>3</span> <span class='hs-varop'>&lt;|&gt;</span>
<a name="line-1016"></a>
<a name="line-1017"></a><a name="Alternative"></a><span class='hs-comment'>-- | A monoid on applicative functors.</span>
<a name="line-1018"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1019"></a><a name="Alternative"></a><span class='hs-comment'>-- If defined, 'some' and 'many' should be the least solutions</span>
<a name="line-1020"></a><a name="Alternative"></a><span class='hs-comment'>-- of the equations:</span>
<a name="line-1021"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1022"></a><a name="Alternative"></a><span class='hs-comment'>-- * @'some' v = (:) 'Prelude.&lt;$&gt;' v '&lt;*&gt;' 'many' v@</span>
<a name="line-1023"></a><a name="Alternative"></a><span class='hs-comment'>--</span>
<a name="line-1024"></a><a name="Alternative"></a><span class='hs-comment'>-- * @'many' v = 'some' v '&lt;|&gt;' 'pure' []@</span>
<a name="line-1025"></a><a name="Alternative"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Applicative</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Alternative</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>where</span>
<a name="line-1026"></a>    <span class='hs-comment'>-- | The identity of '&lt;|&gt;'</span>
<a name="line-1027"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1028"></a>    <span class='hs-comment'>-- | An associative binary operation</span>
<a name="line-1029"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1030"></a>
<a name="line-1031"></a>    <span class='hs-comment'>-- | One or more.</span>
<a name="line-1032"></a>    <span class='hs-varid'>some</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1033"></a>    <span class='hs-varid'>some</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span>
<a name="line-1034"></a>      <span class='hs-keyword'>where</span>
<a name="line-1035"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1036"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>many_v</span>
<a name="line-1037"></a>
<a name="line-1038"></a>    <span class='hs-comment'>-- | Zero or more.</span>
<a name="line-1039"></a>    <span class='hs-varid'>many</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1040"></a>    <span class='hs-varid'>many</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>many_v</span>
<a name="line-1041"></a>      <span class='hs-keyword'>where</span>
<a name="line-1042"></a>        <span class='hs-varid'>many_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>some_v</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>[]</span>
<a name="line-1043"></a>        <span class='hs-varid'>some_v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftA2</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>many_v</span>
<a name="line-1044"></a>
<a name="line-1045"></a>
<a name="line-1046"></a><a name="instance%20Alternative%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1047"></a><a name="instance%20Alternative%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>Maybe</span> <span class='hs-keyword'>where</span>
<a name="line-1048"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1049"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1050"></a>    <span class='hs-varid'>l</span>       <span class='hs-varop'>&lt;|&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span>
<a name="line-1051"></a>
<a name="line-1052"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-1053"></a><span class='hs-comment'>-- The MonadPlus class definition</span>
<a name="line-1054"></a>
<a name="line-1055"></a><a name="MonadPlus"></a><span class='hs-comment'>-- | Monads that also support choice and failure.</span>
<a name="line-1056"></a><a name="MonadPlus"></a><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alternative</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>where</span>
<a name="line-1057"></a>   <span class='hs-comment'>-- | The identity of 'mplus'.  It should also satisfy the equations</span>
<a name="line-1058"></a>   <span class='hs-comment'>--</span>
<a name="line-1059"></a>   <span class='hs-comment'>-- &gt; mzero &gt;&gt;= f  =  mzero</span>
<a name="line-1060"></a>   <span class='hs-comment'>-- &gt; v &gt;&gt; mzero   =  mzero</span>
<a name="line-1061"></a>   <span class='hs-comment'>--</span>
<a name="line-1062"></a>   <span class='hs-comment'>-- The default definition is</span>
<a name="line-1063"></a>   <span class='hs-comment'>--</span>
<a name="line-1064"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1065"></a>   <span class='hs-comment'>-- mzero = 'empty'</span>
<a name="line-1066"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1067"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-1068"></a>   <span class='hs-varid'>mzero</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-1069"></a>
<a name="line-1070"></a>   <span class='hs-comment'>-- | An associative operation. The default definition is</span>
<a name="line-1071"></a>   <span class='hs-comment'>--</span>
<a name="line-1072"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1073"></a>   <span class='hs-comment'>-- mplus = ('&lt;|&gt;')</span>
<a name="line-1074"></a>   <span class='hs-comment'>-- @</span>
<a name="line-1075"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-1076"></a>   <span class='hs-varid'>mplus</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span>
<a name="line-1077"></a>
<a name="line-1078"></a><a name="instance%20MonadPlus%20Maybe"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1079"></a><a name="instance%20MonadPlus%20Maybe"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>Maybe</span>
<a name="line-1080"></a>
<a name="line-1081"></a><span class='hs-comment'>---------------------------------------------</span>
<a name="line-1082"></a><span class='hs-comment'>-- The non-empty list type</span>
<a name="line-1083"></a>
<a name="line-1084"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>5</span> <span class='hs-conop'>:|</span>
<a name="line-1085"></a>
<a name="line-1086"></a><a name="NonEmpty"></a><span class='hs-comment'>-- | Non-empty (and non-strict) list type.</span>
<a name="line-1087"></a><a name="NonEmpty"></a><span class='hs-comment'>--</span>
<a name="line-1088"></a><a name="NonEmpty"></a><span class='hs-comment'>-- @since 4.9.0.0</span>
<a name="line-1089"></a><a name="NonEmpty"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1090"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Eq</span>  <span class='hs-comment'>-- ^ @since 4.9.0.0</span>
<a name="line-1091"></a>           <span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-comment'>-- ^ @since 4.9.0.0</span>
<a name="line-1092"></a>           <span class='hs-layout'>)</span>
<a name="line-1093"></a>
<a name="line-1094"></a><a name="instance%20Functor%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1095"></a><a name="instance%20Functor%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1096"></a>  <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>as</span>
<a name="line-1097"></a>  <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;$</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>   <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&lt;$</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-1098"></a>
<a name="line-1099"></a><a name="instance%20Applicative%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1100"></a><a name="instance%20Applicative%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1101"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span>
<a name="line-1102"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-1103"></a>  <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM2</span>
<a name="line-1104"></a>
<a name="line-1105"></a><a name="instance%20Monad%20NonEmpty"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1106"></a><a name="instance%20Monad%20NonEmpty"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-keyword'>where</span>
<a name="line-1107"></a>  <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-varid'>bs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bs'</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span>
<a name="line-1109"></a>          <span class='hs-varid'>bs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>toList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span>
<a name="line-1110"></a>          <span class='hs-varid'>toList</span> <span class='hs-keyglyph'>~</span><span class='hs-layout'>(</span><span class='hs-varid'>c</span> <span class='hs-conop'>:|</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cs</span>
<a name="line-1111"></a>
<a name="line-1112"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1113"></a><span class='hs-comment'>-- The list type</span>
<a name="line-1114"></a>
<a name="line-1115"></a><a name="instance%20Functor%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1116"></a><a name="instance%20Functor%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1117"></a>    <span class='hs-comment'>{-# INLINE fmap #-}</span>
<a name="line-1118"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span>
<a name="line-1119"></a>
<a name="line-1120"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-1121"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1122"></a><a name="instance%20Applicative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1123"></a>    <span class='hs-comment'>{-# INLINE pure #-}</span>
<a name="line-1124"></a>    <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-1125"></a>    <span class='hs-comment'>{-# INLINE (&lt;*&gt;) #-}</span>
<a name="line-1126"></a>    <span class='hs-varid'>fs</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fs</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>]</span>
<a name="line-1127"></a>    <span class='hs-comment'>{-# INLINE liftA2 #-}</span>
<a name="line-1128"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
<a name="line-1129"></a>    <span class='hs-comment'>{-# INLINE (*&gt;) #-}</span>
<a name="line-1130"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>ys</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ys</span><span class='hs-keyglyph'>]</span>
<a name="line-1131"></a>
<a name="line-1132"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-comment'>-- See Note: [List comprehensions and inlining]</span>
<a name="line-1133"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1134"></a><a name="instance%20Monad%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>[]</span>  <span class='hs-keyword'>where</span>
<a name="line-1135"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=) #-}</span>
<a name="line-1136"></a>    <span class='hs-varid'>xs</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>f</span>             <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xs</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span>
<a name="line-1137"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;) #-}</span>
<a name="line-1138"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1139"></a>
<a name="line-1140"></a><a name="instance%20Alternative%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1141"></a><a name="instance%20Alternative%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>where</span>
<a name="line-1142"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1143"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-1144"></a>
<a name="line-1145"></a><a name="instance%20MonadPlus%20%5b%5d"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1146"></a><a name="instance%20MonadPlus%20%5b%5d"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>[]</span>
<a name="line-1147"></a>
<a name="line-1148"></a><span class='hs-comment'>{-
<a name="line-1149"></a>A few list functions that appear here because they are used here.
<a name="line-1150"></a>The rest of the prelude list functions are in GHC.List.
<a name="line-1151"></a>-}</span>
<a name="line-1152"></a>
<a name="line-1153"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1154"></a><span class='hs-comment'>--      foldr/build/augment</span>
<a name="line-1155"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1156"></a>
<a name="line-1157"></a><span class='hs-comment'>-- | 'foldr', applied to a binary operator, a starting value (typically</span>
<a name="line-1158"></a><span class='hs-comment'>-- the right-identity of the operator), and a list, reduces the list</span>
<a name="line-1159"></a><span class='hs-comment'>-- using the binary operator, from right to left:</span>
<a name="line-1160"></a><span class='hs-comment'>--</span>
<a name="line-1161"></a><span class='hs-comment'>-- &gt; foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</span>
<a name="line-1162"></a>
<a name="line-1163"></a><span class='hs-definition'>foldr</span>            <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1164"></a><span class='hs-comment'>-- foldr _ z []     =  z</span>
<a name="line-1165"></a><span class='hs-comment'>-- foldr f z (x:xs) =  f x (foldr f z xs)</span>
<a name="line-1166"></a><span class='hs-comment'>{-# INLINE [0] foldr #-}</span>
<a name="line-1167"></a><span class='hs-comment'>-- Inline only in the final stage, after the foldr/cons rule has had a chance</span>
<a name="line-1168"></a><span class='hs-comment'>-- Also note that we inline it when it has *two* parameters, which are the</span>
<a name="line-1169"></a><span class='hs-comment'>-- ones we are keen about specialising!</span>
<a name="line-1170"></a><span class='hs-definition'>foldr</span> <span class='hs-varid'>k</span> <span class='hs-varid'>z</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1171"></a>          <span class='hs-keyword'>where</span>
<a name="line-1172"></a>            <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span>
<a name="line-1173"></a>            <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>y</span> <span class='hs-varop'>`k`</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ys</span>
<a name="line-1174"></a>
<a name="line-1175"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-1176"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-1177"></a><span class='hs-comment'>--</span>
<a name="line-1178"></a><span class='hs-comment'>-- &gt;    build g = g (:) []</span>
<a name="line-1179"></a><span class='hs-comment'>--</span>
<a name="line-1180"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-1181"></a><span class='hs-comment'>-- @'foldr' k z ('build' g)@, which may arise after inlining, to @g k z@,</span>
<a name="line-1182"></a><span class='hs-comment'>-- which avoids producing an intermediate list.</span>
<a name="line-1183"></a>
<a name="line-1184"></a><span class='hs-definition'>build</span>   <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1185"></a><span class='hs-comment'>{-# INLINE [1] build #-}</span>
<a name="line-1186"></a>        <span class='hs-comment'>-- The INLINE is important, even though build is tiny,</span>
<a name="line-1187"></a>        <span class='hs-comment'>-- because it prevents [] getting inlined in the version that</span>
<a name="line-1188"></a>        <span class='hs-comment'>-- appears in the interface file.  If [] *is* inlined, it</span>
<a name="line-1189"></a>        <span class='hs-comment'>-- won't match with [] appearing in rules in an importing module.</span>
<a name="line-1190"></a>        <span class='hs-comment'>--</span>
<a name="line-1191"></a>        <span class='hs-comment'>-- The "1" says to inline in phase 1</span>
<a name="line-1192"></a>
<a name="line-1193"></a><span class='hs-definition'>build</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-1194"></a>
<a name="line-1195"></a><span class='hs-comment'>-- | A list producer that can be fused with 'foldr'.</span>
<a name="line-1196"></a><span class='hs-comment'>-- This function is merely</span>
<a name="line-1197"></a><span class='hs-comment'>--</span>
<a name="line-1198"></a><span class='hs-comment'>-- &gt;    augment g xs = g (:) xs</span>
<a name="line-1199"></a><span class='hs-comment'>--</span>
<a name="line-1200"></a><span class='hs-comment'>-- but GHC's simplifier will transform an expression of the form</span>
<a name="line-1201"></a><span class='hs-comment'>-- @'foldr' k z ('augment' g xs)@, which may arise after inlining, to</span>
<a name="line-1202"></a><span class='hs-comment'>-- @g k ('foldr' k z xs)@, which avoids producing an intermediate list.</span>
<a name="line-1203"></a>
<a name="line-1204"></a><a name="augment"></a><span class='hs-definition'>augment</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>b</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>-&gt;</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1205"></a><span class='hs-comment'>{-# INLINE [1] augment #-}</span>
<a name="line-1206"></a><span class='hs-definition'>augment</span> <span class='hs-varid'>g</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-1207"></a>
<a name="line-1208"></a><span class='hs-comment'>{-# RULES
<a name="line-1209"></a>"fold/build"    forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1210"></a>                foldr k z (build g) = g k z
<a name="line-1211"></a>
<a name="line-1212"></a>"foldr/augment" forall k z xs (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1213"></a>                foldr k z (augment g xs) = g k (foldr k z xs)
<a name="line-1214"></a>
<a name="line-1215"></a>"foldr/id"                        foldr (:) [] = \x  -&gt; x
<a name="line-1216"></a>"foldr/app"     [1] forall ys. foldr (:) ys = \xs -&gt; xs ++ ys
<a name="line-1217"></a>        -- Only activate this from phase 1, because that's
<a name="line-1218"></a>        -- when we disable the rule that expands (++) into foldr
<a name="line-1219"></a>
<a name="line-1220"></a>-- The foldr/cons rule looks nice, but it can give disastrously
<a name="line-1221"></a>-- bloated code when commpiling
<a name="line-1222"></a>--      array (a,b) [(1,2), (2,2), (3,2), ...very long list... ]
<a name="line-1223"></a>-- i.e. when there are very very long literal lists
<a name="line-1224"></a>-- So I've disabled it for now. We could have special cases
<a name="line-1225"></a>-- for short lists, I suppose.
<a name="line-1226"></a>-- "foldr/cons" forall k z x xs. foldr k z (x:xs) = k x (foldr k z xs)
<a name="line-1227"></a>
<a name="line-1228"></a>"foldr/single"  forall k z x. foldr k z [x] = k x z
<a name="line-1229"></a>"foldr/nil"     forall k z.   foldr k z []  = z
<a name="line-1230"></a>
<a name="line-1231"></a>"foldr/cons/build" forall k z x (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1232"></a>                           foldr k z (x:build g) = k x (g k z)
<a name="line-1233"></a>
<a name="line-1234"></a>"augment/build" forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b)
<a name="line-1235"></a>                       (h::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1236"></a>                       augment g (build h) = build (\c n -&gt; g c (h c n))
<a name="line-1237"></a>"augment/nil"   forall (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
<a name="line-1238"></a>                        augment g [] = build g
<a name="line-1239"></a> #-}</span>
<a name="line-1240"></a>
<a name="line-1241"></a><span class='hs-comment'>-- This rule is true, but not (I think) useful:</span>
<a name="line-1242"></a><span class='hs-comment'>--      augment g (augment h t) = augment (\cn -&gt; g c (h c n)) t</span>
<a name="line-1243"></a>
<a name="line-1244"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1245"></a><span class='hs-comment'>--              map</span>
<a name="line-1246"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1247"></a>
<a name="line-1248"></a><span class='hs-comment'>-- | \(\mathcal{O}(n)\). 'map' @f xs@ is the list obtained by applying @f@ to</span>
<a name="line-1249"></a><span class='hs-comment'>-- each element of @xs@, i.e.,</span>
<a name="line-1250"></a><span class='hs-comment'>--</span>
<a name="line-1251"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]</span>
<a name="line-1252"></a><span class='hs-comment'>-- &gt; map f [x1, x2, ...] == [f x1, f x2, ...]</span>
<a name="line-1253"></a><span class='hs-comment'>--</span>
<a name="line-1254"></a><span class='hs-comment'>-- &gt;&gt;&gt; map (+1) [1, 2, 3]</span>
<a name="line-1255"></a><span class='hs-comment'>--- [2,3,4]</span>
<a name="line-1256"></a>
<a name="line-1257"></a><a name="map"></a><span class='hs-definition'>map</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1258"></a><span class='hs-comment'>{-# NOINLINE [0] map #-}</span>
<a name="line-1259"></a>  <span class='hs-comment'>-- We want the RULEs "map" and "map/coerce" to fire first.</span>
<a name="line-1260"></a>  <span class='hs-comment'>-- map is recursive, so won't inline anyway,</span>
<a name="line-1261"></a>  <span class='hs-comment'>-- but saying so is more explicit, and silences warnings</span>
<a name="line-1262"></a><span class='hs-definition'>map</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1263"></a><span class='hs-definition'>map</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>xs</span>
<a name="line-1264"></a>
<a name="line-1265"></a><a name="mapFB"></a><span class='hs-comment'>-- Note eta expanded</span>
<a name="line-1266"></a><span class='hs-definition'>mapFB</span> <span class='hs-keyglyph'>::</span>  <span class='hs-layout'>(</span><span class='hs-varid'>elt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>elt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lst</span>
<a name="line-1267"></a><span class='hs-comment'>{-# INLINE [0] mapFB #-}</span> <span class='hs-comment'>-- See Note [Inline FB functions] in GHC.List</span>
<a name="line-1268"></a><span class='hs-definition'>mapFB</span> <span class='hs-varid'>c</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span>
<a name="line-1269"></a>
<a name="line-1270"></a><span class='hs-comment'>{- Note [The rules for map]
<a name="line-1271"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1272"></a>The rules for map work like this.
<a name="line-1273"></a>
<a name="line-1274"></a>* Up to (but not including) phase 1, we use the "map" rule to
<a name="line-1275"></a>  rewrite all saturated applications of map with its build/fold
<a name="line-1276"></a>  form, hoping for fusion to happen.
<a name="line-1277"></a>
<a name="line-1278"></a>  In phase 1 and 0, we switch off that rule, inline build, and
<a name="line-1279"></a>  switch on the "mapList" rule, which rewrites the foldr/mapFB
<a name="line-1280"></a>  thing back into plain map.
<a name="line-1281"></a>
<a name="line-1282"></a>  It's important that these two rules aren't both active at once
<a name="line-1283"></a>  (along with build's unfolding) else we'd get an infinite loop
<a name="line-1284"></a>  in the rules.  Hence the activation control below.
<a name="line-1285"></a>
<a name="line-1286"></a>* This same pattern is followed by many other functions:
<a name="line-1287"></a>  e.g. append, filter, iterate, repeat, etc. in GHC.List
<a name="line-1288"></a>
<a name="line-1289"></a>  See also Note [Inline FB functions] in GHC.List
<a name="line-1290"></a>
<a name="line-1291"></a>* The "mapFB" rule optimises compositions of map
<a name="line-1292"></a>
<a name="line-1293"></a>* The "mapFB/id" rule gets rid of 'map id' calls.
<a name="line-1294"></a>  You might think that (mapFB c id) will turn into c simply
<a name="line-1295"></a>  when mapFB is inlined; but before that happens the "mapList"
<a name="line-1296"></a>  rule turns
<a name="line-1297"></a>     (foldr (mapFB (:) id) [] a
<a name="line-1298"></a>  back into
<a name="line-1299"></a>     map id
<a name="line-1300"></a>  Which is not very clever.
<a name="line-1301"></a>
<a name="line-1302"></a>* Any similarity to the Functor laws for [] is expected.
<a name="line-1303"></a>-}</span>
<a name="line-1304"></a>
<a name="line-1305"></a><span class='hs-comment'>{-# RULES
<a name="line-1306"></a>"map"       [~1] forall f xs.   map f xs                = build (\c n -&gt; foldr (mapFB c f) n xs)
<a name="line-1307"></a>"mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
<a name="line-1308"></a>"mapFB"     forall c f g.       mapFB (mapFB c f) g     = mapFB c (f.g)
<a name="line-1309"></a>"mapFB/id"  forall c.           mapFB c (\x -&gt; x)       = c
<a name="line-1310"></a>  #-}</span>
<a name="line-1311"></a>
<a name="line-1312"></a><span class='hs-comment'>-- See Breitner, Eisenberg, Peyton Jones, and Weirich, "Safe Zero-cost</span>
<a name="line-1313"></a><span class='hs-comment'>-- Coercions for Haskell", section 6.5:</span>
<a name="line-1314"></a><span class='hs-comment'>--   <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf">http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf</a></span>
<a name="line-1315"></a>
<a name="line-1316"></a><span class='hs-comment'>{-# RULES "map/coerce" [1] map coerce = coerce #-}</span>
<a name="line-1317"></a>
<a name="line-1318"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1319"></a><span class='hs-comment'>--              append</span>
<a name="line-1320"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1321"></a>
<a name="line-1322"></a><span class='hs-comment'>-- | Append two lists, i.e.,</span>
<a name="line-1323"></a><span class='hs-comment'>--</span>
<a name="line-1324"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]</span>
<a name="line-1325"></a><span class='hs-comment'>-- &gt; [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</span>
<a name="line-1326"></a><span class='hs-comment'>--</span>
<a name="line-1327"></a><span class='hs-comment'>-- If the first list is not finite, the result is the first list.</span>
<a name="line-1328"></a>
<a name="line-1329"></a><a name="++"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1330"></a><span class='hs-comment'>{-# NOINLINE [1] (++) #-}</span>    <span class='hs-comment'>-- We want the RULE to fire first.</span>
<a name="line-1331"></a>                             <span class='hs-comment'>-- It's recursive, so won't inline anyway,</span>
<a name="line-1332"></a>                             <span class='hs-comment'>-- but saying so is more explicit</span>
<a name="line-1333"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<a name="line-1334"></a><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span>
<a name="line-1335"></a>
<a name="line-1336"></a><span class='hs-comment'>{-# RULES
<a name="line-1337"></a>"++"    [~1] forall xs ys. xs ++ ys = augment (\c n -&gt; foldr c n xs) ys
<a name="line-1338"></a>  #-}</span>
<a name="line-1339"></a>
<a name="line-1340"></a>
<a name="line-1341"></a><span class='hs-comment'>-- |'otherwise' is defined as the value 'True'.  It helps to make</span>
<a name="line-1342"></a><span class='hs-comment'>-- guards more readable.  eg.</span>
<a name="line-1343"></a><span class='hs-comment'>--</span>
<a name="line-1344"></a><span class='hs-comment'>-- &gt;  f x | x &lt; 0     = ...</span>
<a name="line-1345"></a><span class='hs-comment'>-- &gt;      | otherwise = ...</span>
<a name="line-1346"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1347"></a><span class='hs-definition'>otherwise</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>True</span>
<a name="line-1348"></a>
<a name="line-1349"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1350"></a><span class='hs-comment'>-- Type Char and String</span>
<a name="line-1351"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1352"></a>
<a name="line-1353"></a><a name="String"></a><span class='hs-comment'>-- | A 'String' is a list of characters.  String constants in Haskell are values</span>
<a name="line-1354"></a><a name="String"></a><span class='hs-comment'>-- of type 'String'.</span>
<a name="line-1355"></a><a name="String"></a><span class='hs-comment'>--</span>
<a name="line-1356"></a><a name="String"></a><span class='hs-comment'>-- See "Data.List" for operations on lists.</span>
<a name="line-1357"></a><a name="String"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Char</span><span class='hs-keyglyph'>]</span>
<a name="line-1358"></a>
<a name="line-1359"></a><a name="unsafeChr"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Char</span>
<a name="line-1360"></a><span class='hs-definition'>unsafeChr</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>chr</span><span class='hs-cpp'>#</span> <span class='hs-varid'>i</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1361"></a>
<a name="line-1362"></a><a name="ord"></a><span class='hs-comment'>-- | The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'.</span>
<a name="line-1363"></a><span class='hs-definition'>ord</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1364"></a><span class='hs-definition'>ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>ord</span><span class='hs-cpp'>#</span> <span class='hs-varid'>c</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1365"></a>
<a name="line-1366"></a><a name="eqString"></a><span class='hs-comment'>-- | This 'String' equality predicate is used when desugaring</span>
<a name="line-1367"></a><span class='hs-comment'>-- pattern-matches against strings.</span>
<a name="line-1368"></a><span class='hs-definition'>eqString</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1369"></a><span class='hs-definition'>eqString</span> <span class='hs-conid'>[]</span>       <span class='hs-conid'>[]</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1370"></a><span class='hs-definition'>eqString</span> <span class='hs-layout'>(</span><span class='hs-varid'>c1</span><span class='hs-conop'>:</span><span class='hs-varid'>cs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>c2</span><span class='hs-conop'>:</span><span class='hs-varid'>cs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>c2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>cs1</span> <span class='hs-varop'>`eqString`</span> <span class='hs-varid'>cs2</span>
<a name="line-1371"></a><span class='hs-definition'>eqString</span> <span class='hs-keyword'>_</span>        <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1372"></a>
<a name="line-1373"></a><span class='hs-comment'>{-# RULES "eqString" (==) = eqString #-}</span>
<a name="line-1374"></a><span class='hs-comment'>-- eqString also has a BuiltInRule in PrelRules.hs:</span>
<a name="line-1375"></a><span class='hs-comment'>--      eqString (unpackCString# (Lit s1)) (unpackCString# (Lit s2)) = s1==s2</span>
<a name="line-1376"></a>
<a name="line-1377"></a>
<a name="line-1378"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1379"></a><span class='hs-comment'>-- 'Int' related definitions</span>
<a name="line-1380"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1381"></a>
<a name="line-1382"></a><a name="maxInt"></a><span class='hs-definition'>maxInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>minInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-1383"></a>
<a name="line-1384"></a><span class='hs-comment'>{- Seems clumsy. Should perhaps put minInt and MaxInt directly into MachDeps.h -}</span>
<a name="line-1385"></a><span class='hs-cpp'>#if WORD_SIZE_IN_BITS == 31</span>
<a name="line-1386"></a><a name="minInt"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x40000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1387"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x3FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1388"></a><span class='hs-cpp'>#elif WORD_SIZE_IN_BITS == 32</span>
<a name="line-1389"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x80000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1390"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1391"></a><span class='hs-cpp'>#else</span>
<a name="line-1392"></a><span class='hs-definition'>minInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>0x8000000000000000</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1393"></a><span class='hs-definition'>maxInt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-num'>0x7FFFFFFFFFFFFFFF</span><span class='hs-cpp'>#</span>
<a name="line-1394"></a><span class='hs-cpp'>#endif</span>
<a name="line-1395"></a>
<a name="line-1396"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1397"></a><span class='hs-comment'>-- The function type</span>
<a name="line-1398"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1399"></a>
<a name="line-1400"></a><a name="id"></a><span class='hs-comment'>-- | Identity function.</span>
<a name="line-1401"></a><span class='hs-comment'>--</span>
<a name="line-1402"></a><span class='hs-comment'>-- &gt; id x = x</span>
<a name="line-1403"></a><span class='hs-definition'>id</span>                      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1404"></a><span class='hs-definition'>id</span> <span class='hs-varid'>x</span>                    <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-1405"></a>
<a name="line-1406"></a><span class='hs-comment'>-- Assertion function.  This simply ignores its boolean argument.</span>
<a name="line-1407"></a><span class='hs-comment'>-- The compiler may rewrite it to @('assertError' line)@.</span>
<a name="line-1408"></a>
<a name="line-1409"></a><span class='hs-comment'>-- | If the first argument evaluates to 'True', then the result is the</span>
<a name="line-1410"></a><span class='hs-comment'>-- second argument.  Otherwise an 'Control.Exception.AssertionFailed' exception</span>
<a name="line-1411"></a><span class='hs-comment'>-- is raised, containing a 'String' with the source file and line number of the</span>
<a name="line-1412"></a><span class='hs-comment'>-- call to 'assert'.</span>
<a name="line-1413"></a><span class='hs-comment'>--</span>
<a name="line-1414"></a><span class='hs-comment'>-- Assertions can normally be turned on or off with a compiler flag</span>
<a name="line-1415"></a><span class='hs-comment'>-- (for GHC, assertions are normally on unless optimisation is turned on</span>
<a name="line-1416"></a><span class='hs-comment'>-- with @-O@ or the @-fignore-asserts@</span>
<a name="line-1417"></a><span class='hs-comment'>-- option is given).  When assertions are turned off, the first</span>
<a name="line-1418"></a><span class='hs-comment'>-- argument to 'assert' is ignored, and the second argument is</span>
<a name="line-1419"></a><span class='hs-comment'>-- returned as the result.</span>
<a name="line-1420"></a>
<a name="line-1421"></a><a name="assert"></a><span class='hs-comment'>--      SLPJ: in 5.04 etc 'assert' is in GHC.Prim,</span>
<a name="line-1422"></a><span class='hs-comment'>--      but from Template Haskell onwards it's simply</span>
<a name="line-1423"></a><span class='hs-comment'>--      defined here in Base.hs</span>
<a name="line-1424"></a><span class='hs-definition'>assert</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1425"></a><span class='hs-definition'>assert</span> <span class='hs-sel'>_pred</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1426"></a>
<a name="line-1427"></a><a name="breakpoint"></a><span class='hs-definition'>breakpoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1428"></a><span class='hs-definition'>breakpoint</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1429"></a>
<a name="line-1430"></a><a name="breakpointCond"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1431"></a><span class='hs-definition'>breakpointCond</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1432"></a>
<a name="line-1433"></a><a name="Opaque"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Opaque</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span><span class='hs-varop'>.</span> <span class='hs-conid'>O</span> <span class='hs-varid'>a</span>
<a name="line-1434"></a><a name="const"></a><span class='hs-comment'>-- | @const x@ is a unary function which evaluates to @x@ for all inputs.</span>
<a name="line-1435"></a><span class='hs-comment'>--</span>
<a name="line-1436"></a><span class='hs-comment'>-- &gt;&gt;&gt; const 42 "hello"</span>
<a name="line-1437"></a><span class='hs-comment'>-- 42</span>
<a name="line-1438"></a><span class='hs-comment'>--</span>
<a name="line-1439"></a><span class='hs-comment'>-- &gt;&gt;&gt; map (const 42) [0..3]</span>
<a name="line-1440"></a><span class='hs-comment'>-- [42,42,42,42]</span>
<a name="line-1441"></a><span class='hs-definition'>const</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1442"></a><span class='hs-definition'>const</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>x</span>
<a name="line-1443"></a>
<a name="line-1444"></a><a name="."></a><span class='hs-comment'>-- | Function composition.</span>
<a name="line-1445"></a><span class='hs-comment'>{-# INLINE (.) #-}</span>
<a name="line-1446"></a><span class='hs-comment'>-- Make sure it has TWO args only on the left, so that it inlines</span>
<a name="line-1447"></a><span class='hs-comment'>-- when applied to two functions, even if there is no final argument</span>
<a name="line-1448"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1449"></a><span class='hs-layout'>(</span><span class='hs-varop'>.</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1450"></a>
<a name="line-1451"></a><a name="flip"></a><span class='hs-comment'>-- | @'flip' f@ takes its (first) two arguments in the reverse order of @f@.</span>
<a name="line-1452"></a><span class='hs-comment'>--</span>
<a name="line-1453"></a><span class='hs-comment'>-- &gt;&gt;&gt; flip (++) "hello" "world"</span>
<a name="line-1454"></a><span class='hs-comment'>-- "worldhello"</span>
<a name="line-1455"></a><span class='hs-definition'>flip</span>                    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-1456"></a><span class='hs-definition'>flip</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>              <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>y</span> <span class='hs-varid'>x</span>
<a name="line-1457"></a>
<a name="line-1458"></a><a name="$"></a><span class='hs-comment'>-- | Application operator.  This operator is redundant, since ordinary</span>
<a name="line-1459"></a><span class='hs-comment'>-- application @(f x)@ means the same as @(f '$' x)@. However, '$' has</span>
<a name="line-1460"></a><span class='hs-comment'>-- low, right-associative binding precedence, so it sometimes allows</span>
<a name="line-1461"></a><span class='hs-comment'>-- parentheses to be omitted; for example:</span>
<a name="line-1462"></a><span class='hs-comment'>--</span>
<a name="line-1463"></a><span class='hs-comment'>-- &gt; f $ g $ h x  =  f (g (h x))</span>
<a name="line-1464"></a><span class='hs-comment'>--</span>
<a name="line-1465"></a><span class='hs-comment'>-- It is also useful in higher-order situations, such as @'map' ('$' 0) xs@,</span>
<a name="line-1466"></a><span class='hs-comment'>-- or @'Data.List.zipWith' ('$') fs xs@.</span>
<a name="line-1467"></a><span class='hs-comment'>--</span>
<a name="line-1468"></a><span class='hs-comment'>-- Note that @('$')@ is levity-polymorphic in its result type, so that</span>
<a name="line-1469"></a><span class='hs-comment'>-- @foo '$' True@ where @foo :: Bool -&gt; Int#@ is well-typed.</span>
<a name="line-1470"></a><span class='hs-comment'>{-# INLINE ($) #-}</span>
<a name="line-1471"></a><span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>r</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1472"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
<a name="line-1473"></a>
<a name="line-1474"></a><span class='hs-comment'>-- | Strict (call-by-value) application operator. It takes a function and an</span>
<a name="line-1475"></a><span class='hs-comment'>-- argument, evaluates the argument to weak head normal form (WHNF), then calls</span>
<a name="line-1476"></a><span class='hs-comment'>-- the function with that value.</span>
<a name="line-1477"></a>
<a name="line-1478"></a><a name="$!"></a><span class='hs-layout'>(</span><span class='hs-varop'>$!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>r</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TYPE</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span>
<a name="line-1479"></a><span class='hs-definition'>f</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>vx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vx</span>  <span class='hs-comment'>-- see #2273</span>
<a name="line-1480"></a>
<a name="line-1481"></a><a name="until"></a><span class='hs-comment'>-- | @'until' p f@ yields the result of applying @f@ until @p@ holds.</span>
<a name="line-1482"></a><span class='hs-definition'>until</span>                   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1483"></a><span class='hs-definition'>until</span> <span class='hs-varid'>p</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1484"></a>  <span class='hs-keyword'>where</span>
<a name="line-1485"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>p</span> <span class='hs-varid'>x</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<a name="line-1486"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-1487"></a>
<a name="line-1488"></a><a name="asTypeOf"></a><span class='hs-comment'>-- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually</span>
<a name="line-1489"></a><span class='hs-comment'>-- used as an infix operator, and its typing forces its first argument</span>
<a name="line-1490"></a><span class='hs-comment'>-- (which is usually overloaded) to have the same type as the second.</span>
<a name="line-1491"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1492"></a><span class='hs-definition'>asTypeOf</span>                <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>const</span>
<a name="line-1493"></a>
<a name="line-1494"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1495"></a><span class='hs-comment'>-- Functor/Applicative/Monad instances for IO</span>
<a name="line-1496"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1497"></a>
<a name="line-1498"></a><a name="instance%20Functor%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1499"></a><a name="instance%20Functor%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Functor</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1500"></a>   <span class='hs-varid'>fmap</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1501"></a>
<a name="line-1502"></a><a name="instance%20Applicative%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1503"></a><a name="instance%20Applicative%20IO"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1504"></a>    <span class='hs-comment'>{-# INLINE pure #-}</span>
<a name="line-1505"></a>    <span class='hs-comment'>{-# INLINE (*&gt;) #-}</span>
<a name="line-1506"></a>    <span class='hs-comment'>{-# INLINE liftA2 #-}</span>
<a name="line-1507"></a>    <span class='hs-varid'>pure</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>returnIO</span>
<a name="line-1508"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thenIO</span>
<a name="line-1509"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-1510"></a>    <span class='hs-varid'>liftA2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM2</span>
<a name="line-1511"></a>
<a name="line-1512"></a><a name="instance%20Monad%20IO"></a><span class='hs-comment'>-- | @since 2.01</span>
<a name="line-1513"></a><a name="instance%20Monad%20IO"></a><span class='hs-keyword'>instance</span>  <span class='hs-conid'>Monad</span> <span class='hs-conid'>IO</span>  <span class='hs-keyword'>where</span>
<a name="line-1514"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;)   #-}</span>
<a name="line-1515"></a>    <span class='hs-comment'>{-# INLINE (&gt;&gt;=)  #-}</span>
<a name="line-1516"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>*&gt;</span><span class='hs-layout'>)</span>
<a name="line-1517"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&gt;&gt;=</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bindIO</span>
<a name="line-1518"></a>
<a name="line-1519"></a><a name="instance%20Alternative%20IO"></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1520"></a><a name="instance%20Alternative%20IO"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Alternative</span> <span class='hs-conid'>IO</span> <span class='hs-keyword'>where</span>
<a name="line-1521"></a>    <span class='hs-varid'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failIO</span> <span class='hs-str'>"mzero"</span>
<a name="line-1522"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;|&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mplusIO</span>
<a name="line-1523"></a>
<a name="line-1524"></a><a name="instance%20MonadPlus%20IO%20returnIO%20::%20a%20-%3e%20IO%20a%20returnIO%20x%20=%20IO%20(%5c%20s%20-%3e%20("></a><span class='hs-comment'>-- | @since 4.9.0.0</span>
<a name="line-1525"></a><a name="instance%20MonadPlus%20IO%20returnIO%20::%20a%20-%3e%20IO%20a%20returnIO%20x%20=%20IO%20(%5c%20s%20-%3e%20("></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadPlus</span> <span class='hs-conid'>IO</span>
<a name="line-1526"></a>
<a name="line-1527"></a><a name="returnIO"></a><span class='hs-definition'>returnIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-1528"></a><span class='hs-definition'>returnIO</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1529"></a>
<a name="line-1530"></a><a name="bindIO"></a><span class='hs-definition'>bindIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1531"></a><span class='hs-definition'>bindIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>)</span>
<a name="line-1532"></a>
<a name="line-1533"></a><a name="thenIO"></a><span class='hs-definition'>thenIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>b</span>
<a name="line-1534"></a><span class='hs-definition'>thenIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unIO</span> <span class='hs-varid'>k</span> <span class='hs-varid'>new_s</span><span class='hs-layout'>)</span>
<a name="line-1535"></a>
<a name="line-1536"></a><a name="failIO"></a><span class='hs-comment'>-- Note that it is import that we do not SOURCE import this as</span>
<a name="line-1537"></a><span class='hs-comment'>-- its demand signature encodes knowledge of its bottoming</span>
<a name="line-1538"></a><span class='hs-comment'>-- behavior, which can expose useful simplifications. See</span>
<a name="line-1539"></a><span class='hs-comment'>-- #16588.</span>
<a name="line-1540"></a><span class='hs-definition'>failIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span>
<a name="line-1541"></a><span class='hs-definition'>failIO</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>raiseIO</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUserError</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1542"></a>
<a name="line-1543"></a><a name="unIO"></a><span class='hs-definition'>unIO</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1544"></a><span class='hs-definition'>unIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-1545"></a>
<a name="line-1546"></a><a name="getTag"></a><span class='hs-comment'>{- |
<a name="line-1547"></a>Returns the tag of a constructor application; this function is used
<a name="line-1548"></a>by the deriving code for Eq, Ord and Enum.
<a name="line-1549"></a>-}</span>
<a name="line-1550"></a><span class='hs-comment'>{-# INLINE getTag #-}</span>
<a name="line-1551"></a><span class='hs-definition'>getTag</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1552"></a><span class='hs-definition'>getTag</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataToTag</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span>
<a name="line-1553"></a>
<a name="line-1554"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1555"></a><span class='hs-comment'>-- Numeric primops</span>
<a name="line-1556"></a><span class='hs-comment'>----------------------------------------------</span>
<a name="line-1557"></a>
<a name="line-1558"></a><span class='hs-comment'>-- Definitions of the boxed PrimOps; these will be</span>
<a name="line-1559"></a><span class='hs-comment'>-- used in the case of partial applications, etc.</span>
<a name="line-1560"></a>
<a name="line-1561"></a><span class='hs-comment'>{-# INLINE quotInt #-}</span>
<a name="line-1562"></a><span class='hs-comment'>{-# INLINE remInt #-}</span>
<a name="line-1563"></a>
<a name="line-1564"></a><a name="quotInt"></a><span class='hs-definition'>quotInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>remInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>divInt</span><span class='hs-layout'>,</span> <span class='hs-varid'>modInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1565"></a><a name="quotInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotInt`</span>  <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1566"></a><a name="remInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`remInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>remInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1567"></a><a name="divInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1568"></a><a name="modInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`modInt`</span>   <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>modInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-1569"></a>
<a name="line-1570"></a><a name="quotRemInt"></a><span class='hs-definition'>quotRemInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1571"></a><a name="quotRemInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`quotRemInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1572"></a>                             <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1573"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1574"></a>
<a name="line-1575"></a><a name="divModInt"></a><span class='hs-definition'>divModInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1576"></a><a name="divModInt"></a><span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>`divModInt`</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>of</span>
<a name="line-1577"></a>                            <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1578"></a>
<a name="line-1579"></a><span class='hs-definition'>divModInt</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1580"></a><a name="x"></a><span class='hs-definition'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>divModInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1581"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1582"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1583"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1584"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>&gt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1585"></a>                                    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>+#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>of</span>
<a name="line-1586"></a>                                      <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>q</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>+#</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span> <span class='hs-varop'>-#</span> <span class='hs-num'>1</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1587"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                <span class='hs-keyglyph'>=</span>
<a name="line-1588"></a>                                    <span class='hs-varid'>x</span><span class='hs-cpp'>#</span> <span class='hs-varop'>`</span><span class='hs-varid'>quotRemInt</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>y</span><span class='hs-cpp'>#</span>
<a name="line-1589"></a>
<a name="line-1590"></a><span class='hs-comment'>-- Wrappers for the shift operations.  The uncheckedShift# family are</span>
<a name="line-1591"></a><span class='hs-comment'>-- undefined when the amount being shifted by is greater than the size</span>
<a name="line-1592"></a><span class='hs-comment'>-- in bits of Int#, so these wrappers perform a check and return</span>
<a name="line-1593"></a><span class='hs-comment'>-- either zero or -1 appropriately.</span>
<a name="line-1594"></a><span class='hs-comment'>--</span>
<a name="line-1595"></a><span class='hs-comment'>-- Note that these wrappers still produce undefined results when the</span>
<a name="line-1596"></a><span class='hs-comment'>-- second argument (the shift amount) is negative.</span>
<a name="line-1597"></a>
<a name="line-1598"></a><a name="shiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1599"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1600"></a><span class='hs-definition'>shiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1601"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1602"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1603"></a>
<a name="line-1604"></a><a name="shiftRL"></a><span class='hs-comment'>-- | Shift the argument right by the specified number of bits</span>
<a name="line-1605"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1606"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1607"></a><span class='hs-comment'>-- (although an arithmetic right shift wouldn't make sense for Word#)</span>
<a name="line-1608"></a><span class='hs-definition'>shiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span><span class='hs-cpp'>#</span>
<a name="line-1609"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>shiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>##</span>
<a name="line-1610"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1611"></a>
<a name="line-1612"></a><a name="iShiftL"></a><span class='hs-comment'>-- | Shift the argument left by the specified number of bits</span>
<a name="line-1613"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1614"></a><span class='hs-definition'>iShiftL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1615"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1616"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1617"></a>
<a name="line-1618"></a><a name="iShiftRA"></a><span class='hs-comment'>-- | Shift the argument right (signed) by the specified number of bits</span>
<a name="line-1619"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1620"></a><span class='hs-comment'>-- The "RA" means "right, arithmetic" (as opposed to RL for logical)</span>
<a name="line-1621"></a><span class='hs-definition'>iShiftRA</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1622"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;#</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1623"></a>                                                          <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-1624"></a>                                                          <span class='hs-keyword'>else</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1625"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRA</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1626"></a>
<a name="line-1627"></a><a name="iShiftRL"></a><span class='hs-comment'>-- | Shift the argument right (unsigned) by the specified number of bits</span>
<a name="line-1628"></a><span class='hs-comment'>-- (which must be non-negative).</span>
<a name="line-1629"></a><span class='hs-comment'>-- The "RL" means "right, logical" (as opposed to RA for arithmetic)</span>
<a name="line-1630"></a><span class='hs-definition'>iShiftRL</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-cpp'>#</span>
<a name="line-1631"></a><a name=""></a><span class='hs-definition'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>iShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-varop'>&gt;=#</span> <span class='hs-conid'>WORD_SIZE_IN_BITS</span><span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-cpp'>#</span>
<a name="line-1632"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`</span><span class='hs-varid'>uncheckedIShiftRL</span><span class='hs-cpp'>#</span><span class='hs-varop'>`</span> <span class='hs-varid'>b</span>
<a name="line-1633"></a>
<a name="line-1634"></a><span class='hs-comment'>-- Rules for C strings (the functions themselves are now in GHC.CString)</span>
<a name="line-1635"></a><span class='hs-comment'>{-# RULES
<a name="line-1636"></a>"unpack"       [~1] forall a   . unpackCString# a             = build (unpackFoldrCString# a)
<a name="line-1637"></a>"unpack-list"  [1]  forall a   . unpackFoldrCString# a (:) [] = unpackCString# a
<a name="line-1638"></a>"unpack-append"     forall a n . unpackFoldrCString# a (:) n  = unpackAppendCString# a n
<a name="line-1639"></a>
<a name="line-1640"></a>-- There's a built-in rule (in PrelRules.hs) for
<a name="line-1641"></a>--      unpackFoldr "foo" c (unpackFoldr "baz" c n)  =  unpackFoldr "foobaz" c n
<a name="line-1642"></a>
<a name="line-1643"></a>  #-}</span>
</pre></body>
</html>
