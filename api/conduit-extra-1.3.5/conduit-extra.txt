-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Batteries included conduit: adapters for common libraries.
--   
--   The conduit package itself maintains relative small dependencies. The
--   purpose of this package is to collect commonly used utility functions
--   wrapping other library dependencies, without depending on
--   heavier-weight dependencies. The basic idea is that this package
--   should only depend on haskell-platform packages and conduit.
@package conduit-extra
@version 1.3.5


-- | Consume attoparsec parsers via conduit.
--   
--   This code was taken from attoparsec-enumerator and adapted for
--   conduits.
module Data.Conduit.Attoparsec

-- | Convert an Attoparsec <a>Parser</a> into a <a>Sink</a>. The parser
--   will be streamed bytes until it returns <a>Done</a> or <a>Fail</a>.
--   
--   If parsing fails, a <a>ParseError</a> will be thrown with
--   <a>throwM</a>.
--   
--   Since 0.5.0
sinkParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> ConduitT a o m b

-- | Same as <a>sinkParser</a>, but we return an <a>Either</a> type instead
--   of raising an exception.
--   
--   Since 1.1.5
sinkParserEither :: (AttoparsecInput a, Monad m) => Parser a b -> ConduitT a o m (Either ParseError b)

-- | Consume a stream of parsed tokens, returning both the token and the
--   position it appears at. This function will raise a <a>ParseError</a>
--   on bad input.
--   
--   Since 0.5.0
conduitParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> ConduitT a (PositionRange, b) m ()

-- | Same as <a>conduitParser</a>, but we return an <a>Either</a> type
--   instead of raising an exception.
conduitParserEither :: (Monad m, AttoparsecInput a) => Parser a b -> ConduitT a (Either ParseError (PositionRange, b)) m ()

-- | The context and message from a <a>Fail</a> value.
data ParseError
ParseError :: [String] -> String -> Position -> ParseError
[errorContexts] :: ParseError -> [String]
[errorMessage] :: ParseError -> String
[errorPosition] :: ParseError -> Position
DivergentParser :: ParseError
data Position
Position :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Position
[posLine] :: Position -> {-# UNPACK #-} !Int
[posCol] :: Position -> {-# UNPACK #-} !Int

[posOffset] :: Position -> {-# UNPACK #-} !Int
data PositionRange
PositionRange :: {-# UNPACK #-} !Position -> {-# UNPACK #-} !Position -> PositionRange
[posRangeStart] :: PositionRange -> {-# UNPACK #-} !Position
[posRangeEnd] :: PositionRange -> {-# UNPACK #-} !Position

-- | A class of types which may be consumed by an Attoparsec parser.
class AttoparsecInput a
instance GHC.Classes.Ord Data.Conduit.Attoparsec.Position
instance GHC.Classes.Eq Data.Conduit.Attoparsec.Position
instance GHC.Show.Show Data.Conduit.Attoparsec.ParseError
instance GHC.Classes.Ord Data.Conduit.Attoparsec.PositionRange
instance GHC.Classes.Eq Data.Conduit.Attoparsec.PositionRange
instance Data.Conduit.Attoparsec.AttoparsecInput Data.ByteString.Internal.ByteString
instance Data.Conduit.Attoparsec.AttoparsecInput Data.Text.Internal.Text
instance GHC.Show.Show Data.Conduit.Attoparsec.PositionRange
instance GHC.Exception.Type.Exception Data.Conduit.Attoparsec.ParseError
instance GHC.Show.Show Data.Conduit.Attoparsec.Position


-- | <i>NOTE</i> It is recommended to start using
--   <a>Data.Conduit.Combinators</a> instead of this module.
--   
--   Functions for interacting with bytes.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Binary

-- | Stream the contents of a file as binary data.
sourceFile :: forall (m :: Type -> Type) i. MonadResource m => FilePath -> ConduitT i ByteString m ()

-- | Stream the contents of a <a>Handle</a> as binary data. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes, since it did not acquire the <tt>Handle</tt> in
--   the first place.
sourceHandle :: forall (m :: Type -> Type) i. MonadIO m => Handle -> ConduitT i ByteString m ()

-- | Same as <tt>sourceHandle</tt>, but instead of allocating a new buffer
--   for each incoming chunk of data, reuses the same buffer. Therefore,
--   the <tt>ByteString</tt>s yielded by this function are not
--   referentially transparent between two different <tt>yield</tt>s.
--   
--   This function will be slightly more efficient than
--   <tt>sourceHandle</tt> by avoiding allocations and reducing garbage
--   collections, but should only be used if you can guarantee that you do
--   not reuse a <tt>ByteString</tt> (or any slice thereof) between two
--   calls to <tt>await</tt>.
sourceHandleUnsafe :: forall (m :: Type -> Type) i. MonadIO m => Handle -> ConduitT i ByteString m ()

-- | An alternative to <a>sourceHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in read
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sourceIOHandle :: forall (m :: Type -> Type) i. MonadResource m => IO Handle -> ConduitT i ByteString m ()

-- | Stream the contents of a file as binary data, starting from a certain
--   offset and only consuming up to a certain number of bytes.
--   
--   Since 0.3.0
sourceFileRange :: MonadResource m => FilePath -> Maybe Integer -> Maybe Integer -> ConduitT i ByteString m ()

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   
--   Since 1.0.8
sourceHandleRange :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> ConduitT i ByteString m ()

-- | Stream the contents of a handle as binary data, starting from a
--   certain offset and only consuming up to a certain number of bytes.
--   This function consumes chunks as specified by the buffer size.
--   
--   Since 1.1.8
sourceHandleRangeWithBuffer :: MonadIO m => Handle -> Maybe Integer -> Maybe Integer -> Int -> ConduitT i ByteString m ()

-- | Like <a>withBinaryFile</a>, but provides a source to read bytes from.
withSourceFile :: forall m (n :: Type -> Type) i a. (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM i ByteString n () -> m a) -> m a

-- | Stream all incoming data to the given file.
sinkFile :: forall (m :: Type -> Type) o. MonadResource m => FilePath -> ConduitT ByteString o m ()

-- | Cautious version of <a>sinkFile</a>. The idea here is to stream the
--   values to a temporary file in the same directory of the destination
--   file, and only on successfully writing the entire file, moves it
--   atomically to the destination path.
--   
--   In the event of an exception occurring, the temporary file will be
--   deleted and no move will be made. If the application shuts down
--   without running exception handling (such as machine failure or a
--   SIGKILL), the temporary file will remain and the destination file will
--   be untouched.
sinkFileCautious :: forall (m :: Type -> Type) o. MonadResource m => FilePath -> ConduitM ByteString o m ()

-- | Stream data into a temporary file in the given directory with the
--   given filename pattern, and return the temporary filename. The
--   temporary file will be automatically deleted when exiting the active
--   <tt>ResourceT</tt> block, if it still exists.
sinkTempFile :: forall (m :: Type -> Type) o. MonadResource m => FilePath -> String -> ConduitM ByteString o m FilePath

-- | Same as <a>sinkTempFile</a>, but will use the default temp file
--   directory for the system as the first argument.
sinkSystemTempFile :: forall (m :: Type -> Type) o. MonadResource m => String -> ConduitM ByteString o m FilePath

-- | Stream all incoming data to the given <a>Handle</a>. Note that this
--   function does <i>not</i> flush and will <i>not</i> close the
--   <tt>Handle</tt> when processing completes.
sinkHandle :: forall (m :: Type -> Type) o. MonadIO m => Handle -> ConduitT ByteString o m ()

-- | An alternative to <a>sinkHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in write
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sinkIOHandle :: forall (m :: Type -> Type) o. MonadResource m => IO Handle -> ConduitT ByteString o m ()

-- | Stream incoming builders, executing them directly on the buffer of the
--   given <a>Handle</a>. Note that this function does <i>not</i>
--   automatically close the <tt>Handle</tt> when processing completes.
--   Pass <a>flush</a> to flush the buffer.
sinkHandleBuilder :: forall (m :: Type -> Type) o. MonadIO m => Handle -> ConduitM Builder o m ()

-- | Stream incoming <tt>Flush</tt>es, executing them on <tt>IO.Handle</tt>
--   Note that this function does <i>not</i> automatically close the
--   <tt>Handle</tt> when processing completes
sinkHandleFlush :: forall (m :: Type -> Type) o. MonadIO m => Handle -> ConduitM (Flush ByteString) o m ()

-- | Like <a>withBinaryFile</a>, but provides a sink to write bytes to.
withSinkFile :: forall m (n :: Type -> Type) o a. (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Same as <a>withSinkFile</a>, but lets you use a <a>Builder</a>.
withSinkFileBuilder :: forall m (n :: Type -> Type) o a. (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM Builder o n () -> m a) -> m a

-- | Like <a>sinkFileCautious</a>, but uses the <tt>with</tt> pattern
--   instead of <tt>MonadResource</tt>.
withSinkFileCautious :: forall m (n :: Type -> Type) o a. (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Stream the contents of the input to a file, and also send it along the
--   pipeline. Similar in concept to the Unix command <tt>tee</tt>.
--   
--   Since 0.3.0
conduitFile :: MonadResource m => FilePath -> ConduitT ByteString ByteString m ()

-- | Stream the contents of the input to a <tt>Handle</tt>, and also send
--   it along the pipeline. Similar in concept to the Unix command
--   <tt>tee</tt>. Like <tt>sourceHandle</tt>, does not close the handle on
--   completion. Related to: <tt>conduitFile</tt>.
--   
--   Since 1.0.9
conduitHandle :: MonadIO m => Handle -> ConduitT ByteString ByteString m ()

-- | Stream the chunks from a lazy bytestring.
--   
--   Since 0.5.0
sourceLbs :: Monad m => ByteString -> ConduitT i ByteString m ()

-- | Return the next byte from the stream, if available.
--   
--   Since 0.3.0
head :: Monad m => ConduitT ByteString o m (Maybe Word8)

-- | Ignore all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
dropWhile :: Monad m => (Word8 -> Bool) -> ConduitT ByteString o m ()

-- | Take the given number of bytes, if available.
--   
--   Since 0.3.0
take :: Monad m => Int -> ConduitT ByteString o m ByteString

-- | Drop up to the given number of bytes.
--   
--   Since 0.5.0
drop :: Monad m => Int -> ConduitT ByteString o m ()

-- | Stream the input data into a temp file and count the number of bytes
--   present. When complete, return a new <tt>Source</tt> reading from the
--   temp file together with the length of the input in bytes.
--   
--   All resources will be cleaned up automatically.
--   
--   Since 1.0.5
sinkCacheLength :: (MonadResource m1, MonadResource m2) => ConduitT ByteString o m1 (Word64, ConduitT i ByteString m2 ())

-- | Consume a stream of input into a lazy bytestring. Note that no lazy
--   I/O is performed, but rather all content is read into memory strictly.
--   
--   Since 1.0.5
sinkLbs :: Monad m => ConduitT ByteString o m ByteString

-- | Perform a computation on each <tt>Word8</tt> in a stream.
--   
--   Since 1.0.10
mapM_ :: Monad m => (Word8 -> m ()) -> ConduitT ByteString o m ()

-- | Consume some instance of <tt>Storable</tt> from the incoming byte
--   stream. In the event of insufficient bytes in the stream, returns a
--   <tt>Nothing</tt> and returns all unused input as leftovers.
sinkStorable :: (Monad m, Storable a) => ConduitT ByteString o m (Maybe a)

-- | Same as <a>sinkStorable</a>, but throws a
--   <a>SinkStorableInsufficientBytes</a> exception (via <a>throwM</a>) in
--   the event of insufficient bytes. This can be more efficient to use
--   than <a>sinkStorable</a> as it avoids the need to
--   construct/deconstruct a <tt>Maybe</tt> wrapper in the success case.
sinkStorableEx :: (MonadThrow m, Storable a) => ConduitT ByteString o m a

-- | Ensure that only up to the given number of bytes are consumed by the
--   inner sink. Note that this does <i>not</i> ensure that all of those
--   bytes are in fact consumed.
--   
--   Since 0.3.0
isolate :: Monad m => Int -> ConduitT ByteString ByteString m ()

-- | Return all bytes while the predicate returns <tt>True</tt>.
--   
--   Since 0.3.0
takeWhile :: Monad m => (Word8 -> Bool) -> ConduitT ByteString ByteString m ()

-- | Split the input bytes into lines. In other words, split on the LF byte
--   (10), and strip it from the output.
--   
--   Since 0.3.0
lines :: Monad m => ConduitT ByteString ByteString m ()
instance GHC.Show.Show Data.Conduit.Binary.SinkStorableException
instance GHC.Exception.Type.Exception Data.Conduit.Binary.SinkStorableException


-- | Convert a stream of blaze-builder <tt>Builder</tt>s into a stream of
--   <tt>ByteString</tt>s.
--   
--   Works with both blaze-builder &lt; 0.4's <tt>Builder</tt>s and
--   <a>Builder</a>.
--   
--   Adapted from blaze-builder-enumerator, written by myself and Simon
--   Meier.
--   
--   Note that the functions here can work in any monad built on top of
--   <tt>IO</tt> or <tt>ST</tt>.
--   
--   Since 1.1.7.0
module Data.Conduit.ByteString.Builder

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: forall (m :: Type -> Type). PrimMonad m => ConduitT Builder ByteString m ()

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: forall (m :: Type -> Type). PrimMonad m => ConduitT Builder ByteString m ()

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: forall (m :: Type -> Type). PrimMonad m => BufferAllocStrategy -> ConduitT Builder ByteString m ()

-- | Same as <a>builderToByteString</a>, but input and output are wrapped
--   in <a>Flush</a>.
builderToByteStringFlush :: forall (m :: Type -> Type). PrimMonad m => ConduitT (Flush Builder) (Flush ByteString) m ()

builderToByteStringWithFlush :: forall (m :: Type -> Type). PrimMonad m => BufferAllocStrategy -> ConduitT (Flush Builder) (Flush ByteString) m ()

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO IO Buffer)

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy


-- | <i>NOTE</i> It is recommended to start using
--   <a>Data.Conduit.Combinators</a> instead of this module.
module Data.Conduit.Filesystem

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
sourceDirectory :: forall (m :: Type -> Type) i. MonadResource m => FilePath -> ConduitT i FilePath m ()

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
sourceDirectoryDeep :: forall (m :: Type -> Type) i. MonadResource m => Bool -> FilePath -> ConduitT i FilePath m ()


-- | Adapter module to work with the <a>foldl</a> package.
module Data.Conduit.Foldl

-- | Convert a left fold into a <a>Consumer</a>. This function is intended
--   to be used with <tt>purely</tt> from the <a>foldl</a> package.
sinkFold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> ConduitT a o m b

-- | Convert a monadic left fold into a <a>Consumer</a>. This function is
--   intended to be used with <tt>impurely</tt> from the <a>foldl</a>
--   package.
sinkFoldM :: Monad m => (x -> a -> m x) -> m x -> (x -> m b) -> ConduitT a o m b


-- | Use lazy I/O for consuming the contents of a source. Warning: All
--   normal warnings of lazy I/O apply. In particular, if you are using
--   this with a <tt>ResourceT</tt> transformer, you must force the list to
--   be evaluated before exiting the <tt>ResourceT</tt>.
module Data.Conduit.Lazy

-- | Use lazy I/O to consume all elements from a <tt>Source</tt>.
--   
--   This function relies on <a>monadActive</a> to determine if the
--   underlying monadic state has been closed.
--   
--   Since 0.3.0
lazyConsume :: forall m a. (MonadUnliftIO m, MonadActive m) => Source m a -> m [a]

-- | Determine if some monad is still active. This is intended to prevent
--   usage of a monadic state after it has been closed. This is necessary
--   for such cases as lazy I/O, where an unevaluated thunk may still refer
--   to a closed <tt>ResourceT</tt>.
--   
--   Since 0.3.0
class Monad m => MonadActive m
monadActive :: MonadActive m => m Bool
instance (Control.Monad.IO.Class.MonadIO m, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Data.Conduit.Lazy.MonadActive Data.Functor.Identity.Identity
instance Data.Conduit.Lazy.MonadActive GHC.Types.IO
instance Data.Conduit.Lazy.MonadActive (GHC.ST.ST s)
instance Data.Conduit.Lazy.MonadActive (Control.Monad.ST.Lazy.Imp.ST s)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.List.ListT m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Maybe.MaybeT m)
instance (Control.Monad.Trans.Error.Error e, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Data.Conduit.Lazy.MonadActive m) => Data.Conduit.Lazy.MonadActive (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Data.Conduit.Internal.Pipe.Pipe l i o u m)
instance Data.Conduit.Lazy.MonadActive m => Data.Conduit.Lazy.MonadActive (Data.Conduit.Internal.Conduit.ConduitT i o m)

module Data.Conduit.Network

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> ConduitT i ByteString m ()

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> ConduitT ByteString o m ()

-- | The data passed to an <tt>Application</tt>.
data AppData
appSource :: (HasReadWrite ad, MonadIO m) => ad -> ConduitT i ByteString m ()
appSink :: (HasReadWrite ad, MonadIO m) => ad -> ConduitT ByteString o m ()
appSockAddr :: AppData -> SockAddr
appLocalAddr :: AppData -> Maybe SockAddr

-- | Settings for a TCP server. It takes a port to listen on, and an
--   optional hostname to bind to.
data ServerSettings
serverSettings :: Int -> HostPreference -> ServerSettings

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runTCPServer :: ServerSettings -> (AppData -> IO ()) -> IO a
runTCPServerWithHandle :: ServerSettings -> ConnectionHandle -> IO a

-- | Fork a TCP Server
--   
--   Will fork the runGeneralTCPServer function but will only return from
--   this call when the server is bound to the port and accepting incoming
--   connections. Will return the thread id of the server
--   
--   Since 1.1.4
forkTCPServer :: MonadUnliftIO m => ServerSettings -> (AppData -> m ()) -> m ThreadId

-- | Run a general TCP server
--   
--   Same as <a>runTCPServer</a>, except monad can be any instance of
--   <a>MonadUnliftIO</a>.
--   
--   Note that any changes to the monadic state performed by individual
--   client handlers will be discarded. If you have mutable state you want
--   to share among multiple handlers, you need to use some kind of mutable
--   variables.
--   
--   Since 1.1.3
runGeneralTCPServer :: MonadUnliftIO m => ServerSettings -> (AppData -> m ()) -> m a

-- | Settings for a TCP client, specifying how to connect to the server.
data ClientSettings
clientSettings :: Int -> ByteString -> ClientSettings

-- | Run an <tt>Application</tt> by connecting to the specified server.
runTCPClient :: ClientSettings -> (AppData -> IO a) -> IO a

-- | Run a general TCP client
--   
--   Same as <a>runTCPClient</a>, except monad can be any instance of
--   <a>MonadUnliftIO</a>.
--   
--   Since 1.1.3
runGeneralTCPClient :: MonadUnliftIO m => ClientSettings -> (AppData -> m a) -> m a
getPort :: HasPort a => a -> Int
getHost :: ClientSettings -> ByteString
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
getNeedLocalAddr :: ServerSettings -> Bool
setPort :: HasPort a => Int -> a -> a
setHost :: ByteString -> ClientSettings -> ClientSettings
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a
setNeedLocalAddr :: Bool -> ServerSettings -> ServerSettings

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt> - "any IPv4 or IPv6
--   hostname"</li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt> - "any IPv4 or IPv6 hostname,
--   IPv4 preferred"</li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt> - "any IPv4 hostname"</li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt>@ - "any IPv4 or IPv6 hostname,
--   IPv6 preferred"</li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt> - "any IPv6 hostname"</li>
--   </ul>
--   
--   Note that the permissive <tt>*</tt> values allow binding to an IPv4 or
--   an IPv6 hostname, which means you might be able to successfully bind
--   to a port more times than you expect (eg once on the IPv4 localhost
--   127.0.0.1 and again on the IPv6 localhost 0:0:0:0:0:0:0:1).
--   
--   Any other value is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference

module Data.Conduit.Network.UDP

-- | Representation of a single UDP message
data Message
Message :: {-# UNPACK #-} !ByteString -> !SockAddr -> Message
[msgData] :: Message -> {-# UNPACK #-} !ByteString
[msgSender] :: Message -> !SockAddr

-- | Stream messages from the socket.
--   
--   The given <tt>len</tt> defines the maximum packet size. Every produced
--   item contains the message payload and the origin address.
--   
--   This function does <i>not</i> automatically close the socket.
sourceSocket :: MonadIO m => Socket -> Int -> ConduitT i Message m ()

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>send</tt>, so some of it might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkSocket :: MonadIO m => Socket -> ConduitT ByteString o m ()

-- | Stream messages to the connected socket.
--   
--   The payload is sent using <tt>sendAll</tt>, so it might end up in
--   multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllSocket :: MonadIO m => Socket -> ConduitT ByteString o m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendTo</tt>, so some of it
--   might be lost.
--   
--   This function does <i>not</i> automatically close the socket.
sinkToSocket :: MonadIO m => Socket -> ConduitT Message o m ()

-- | Stream messages to the socket.
--   
--   Every handled item contains the message payload and the destination
--   address. The payload is sent using <tt>sendAllTo</tt>, so it might end
--   up in multiple packets.
--   
--   This function does <i>not</i> automatically close the socket.
sinkAllToSocket :: MonadIO m => Socket -> ConduitT Message o m ()

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt> - "any IPv4 or IPv6
--   hostname"</li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt> - "any IPv4 or IPv6 hostname,
--   IPv4 preferred"</li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt> - "any IPv4 hostname"</li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt>@ - "any IPv4 or IPv6 hostname,
--   IPv6 preferred"</li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt> - "any IPv6 hostname"</li>
--   </ul>
--   
--   Note that the permissive <tt>*</tt> values allow binding to an IPv4 or
--   an IPv6 hostname, which means you might be able to successfully bind
--   to a port more times than you expect (eg once on the IPv4 localhost
--   127.0.0.1 and again on the IPv6 localhost 0:0:0:0:0:0:0:1).
--   
--   Any other value is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference

module Data.Conduit.Network.Unix

-- | Stream data from the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sourceSocket :: MonadIO m => Socket -> ConduitT i ByteString m ()

-- | Stream data to the socket.
--   
--   This function does <i>not</i> automatically close the socket.
--   
--   Since 0.0.0
sinkSocket :: MonadIO m => Socket -> ConduitT ByteString o m ()

-- | The data passed to a Unix domain sockets <tt>Application</tt>.
data AppDataUnix
appSource :: (HasReadWrite ad, MonadIO m) => ad -> ConduitT i ByteString m ()
appSink :: (HasReadWrite ad, MonadIO m) => ad -> ConduitT ByteString o m ()

-- | Settings for a Unix domain sockets server.
data ServerSettingsUnix
serverSettings :: FilePath -> ServerSettingsUnix

-- | Run an <tt>Application</tt> with the given settings. This function
--   will create a new listening socket, accept connections on it, and
--   spawn a new thread for each connection.
runUnixServer :: ServerSettingsUnix -> (AppDataUnix -> IO ()) -> IO a

-- | Settings for a Unix domain sockets client.
data ClientSettingsUnix
clientSettings :: FilePath -> ClientSettingsUnix

-- | Run an <tt>Application</tt> by connecting to the specified server.
runUnixClient :: ClientSettingsUnix -> (AppDataUnix -> IO a) -> IO a
getPath :: HasPath a => a -> FilePath
getAfterBind :: HasAfterBind a => a -> Socket -> IO ()
setPath :: HasPath a => FilePath -> a -> a
setAfterBind :: HasAfterBind a => (Socket -> IO ()) -> a -> a


-- | A full tutorial for this module is available at:
--   <a>https://github.com/snoyberg/conduit/blob/master/PROCESS.md</a>.
--   
--   Note that this is a very thin layer around the
--   <tt>Data.Streaming.Process</tt> module. In particular, it:
--   
--   <ul>
--   <li>Provides orphan instances for conduit</li>
--   <li>Provides some useful helper functions</li>
--   </ul>
module Data.Conduit.Process

-- | Like <tt>sourceProcessWithConsumer</tt> but providing the command to
--   be run as a <tt>String</tt>.
--   
--   Since 1.1.2
sourceCmdWithConsumer :: MonadIO m => String -> ConduitT ByteString Void m a -> m (ExitCode, a)

-- | Given a <tt>CreateProcess</tt>, run the process, with its output being
--   used as a <tt>Source</tt> to feed the provided <tt>Consumer</tt>. Once
--   the process has completed, return a tuple of the <tt>ExitCode</tt>
--   from the process and the output collected from the <tt>Consumer</tt>.
--   
--   Note that, if an exception is raised by the consumer, the process is
--   <i>not</i> terminated. This behavior is different from
--   <a>sourceProcessWithStreams</a> due to historical reasons.
--   
--   Since 1.1.2
sourceProcessWithConsumer :: MonadIO m => CreateProcess -> ConduitT ByteString Void m a -> m (ExitCode, a)

-- | Like <tt>sourceProcessWithStreams</tt> but providing the command to be
--   run as a <tt>String</tt>.
sourceCmdWithStreams :: MonadUnliftIO m => String -> ConduitT () ByteString m () -> ConduitT ByteString Void m a -> ConduitT ByteString Void m b -> m (ExitCode, a, b)

-- | Given a <tt>CreateProcess</tt>, run the process and feed the provided
--   <tt>Producer</tt> to the stdin <tt>Sink</tt> of the process. Use the
--   process outputs (stdout, stderr) as <tt>Source</tt>s and feed it to
--   the provided <tt>Consumer</tt>s. Once the process has completed,
--   return a tuple of the <tt>ExitCode</tt> from the process and the
--   results collected from the <tt>Consumer</tt>s.
--   
--   If an exception is raised by any of the streams, the process is
--   terminated.
--   
--   IO is required because the streams are run concurrently using the
--   <a>async</a> package
sourceProcessWithStreams :: MonadUnliftIO m => CreateProcess -> ConduitT () ByteString m () -> ConduitT ByteString Void m a -> ConduitT ByteString Void m b -> m (ExitCode, a, b)

-- | Same as <a>withCheckedProcess</a>, but kills the child process in the
--   case of an exception being thrown by the provided callback function.
withCheckedProcessCleanup :: (InputSource stdin, OutputSink stderr, OutputSink stdout, MonadUnliftIO m) => CreateProcess -> (stdin -> stdout -> stderr -> m b) -> m b

-- | Wrapper for input source which accepts <tt>Flush</tt>es. Note that the
--   pipe will <i>not</i> automatically close then processing completes.
newtype FlushInput o m r
FlushInput :: ConduitM (Flush ByteString) o m r -> FlushInput o m r

-- | Wrapper for input source which accepts <a>Builder</a>s. You can pass
--   <a>flush</a> to flush the input. Note that the pipe will <i>not</i>
--   automatically close when the processing completes.
newtype BuilderInput o m r
BuilderInput :: ConduitM Builder o m r -> BuilderInput o m r
instance (Control.Monad.IO.Class.MonadIO m, r GHC.Types.~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.FlushInput o m r)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, r GHC.Types.~ (), r' GHC.Types.~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.FlushInput o m r, n r')
instance (Control.Monad.IO.Class.MonadIO m, r GHC.Types.~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.BuilderInput o m r)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, r GHC.Types.~ (), r' GHC.Types.~ ()) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Process.BuilderInput o m r, n r')
instance (r GHC.Types.~ (), Control.Monad.IO.Class.MonadIO m, i GHC.Types.~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Internal.Conduit.ConduitM i o m r)
instance (r GHC.Types.~ (), r' GHC.Types.~ (), Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, i GHC.Types.~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.InputSource (Data.Conduit.Internal.Conduit.ConduitM i o m r, n r')
instance (r GHC.Types.~ (), Control.Monad.IO.Class.MonadIO m, o GHC.Types.~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.OutputSink (Data.Conduit.Internal.Conduit.ConduitM i o m r)
instance (r GHC.Types.~ (), r' GHC.Types.~ (), Control.Monad.IO.Class.MonadIO m, Control.Monad.IO.Class.MonadIO n, o GHC.Types.~ Data.ByteString.Internal.ByteString) => Data.Streaming.Process.Internal.OutputSink (Data.Conduit.Internal.Conduit.ConduitM i o m r, n r')


-- | The <a>System.Process.Typed</a> module from <tt>typed-process</tt>,
--   but with added conduit helpers.
module Data.Conduit.Process.Typed

-- | Provide input to a process by writing to a conduit. The sink provided
--   here will leave the pipe to the child open after the stream ends. This
--   allows the sink to be used multiple times, but may result in
--   surprising behavior. You may prefer <a>createSinkClose</a>, see
--   <a>https://github.com/snoyberg/conduit/issues/434</a>.
createSink :: MonadIO m => StreamSpec 'STInput (ConduitM ByteString o m ())

-- | Like <a>createSink</a>, but closes the pipe to the child process as
--   soon as it runs out of data.
createSinkClose :: MonadIO m => StreamSpec 'STInput (ConduitM ByteString o m ())

-- | Read output from a process by read from a conduit.
createSource :: MonadIO m => StreamSpec 'STOutput (ConduitM i ByteString m ())

-- | Run a process, throwing an exception on a failure exit code. This will
--   store all output from stdout and stderr in memory for better error
--   messages. Note that this will require unbounded memory usage, so
--   caveat emptor.
--   
--   This will ignore any previous settings for the stdout and stderr
--   streams, and instead force them to use <a>createSource</a>.
withLoggedProcess_ :: MonadUnliftIO m => ProcessConfig stdin stdoutIgnored stderrIgnored -> (Process stdin (ConduitM () ByteString m ()) (ConduitM () ByteString m ()) -> m a) -> m a


-- | <i>NOTE</i> It is recommended to start using
--   <a>Data.Conduit.Combinators</a> instead of this module.
--   
--   Copyright: 2011 Michael Snoyman, 2010-2011 John Millikin License: MIT
--   
--   Handle streams of text.
--   
--   Parts of this code were taken from enumerator and adapted for
--   conduits.
--   
--   For many purposes, it's recommended to use the conduit-combinators
--   library, which provides a more complete set of functions.
module Data.Conduit.Text

-- | A specific character encoding.
--   
--   Since 0.3.0
data Codec

-- | Convert text into bytes, using the provided codec. If the codec is not
--   capable of representing an input character, an exception will be
--   thrown.
--   
--   Since 0.3.0
encode :: MonadThrow m => Codec -> ConduitT Text ByteString m ()

-- | Convert bytes into text, using the provided codec. If the codec is not
--   capable of decoding an input byte sequence, an exception will be
--   thrown.
--   
--   Since 0.3.0
decode :: MonadThrow m => Codec -> ConduitT ByteString Text m ()

-- | Since 0.3.0
utf8 :: Codec

-- | Since 0.3.0
utf16_le :: Codec

-- | Since 0.3.0
utf16_be :: Codec

-- | Since 0.3.0
utf32_le :: Codec

-- | Since 0.3.0
utf32_be :: Codec

-- | Since 0.3.0
ascii :: Codec

-- | Since 0.3.0
iso8859_1 :: Codec

-- | Emit each line separately
--   
--   Since 0.4.1
lines :: Monad m => ConduitT Text Text m ()

-- | Variant of the lines function with an integer parameter. The text
--   length of any emitted line never exceeds the value of the parameter.
--   Whenever this is about to happen a LengthExceeded exception is thrown.
--   This function should be used instead of the lines function whenever we
--   are dealing with user input (e.g. a file upload) because we can't be
--   sure that user input won't have extraordinarily large lines which
--   would require large amounts of memory if consumed.
linesBounded :: MonadThrow m => Int -> ConduitT Text Text m ()

-- | Since 0.3.0
data TextException
DecodeException :: Codec -> Word8 -> TextException
EncodeException :: Codec -> Char -> TextException
LengthExceeded :: Int -> TextException
TextException :: SomeException -> TextException
NewDecodeException :: !Text -> !Int -> !ByteString -> TextException

-- | Since 1.0.8
takeWhile :: Monad m => (Char -> Bool) -> ConduitT Text Text m ()

-- | Since 1.0.8
dropWhile :: Monad m => (Char -> Bool) -> ConduitT Text o m ()

-- | Since 1.0.8
take :: Monad m => Int -> ConduitT Text Text m ()

-- | Since 1.0.8
drop :: Monad m => Int -> ConduitT Text o m ()

-- | Since 1.0.8
foldLines :: Monad m => (a -> ConduitM Text o m a) -> a -> ConduitT Text o m a

-- | Since 1.0.8
withLine :: Monad m => ConduitT Text Void m a -> ConduitT Text o m (Maybe a)

-- | Decode a stream of binary data as UTF8.
decodeUtf8 :: forall (m :: Type -> Type). MonadThrow m => ConduitT ByteString Text m ()

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes
--   with the Unicode replacement character.
decodeUtf8Lenient :: forall (m :: Type -> Type). Monad m => ConduitT ByteString Text m ()

-- | Encode a stream of text as UTF8.
--   
--   Subject to fusion
encodeUtf8 :: forall (m :: Type -> Type) text binary. (Monad m, Utf8 text binary) => ConduitT text binary m ()

-- | Automatically determine which UTF variant is being used. This function
--   checks for BOMs, removing them as necessary. It defaults to assuming
--   UTF-8.
--   
--   Since 1.1.9
detectUtf :: MonadThrow m => ConduitT ByteString Text m ()
instance GHC.Show.Show Data.Conduit.Text.Codec
instance GHC.Show.Show Data.Conduit.Text.TextException
instance GHC.Exception.Type.Exception Data.Conduit.Text.TextException


-- | Streaming compression and decompression using conduits.
--   
--   Parts of this code were taken from zlib-enum and adapted for conduits.
module Data.Conduit.Zlib

-- | Compress (deflate) a stream of <a>ByteString</a>s. The
--   <a>WindowBits</a> also control the format (zlib vs. gzip).
compress :: (PrimMonad m, MonadThrow m) => Int -> WindowBits -> ConduitT ByteString ByteString m ()

-- | Decompress (inflate) a stream of <a>ByteString</a>s. For example:
--   
--   <pre>
--   sourceFile "test.z" $= decompress defaultWindowBits $$ sinkFile "test"
--   </pre>
decompress :: (PrimMonad m, MonadThrow m) => WindowBits -> ConduitT ByteString ByteString m ()

-- | Gzip compression with default parameters.
gzip :: (MonadThrow m, PrimMonad m) => ConduitT ByteString ByteString m ()

-- | Gzip decompression with default parameters.
ungzip :: (PrimMonad m, MonadThrow m) => ConduitT ByteString ByteString m ()

-- | Same as <a>compress</a>, but allows you to explicitly flush the
--   stream.
compressFlush :: (PrimMonad m, MonadThrow m) => Int -> WindowBits -> ConduitT (Flush ByteString) (Flush ByteString) m ()

-- | Same as <a>decompress</a>, but allows you to explicitly flush the
--   stream.
decompressFlush :: (PrimMonad m, MonadThrow m) => WindowBits -> ConduitT (Flush ByteString) (Flush ByteString) m ()

-- | The standard <a>decompress</a> and <a>ungzip</a> functions will only
--   decompress a single compressed entity from the stream. This combinator
--   will exhaust the stream completely of all individual compressed
--   entities. This is useful for cases where you have a concatenated
--   archive, e.g. <tt>cat file1.gz file2.gz &gt; combined.gz</tt>.
--   
--   Usage:
--   
--   <pre>
--   sourceFile "combined.gz" $$ multiple ungzip =$ consume
--   </pre>
--   
--   This combinator will not fail on an empty stream. If you want to
--   ensure that at least one compressed entity in the stream exists,
--   consider a usage such as:
--   
--   <pre>
--   sourceFile "combined.gz" $$ (ungzip &gt;&gt; multiple ungzip) =$ consume
--   </pre>
multiple :: Monad m => ConduitT ByteString a m () -> ConduitT ByteString a m ()

-- | This specifies the size of the compression window. Larger values of
--   this parameter result in better compression at the expense of higher
--   memory usage.
--   
--   The compression window size is the value of the the window bits raised
--   to the power 2. The window bits must be in the range <tt>9..15</tt>
--   which corresponds to compression window sizes of 512b to 32Kb. The
--   default is 15 which is also the maximum size.
--   
--   The total amount of memory used depends on the window bits and the
--   <a>MemoryLevel</a>. See the <a>MemoryLevel</a> for the details.
data WindowBits
WindowBits :: Int -> WindowBits

-- | The default <a>WindowBits</a> is 15 which is also the maximum size.
defaultWindowBits :: WindowBits
