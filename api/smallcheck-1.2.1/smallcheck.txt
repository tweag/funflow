-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A property-based testing library
--   
--   SmallCheck is a testing library that allows to verify properties for
--   all test cases up to some depth. The test cases are generated
--   automatically by SmallCheck.
@package smallcheck
@version 1.2.1


-- | You need this module if you want to generate test values of your own
--   types.
--   
--   You'll typically need the following extensions:
--   
--   <pre>
--   {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
--   </pre>
--   
--   SmallCheck itself defines data generators for all the data types used
--   by the <a>Prelude</a>.
--   
--   In order to generate values and functions of your own types, you need
--   to make them instances of <a>Serial</a> (for values) and
--   <a>CoSerial</a> (for functions). There are two main ways to do so:
--   using Generics or writing the instances by hand.
module Test.SmallCheck.Series
cons0 :: a -> Series m a
cons1 :: Serial m a => (a -> b) -> Series m b
cons2 :: (Serial m a, Serial m b) => (a -> b -> c) -> Series m c
cons3 :: (Serial m a, Serial m b, Serial m c) => (a -> b -> c -> d) -> Series m d
cons4 :: (Serial m a, Serial m b, Serial m c, Serial m d) => (a -> b -> c -> d -> e) -> Series m e
cons5 :: (Serial m a, Serial m b, Serial m c, Serial m d, Serial m e) => (a -> b -> c -> d -> e -> f) -> Series m f
cons6 :: (Serial m a, Serial m b, Serial m c, Serial m d, Serial m e, Serial m f) => (a -> b -> c -> d -> e -> f -> g) -> Series m g

-- | Same as <a>cons1</a>, but preserves the depth.
newtypeCons :: Serial m a => (a -> b) -> Series m b
alts0 :: Series m a -> Series m a
alts1 :: CoSerial m a => Series m b -> Series m (a -> b)
alts2 :: (CoSerial m a, CoSerial m b) => Series m c -> Series m (a -> b -> c)
alts3 :: (CoSerial m a, CoSerial m b, CoSerial m c) => Series m d -> Series m (a -> b -> c -> d)
alts4 :: (CoSerial m a, CoSerial m b, CoSerial m c, CoSerial m d) => Series m e -> Series m (a -> b -> c -> d -> e)
alts5 :: (CoSerial m a, CoSerial m b, CoSerial m c, CoSerial m d, CoSerial m e) => Series m f -> Series m (a -> b -> c -> d -> e -> f)
alts6 :: (CoSerial m a, CoSerial m b, CoSerial m c, CoSerial m d, CoSerial m e, CoSerial m f) => Series m g -> Series m (a -> b -> c -> d -> e -> f -> g)

-- | Same as <a>alts1</a>, but preserves the depth.
newtypeAlts :: CoSerial m a => Series m b -> Series m (a -> b)

-- | Maximum depth of generated test values.
--   
--   For data values, it is the depth of nested constructor applications.
--   
--   For functional values, it is both the depth of nested case analysis
--   and the depth of results.
type Depth = Int

-- | <a>Series</a> is a <a>MonadLogic</a> action that enumerates values of
--   a certain type, up to some depth.
--   
--   The depth bound is tracked in the <a>Series</a> monad and can be
--   extracted using <a>getDepth</a> and changed using <a>localDepth</a>.
--   
--   To manipulate series at the lowest level you can use its <a>Monad</a>,
--   <a>MonadPlus</a> and <a>MonadLogic</a> instances. This module provides
--   some higher-level combinators which simplify creating series.
--   
--   A proper <a>Series</a> should be monotonic with respect to the depth â€”
--   i.e. <a>localDepth</a> <tt>(+1)</tt> <tt>s</tt> should emit all the
--   values that <tt>s</tt> emits (and possibly some more).
--   
--   It is also desirable that values of smaller depth come before the
--   values of greater depth.
data Series m a
class Monad m => Serial m a
series :: Serial m a => Series m a
series :: (Serial m a, Generic a, GSerial m (Rep a)) => Series m a
class Monad m => CoSerial m a

-- | A proper <a>coseries</a> implementation should pass the depth
--   unchanged to its first argument. Doing otherwise will make enumeration
--   of curried functions non-uniform in their arguments.
coseries :: CoSerial m a => Series m b -> Series m (a -> b)

-- | A proper <a>coseries</a> implementation should pass the depth
--   unchanged to its first argument. Doing otherwise will make enumeration
--   of curried functions non-uniform in their arguments.
coseries :: (CoSerial m a, Generic a, GCoSerial m (Rep a)) => Series m b -> Series m (a -> b)
genericSeries :: (Monad m, Generic a, GSerial m (Rep a)) => Series m a
genericCoseries :: (Monad m, Generic a, GCoSerial m (Rep a)) => Series m b -> Series m (a -> b)

-- | <a>Positive</a> <tt>x</tt> guarantees that &lt;math&gt;.
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a

-- | <a>NonNegative</a> <tt>x</tt> guarantees that &lt;math&gt;.
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a

-- | <a>NonZero</a> <tt>x</tt> guarantees that &lt;math&gt;.
newtype NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a

-- | <a>NonEmpty</a> <tt>xs</tt> guarantees that <tt>xs</tt> is not null.
newtype NonEmpty a
NonEmpty :: [a] -> NonEmpty a
[getNonEmpty] :: NonEmpty a -> [a]

-- | Sum (union) of series.
(\/) :: Monad m => Series m a -> Series m a -> Series m a
infixr 7 \/

-- | Product of series
(><) :: Monad m => Series m a -> Series m b -> Series m (a, b)
infixr 8 ><

-- | Fair version of <a>ap</a> and <a>&lt;*&gt;</a>.
(<~>) :: Monad m => Series m (a -> b) -> Series m a -> Series m b
infixl 4 <~>

-- | <b>Fair conjunction.</b> Similarly to the previous function, consider
--   the distributivity law, naturally expected from <a>MonadPlus</a>:
--   
--   <pre>
--   (a &lt;|&gt; b) &gt;&gt;= k = (a &gt;&gt;= k) &lt;|&gt; (b &gt;&gt;= k)
--   </pre>
--   
--   If <tt>a</tt> <a>&gt;&gt;=</a> <tt>k</tt> can backtrack arbitrarily
--   many times, <tt>b</tt> <a>&gt;&gt;=</a> <tt>k</tt> may never be
--   considered. In logic statements, "backtracking" is the process of
--   discarding the current possible solution value and returning to a
--   previous decision point where a new value can be obtained and tried.
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; do { x &lt;- pure 0 &lt;|&gt; pure 1 &lt;|&gt; pure 2; if even x then pure x else empty } :: [Int]
--   [0,2]
--   </pre>
--   
--   Here, the <tt>x</tt> value can be produced three times, where
--   <a>&lt;|&gt;</a> represents the decision points of that production.
--   The subsequent <tt>if</tt> statement specifies <a>empty</a> (fail) if
--   <tt>x</tt> is odd, causing it to be discarded and a return to an
--   <a>&lt;|&gt;</a> decision point to get the next <tt>x</tt>.
--   
--   The statement "<tt>a</tt> <a>&gt;&gt;=</a> <tt>k</tt> can backtrack
--   arbitrarily many times" means that the computation is resulting in
--   <a>empty</a> and that <tt>a</tt> has an infinite number of
--   <a>&lt;|&gt;</a> applications to return to. This is called a
--   conjunctive computation because the logic for <tt>a</tt> <i>and</i>
--   <tt>k</tt> must both succeed (i.e. <a>pure</a> a value instead of
--   <a>empty</a>).
--   
--   Similar to the way <a>interleave</a> allows both branches of a
--   disjunctive computation, the <a>&gt;&gt;-</a> operator takes care to
--   consider both branches of a conjunctive computation.
--   
--   Consider the operation:
--   
--   <pre>
--   odds = pure 1 &lt;|&gt; fmap (2 +) odds
--   
--   oddsPlus n = odds &gt;&gt;= \a -&gt; pure (a + n)
--   
--   g = do x &lt;- (pure 0 &lt;|&gt; pure 1) &gt;&gt;= oddsPlus
--          if even x then pure x else empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; observeMany 3 g
--   ...never completes...
--   </pre>
--   
--   This will never produce any value because all values produced by the
--   <tt>do</tt> program come from the <a>pure</a> <tt>1</tt> driven
--   operation (adding one to the sequence of odd values, resulting in the
--   even values that are allowed by the test in the second line), but the
--   <a>pure</a> <tt>0</tt> input to <tt>oddsPlus</tt> generates an
--   infinite number of <a>empty</a> failures so the even values generated
--   by the <a>pure</a> <tt>1</tt> alternative are never seen. Using
--   <a>interleave</a> here instead of <a>&lt;|&gt;</a> does not help due
--   to the aforementioned distributivity law.
--   
--   Also note that the <tt>do</tt> notation desugars to <a>&gt;&gt;=</a>
--   bind operations, so the following would also fail:
--   
--   <pre>
--   do a &lt;- pure 0 &lt;|&gt; pure 1
--      x &lt;- oddsPlus a
--      if even x then pure x else empty
--   </pre>
--   
--   The solution is to use the <a>&gt;&gt;-</a> in place of the normal
--   monadic bind operation <a>&gt;&gt;=</a> when fairness between
--   alternative productions is needed in a conjunction of statements
--   (rules):
--   
--   <pre>
--   h = do x &lt;- (pure 0 &lt;|&gt; pure 1) &gt;&gt;- oddsPlus
--          if even x then pure x else empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; observeMany 3 h
--   [2,4,6]
--   </pre>
--   
--   However, a bit of care is needed when using <a>&gt;&gt;-</a> because,
--   unlike <a>&gt;&gt;=</a>, it is not associative. For example:
--   
--   <pre>
--   &gt;&gt;&gt; let m = [2,7] :: [Int]
--   
--   &gt;&gt;&gt; let k x = [x, x + 1]
--   
--   &gt;&gt;&gt; let h x = [x, x * 2]
--   
--   &gt;&gt;&gt; m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
--   [2,4,3,6,7,14,8,16]
--   
--   &gt;&gt;&gt; (m &gt;&gt;= k) &gt;&gt;= h -- same as above
--   [2,4,3,6,7,14,8,16]
--   
--   &gt;&gt;&gt; m &gt;&gt;- (\x -&gt; k x &gt;&gt;- h)
--   [2,7,3,8,4,14,6,16]
--   
--   &gt;&gt;&gt; (m &gt;&gt;- k) &gt;&gt;- h -- central elements are different
--   [2,7,4,3,14,8,6,16]
--   </pre>
--   
--   This means that the following will be productive:
--   
--   <pre>
--   (pure 0 &lt;|&gt; pure 1) &gt;&gt;-
--     oddsPlus &gt;&gt;-
--       \x -&gt; if even x then pure x else empty
--   </pre>
--   
--   Which is equivalent to
--   
--   <pre>
--   ((pure 0 &lt;|&gt; pure 1) &gt;&gt;- oddsPlus) &gt;&gt;-
--     (\x -&gt; if even x then pure x else empty)
--   </pre>
--   
--   But the following will <i>not</i> be productive:
--   
--   <pre>
--   (pure 0 &lt;|&gt; pure 1) &gt;&gt;-
--     (\a -&gt; (oddsPlus a &gt;&gt;- \x -&gt; if even x then pure x else empty))
--   </pre>
--   
--   Since do notation desugaring results in the latter, the
--   <tt>RebindableSyntax</tt> language pragma cannot easily be used
--   either. Instead, it is recommended to carefully use explicit
--   <a>&gt;&gt;-</a> only when needed.
(>>-) :: MonadLogic m => m a -> (a -> m b) -> m b
infixl 1 >>-

-- | Run a series with a modified depth.
localDepth :: (Depth -> Depth) -> Series m a -> Series m a

-- | Run a <a>Series</a> with the depth decreased by 1.
--   
--   If the current depth is less or equal to 0, the result is
--   <a>empty</a>.
decDepth :: Series m a -> Series m a

-- | Query the current depth.
getDepth :: Series m Depth

-- | A simple series specified by a function from depth to the list of
--   values up to that depth.
generate :: (Depth -> [a]) -> Series m a

-- | Limit a <a>Series</a> to its first <tt>n</tt> elements.
limit :: forall m a. Monad m => Int -> Series m a -> Series m a

-- | Given a depth, return the list of values generated by a <a>Serial</a>
--   instance.
--   
--   For example, list all integers up to depth 1:
--   
--   <ul>
--   <li><pre>listSeries 1 :: [Int] -- returns [0,1,-1]</pre></li>
--   </ul>
listSeries :: Serial Identity a => Depth -> [a]

-- | Return the list of values generated by a <a>Series</a>. Useful for
--   debugging <a>Serial</a> instances.
--   
--   Examples:
--   
--   <ul>
--   <li><pre><a>list</a> 3 <a>series</a> :: [<a>Int</a>] -- returns
--   [0,1,-1,2,-2,3,-3]</pre></li>
--   <li><pre><a>list</a> 3 (<a>series</a> :: <a>Series</a> <a>Identity</a>
--   <a>Int</a>) -- returns [0,1,-1,2,-2,3,-3]</pre></li>
--   <li><pre><a>list</a> 2 <a>series</a> :: [[<a>Bool</a>]] -- returns
--   [[],[<a>True</a>],[<a>False</a>]]</pre></li>
--   </ul>
--   
--   The first two are equivalent. The second has a more explicit type
--   binding.
list :: Depth -> Series Identity a -> [a]

-- | Monadic version of <a>list</a>.
listM :: Applicative m => Depth -> Series m a -> m [a]

-- | Fix the depth of a series at the current level. The resulting series
--   will no longer depend on the "ambient" depth.
fixDepth :: Series m a -> Series m (Series m a)

-- | If the current depth is 0, evaluate the first argument. Otherwise,
--   evaluate the second argument with decremented depth.
decDepthChecked :: Series m a -> Series m a -> Series m a

-- | <pre>
--   <a>constM</a> = <a>liftM</a> <a>const</a>
--   </pre>
constM :: Monad m => m b -> m (a -> b)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.N a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.SmallCheck.Series.N a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.SmallCheck.Series.N a)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.M a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.SmallCheck.Series.M a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.SmallCheck.Series.M a)
instance Data.Traversable.Traversable Test.SmallCheck.Series.Positive
instance Data.Foldable.Foldable Test.SmallCheck.Series.Positive
instance GHC.Base.Functor Test.SmallCheck.Series.Positive
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.SmallCheck.Series.Positive a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.SmallCheck.Series.Positive a)
instance Data.Traversable.Traversable Test.SmallCheck.Series.NonNegative
instance Data.Foldable.Foldable Test.SmallCheck.Series.NonNegative
instance GHC.Base.Functor Test.SmallCheck.Series.NonNegative
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.SmallCheck.Series.NonNegative a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.SmallCheck.Series.NonNegative a)
instance Data.Traversable.Traversable Test.SmallCheck.Series.NonZero
instance Data.Foldable.Foldable Test.SmallCheck.Series.NonZero
instance GHC.Base.Functor Test.SmallCheck.Series.NonZero
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.SmallCheck.Series.NonZero a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.SmallCheck.Series.NonZero a)
instance Test.SmallCheck.Series.Serial m a => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.NonEmpty a)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.NonEmpty a)
instance GHC.Real.Real a => GHC.Real.Real (Test.SmallCheck.Series.NonZero a)
instance (GHC.Classes.Eq a, GHC.Num.Num a, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Test.SmallCheck.Series.NonZero a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.SmallCheck.Series.NonZero a)
instance GHC.Num.Num a => GHC.Num.Num (Test.SmallCheck.Series.NonZero a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.SmallCheck.Series.NonZero a)
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.SmallCheck.Series.Serial m a) => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.NonZero a)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.NonZero a)
instance GHC.Real.Real a => GHC.Real.Real (Test.SmallCheck.Series.NonNegative a)
instance (GHC.Num.Num a, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Test.SmallCheck.Series.NonNegative a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.SmallCheck.Series.NonNegative a)
instance GHC.Num.Num a => GHC.Num.Num (Test.SmallCheck.Series.NonNegative a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.SmallCheck.Series.NonNegative a)
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.SmallCheck.Series.Serial m a) => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.NonNegative a)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.NonNegative a)
instance (GHC.Real.Integral i, Test.SmallCheck.Series.Serial m i) => Test.SmallCheck.Series.Serial m (GHC.Real.Ratio i)
instance GHC.Real.Real a => GHC.Real.Real (Test.SmallCheck.Series.Positive a)
instance (GHC.Num.Num a, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Test.SmallCheck.Series.Positive a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.SmallCheck.Series.Positive a)
instance GHC.Num.Num a => GHC.Num.Num (Test.SmallCheck.Series.Positive a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.SmallCheck.Series.Positive a)
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.SmallCheck.Series.Serial m a) => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.Positive a)
instance GHC.Show.Show a => GHC.Show.Show (Test.SmallCheck.Series.Positive a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Int
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Int
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Int.Int8
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Int.Int8
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Int.Int16
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Int.Int16
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Int.Int32
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Int.Int32
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Int.Int64
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Int.Int64
instance GHC.Real.Real a => GHC.Real.Real (Test.SmallCheck.Series.M a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.SmallCheck.Series.M a)
instance GHC.Num.Num a => GHC.Num.Num (Test.SmallCheck.Series.M a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.SmallCheck.Series.M a)
instance (GHC.Num.Num a, GHC.Enum.Enum a, GHC.Base.Monad m) => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.M a)
instance (GHC.Classes.Ord a, GHC.Num.Num a, GHC.Base.Monad m) => Test.SmallCheck.Series.CoSerial m (Test.SmallCheck.Series.M a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Natural.Natural
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Natural.Natural
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Word
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Word
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Word.Word8
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Word.Word8
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Word.Word16
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Word.Word16
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Word.Word32
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Word.Word32
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Word.Word64
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Word.Word64
instance GHC.Real.Real a => GHC.Real.Real (Test.SmallCheck.Series.N a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.SmallCheck.Series.N a)
instance GHC.Num.Num a => GHC.Num.Num (Test.SmallCheck.Series.N a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.SmallCheck.Series.N a)
instance (GHC.Num.Num a, GHC.Enum.Enum a, Test.SmallCheck.Series.Serial m a) => Test.SmallCheck.Series.Serial m (Test.SmallCheck.Series.N a)
instance (GHC.Real.Integral a, GHC.Base.Monad m) => Test.SmallCheck.Series.CoSerial m (Test.SmallCheck.Series.N a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Char
instance Test.SmallCheck.Series.CoSerial m c => Test.SmallCheck.Series.GCoSerial m (GHC.Generics.K1 i c)
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m ()
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Float
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Double
instance (GHC.Real.Integral i, Test.SmallCheck.Series.CoSerial m i) => Test.SmallCheck.Series.CoSerial m (GHC.Real.Ratio i)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b) => Test.SmallCheck.Series.CoSerial m (a, b)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b, Test.SmallCheck.Series.CoSerial m c) => Test.SmallCheck.Series.CoSerial m (a, b, c)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b, Test.SmallCheck.Series.CoSerial m c, Test.SmallCheck.Series.CoSerial m d) => Test.SmallCheck.Series.CoSerial m (a, b, c, d)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b, Test.SmallCheck.Series.CoSerial m c, Test.SmallCheck.Series.CoSerial m d, Test.SmallCheck.Series.CoSerial m e) => Test.SmallCheck.Series.CoSerial m (a, b, c, d, e)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b, Test.SmallCheck.Series.CoSerial m c, Test.SmallCheck.Series.CoSerial m d, Test.SmallCheck.Series.CoSerial m e, Test.SmallCheck.Series.CoSerial m f) => Test.SmallCheck.Series.CoSerial m (a, b, c, d, e, f)
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Bool
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m GHC.Types.Ordering
instance Test.SmallCheck.Series.CoSerial m a => Test.SmallCheck.Series.CoSerial m (GHC.Maybe.Maybe a)
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.CoSerial m b) => Test.SmallCheck.Series.CoSerial m (Data.Either.Either a b)
instance Test.SmallCheck.Series.CoSerial m a => Test.SmallCheck.Series.CoSerial m [a]
instance Test.SmallCheck.Series.CoSerial m a => Test.SmallCheck.Series.CoSerial m (GHC.Base.NonEmpty a)
instance Test.SmallCheck.Series.CoSerial m a => Test.SmallCheck.Series.CoSerial m (Data.Complex.Complex a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Data.Void.Void
instance (Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.Serial m b) => Test.SmallCheck.Series.Serial m (a -> b)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.CoSerial m a, Test.SmallCheck.Series.Serial m b, Test.SmallCheck.Series.CoSerial m b) => Test.SmallCheck.Series.CoSerial m (a -> b)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m (f (g a))) => Test.SmallCheck.Series.CoSerial m (Data.Functor.Compose.Compose f g a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CFloat
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CDouble
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CBool
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CSChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CShort
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUShort
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CInt
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUInt
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CULong
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CPtrdiff
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CSize
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CWchar
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CSigAtomic
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CLLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CULLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CIntPtr
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUIntPtr
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CIntMax
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUIntMax
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CClock
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CTime
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CUSeconds
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Foreign.C.Types.CSUSeconds
instance Test.SmallCheck.Series.GCoSerial m f => Test.SmallCheck.Series.GCoSerial m (GHC.Generics.M1 i c f)
instance Test.SmallCheck.Series.GCoSerial m GHC.Generics.U1
instance Test.SmallCheck.Series.GCoSerial m GHC.Generics.V1
instance (GHC.Base.Monad m, Test.SmallCheck.Series.GCoSerial m a, Test.SmallCheck.Series.GCoSerial m b) => Test.SmallCheck.Series.GCoSerial m (a GHC.Generics.:*: b)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.GCoSerial m a, Test.SmallCheck.Series.GCoSerial m b) => Test.SmallCheck.Series.GCoSerial m (a GHC.Generics.:+: b)
instance Test.SmallCheck.Series.Serial m c => Test.SmallCheck.Series.GSerial m (GHC.Generics.K1 i c)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m ()
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Float
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Double
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Char
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b) => Test.SmallCheck.Series.Serial m (a, b)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b, Test.SmallCheck.Series.Serial m c) => Test.SmallCheck.Series.Serial m (a, b, c)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b, Test.SmallCheck.Series.Serial m c, Test.SmallCheck.Series.Serial m d) => Test.SmallCheck.Series.Serial m (a, b, c, d)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b, Test.SmallCheck.Series.Serial m c, Test.SmallCheck.Series.Serial m d, Test.SmallCheck.Series.Serial m e) => Test.SmallCheck.Series.Serial m (a, b, c, d, e)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b, Test.SmallCheck.Series.Serial m c, Test.SmallCheck.Series.Serial m d, Test.SmallCheck.Series.Serial m e, Test.SmallCheck.Series.Serial m f) => Test.SmallCheck.Series.Serial m (a, b, c, d, e, f)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Bool
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m GHC.Types.Ordering
instance Test.SmallCheck.Series.Serial m a => Test.SmallCheck.Series.Serial m (GHC.Maybe.Maybe a)
instance (Test.SmallCheck.Series.Serial m a, Test.SmallCheck.Series.Serial m b) => Test.SmallCheck.Series.Serial m (Data.Either.Either a b)
instance Test.SmallCheck.Series.Serial m a => Test.SmallCheck.Series.Serial m [a]
instance Test.SmallCheck.Series.Serial m a => Test.SmallCheck.Series.Serial m (GHC.Base.NonEmpty a)
instance Test.SmallCheck.Series.Serial m a => Test.SmallCheck.Series.Serial m (Data.Complex.Complex a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Data.Void.Void
instance (Test.SmallCheck.Series.Serial Data.Functor.Identity.Identity a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a -> b)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m (f (g a))) => Test.SmallCheck.Series.Serial m (Data.Functor.Compose.Compose f g a)
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CFloat
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CDouble
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CBool
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CSChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUChar
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CShort
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUShort
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CInt
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUInt
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CULong
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CPtrdiff
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CSize
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CWchar
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CSigAtomic
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CLLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CULLong
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CIntPtr
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUIntPtr
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CIntMax
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUIntMax
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CClock
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CTime
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CUSeconds
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Foreign.C.Types.CSUSeconds
instance Test.SmallCheck.Series.GSerial m f => Test.SmallCheck.Series.GSerial m (GHC.Generics.M1 i c f)
instance Test.SmallCheck.Series.GSerial m GHC.Generics.U1
instance Test.SmallCheck.Series.GSerial m GHC.Generics.V1
instance (GHC.Base.Monad m, Test.SmallCheck.Series.GSerial m a, Test.SmallCheck.Series.GSerial m b) => Test.SmallCheck.Series.GSerial m (a GHC.Generics.:*: b)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.GSerial m a, Test.SmallCheck.Series.GSerial m b) => Test.SmallCheck.Series.GSerial m (a GHC.Generics.:+: b)
instance Test.SmallCheck.Series.GSerial m f => Test.SmallCheck.Series.GSerial m (GHC.Generics.C1 c f)


-- | You should only need this module if you wish to create your own way to
--   run SmallCheck tests
module Test.SmallCheck.Drivers

-- | A simple driver that runs the test in the <a>IO</a> monad and prints
--   the results.
smallCheck :: Testable IO a => Depth -> a -> IO ()

-- | Use this if:
--   
--   <ul>
--   <li>You need to run a test in a monad different from <a>IO</a></li>
--   <li>You need to analyse the results rather than just print them</li>
--   </ul>
smallCheckM :: Testable m a => Depth -> a -> m (Maybe PropertyFailure)

-- | Like <a>smallCheckM</a>, but allows to specify a monadic hook that
--   gets executed after each test is run.
--   
--   Useful for applications that want to report progress information to
--   the user.
smallCheckWithHook :: Testable m a => Depth -> (TestQuality -> m ()) -> a -> m (Maybe PropertyFailure)
test :: Testable m a => a -> Property m
ppFailure :: PropertyFailure -> String
data PropertyFailure
NotExist :: PropertyFailure
AtLeastTwo :: [Argument] -> PropertySuccess -> [Argument] -> PropertySuccess -> PropertyFailure
CounterExample :: [Argument] -> PropertyFailure -> PropertyFailure
PropertyFalse :: Maybe Reason -> PropertyFailure
data PropertySuccess
Exist :: [Argument] -> PropertySuccess -> PropertySuccess
ExistUnique :: [Argument] -> PropertySuccess -> PropertySuccess
PropertyTrue :: Maybe Reason -> PropertySuccess
Vacuously :: PropertyFailure -> PropertySuccess
type Argument = String

-- | An explanation for the test outcome.
type Reason = String
data TestQuality
GoodTest :: TestQuality
BadTest :: TestQuality


-- | This module exports the main pieces of SmallCheck functionality.
--   
--   To generate test cases for your own types, refer to
--   <a>Test.SmallCheck.Series</a>.
--   
--   For pointers to other sources of information about SmallCheck, please
--   refer to the README at
--   <a>https://github.com/Bodigrim/smallcheck/blob/master/README.md</a>
module Test.SmallCheck

-- | Set the universal quantification context.
forAll :: Testable m a => a -> Property m

-- | Set the existential quantification context.
exists :: Testable m a => a -> Property m

-- | Set the uniqueness quantification context.
--   
--   Bear in mind that &lt;math&gt; is not the same as &lt;math&gt;.
--   
--   For example, &lt;math&gt; is true (it holds only when &lt;math&gt;),
--   but &lt;math&gt; is false (there are many such pairs).
--   
--   As is customary in mathematics, <tt><a>existsUnique</a> $ \x y -&gt; p
--   x y</tt> is equivalent to <tt><a>existsUnique</a> $ \(x, y) -&gt; p x
--   y</tt> and not to <tt><a>existsUnique</a> $ \x -&gt;
--   <a>existsUnique</a> $ \y -&gt; p x y</tt> (the latter, of course, may
--   be explicitly written when desired).
--   
--   That is, all the variables affected by the same uniqueness context are
--   quantified simultaneously as a tuple.
existsUnique :: Testable m a => a -> Property m

-- | <tt><a>over</a> s $ \x -&gt; p x</tt> makes <tt>x</tt> range over the
--   <a>Series</a> <tt>s</tt> (by default, all variables range over the
--   <a>series</a> for their types).
--   
--   Note that, unlike the quantification operators, this affects only the
--   variable following the operator and not subsequent variables.
--   
--   <a>over</a> does not affect the quantification context.
over :: (Show a, Testable m b) => Series m a -> (a -> b) -> Property m

-- | Execute a monadic test.
monadic :: Testable m a => m a -> Property m

-- | The <a>==&gt;</a> operator can be used to express a restricting
--   condition under which a property should hold. It corresponds to
--   implication in the classical logic.
--   
--   Note that <a>==&gt;</a> resets the quantification context for its
--   operands to the default (universal).
(==>) :: (Testable m c, Testable m a) => c -> a -> Property m
infixr 0 ==>

-- | Run property with a modified depth. Affects all quantified variables
--   in the property.
changeDepth :: Testable m a => (Depth -> Depth) -> a -> Property m

-- | Quantify the function's argument over its <a>series</a>, but adjust
--   the depth. This doesn't affect any subsequent variables.
changeDepth1 :: (Show a, Serial m a, Testable m b) => (Depth -> Depth) -> (a -> b) -> Property m

-- | Maximum depth of generated test values.
--   
--   For data values, it is the depth of nested constructor applications.
--   
--   For functional values, it is both the depth of nested case analysis
--   and the depth of results.
type Depth = Int

-- | A simple driver that runs the test in the <a>IO</a> monad and prints
--   the results.
smallCheck :: Testable IO a => Depth -> a -> IO ()

-- | Class of tests that can be run in a monad. For pure tests, it is
--   recommended to keep their types polymorphic in <tt>m</tt> rather than
--   specialising it to <a>Identity</a>.
class Monad m => Testable m a
test :: Testable m a => a -> Property m

-- | The type of properties over the monad <tt>m</tt>.
data Property m

-- | An explanation for the test outcome.
type Reason = String
