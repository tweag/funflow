-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast binary serialization
--   
--   Fast binary serialization
@package store
@version 0.7.16

module Data.Store.TH.Internal
deriveManyStoreFromStorable :: (Type -> Bool) -> Q [Dec]
deriveTupleStoreInstance :: Int -> Dec
deriveGenericInstance :: Cxt -> Type -> Dec
deriveGenericInstanceFromName :: Name -> Q Dec
deriveManyStorePrimVector :: Q [Dec]
deriveManyStoreUnboxVector :: Q [Dec]
deriveStore :: Cxt -> Type -> [DataCon] -> Q Dec

-- | Given the name of a type, generate a Store instance for it, assuming
--   that all type variables also need to be Store instances.
--   
--   Note that when used with datatypes that require type variables, the
--   ScopedTypeVariables extension is required.
makeStore :: Name -> Q [Dec]
getAllInstanceTypes1 :: Name -> Q [Type]
isMonoType :: Type -> Bool
instance TH.Derive.Internal.Deriver (Data.Store.Impl.Store a)


-- | This module exports TH utilities intended to be useful to users.
--   
--   <a>makeStore</a> can be used to generate a <a>Store</a> instance for
--   types, when all the type variables also require <a>Store</a>
--   instances. If some do not, then instead use <a>TH.Derive</a> like
--   this:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   {-# LANGUAGE ScopedTypeVariables #-}
--   
--   import TH.Derive
--   import Data.Store
--   
--   data Foo a = Foo a | Bar Int
--   
--   $($(derive [d|
--       instance Store a =&gt; Deriving (Store (Foo a))
--       |]))
--   </pre>
--   
--   Note that when used with datatypes that require type variables, the
--   ScopedTypeVariables extension is required.
--   
--   One advantage of using this Template Haskell definition of Store
--   instances is that in some cases they can be faster than the instances
--   defined via Generics. Specifically, sum types which can yield
--   <a>ConstSize</a> from <a>size</a> will be faster when used in
--   array-like types. The instances generated via generics always use
--   <a>VarSize</a> for sum types.
module Data.Store.TH

-- | Given the name of a type, generate a Store instance for it, assuming
--   that all type variables also need to be Store instances.
--   
--   Note that when used with datatypes that require type variables, the
--   ScopedTypeVariables extension is required.
makeStore :: Name -> Q [Dec]

-- | Test a <a>Store</a> instance using <tt>smallcheck</tt> and
--   <a>hspec</a>.
smallcheckManyStore :: Bool -> Int -> [TypeQ] -> ExpQ

-- | Check if a given value succeeds in decoding its encoded
--   representation.
checkRoundtrip :: (Eq a, Show a, Store a) => Bool -> a -> Bool
assertRoundtrip :: (Eq a, Show a, Store a, MonadFail m, Typeable a) => Bool -> a -> m ()


-- | Internal API for the store package. The functions here which are not
--   re-exported by <a>Data.Store</a> are less likely to have stable APIs.
--   
--   This module also defines most of the included <a>Store</a> instances,
--   for types from the base package and other commonly used packages
--   (bytestring, containers, text, time, etc).
module Data.Store.Internal

-- | Serializes a value to a <a>ByteString</a>. In order to do this, it
--   first allocates a <a>ByteString</a> of the correct size (based on
--   <a>size</a>), and then uses <a>poke</a> to fill it.
--   
--   Safety of this function depends on correctness of the <a>Store</a>
--   instance. If <a>size</a> returns a. The good news is that this isn't
--   an issue if you use well-tested manual instances (such as those from
--   this package) combined with auomatic definition of instances.
encode :: Store a => a -> ByteString

-- | Decodes a value from a <a>ByteString</a>. Returns an exception if
--   there's an error while decoding, or if decoding undershoots /
--   overshoots the end of the buffer.
decode :: Store a => ByteString -> Either PeekException a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeWith :: Peek a -> ByteString -> Either PeekException a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions. It is an exception to not consume all input.
decodeEx :: Store a => ByteString -> a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeExWith :: Peek a -> ByteString -> a

-- | Similar to <a>decodeExWith</a>, but it allows there to be more of the
--   buffer remaining. The <a>Offset</a> of the buffer contents immediately
--   after the decoded value is returned.
decodeExPortionWith :: Peek a -> ByteString -> (Offset, a)

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions. It is an exception to not consume all input.
decodeIO :: Store a => ByteString -> IO a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeIOWith :: Peek a -> ByteString -> IO a

-- | Similar to <a>decodeExPortionWith</a>, but runs in the <a>IO</a>
--   monad.
decodeIOPortionWith :: Peek a -> ByteString -> IO (Offset, a)

-- | The <a>Store</a> typeclass provides efficient serialization and
--   deserialization to raw pointer addresses.
--   
--   The <a>peek</a> and <a>poke</a> methods should be defined such that
--   <tt> decodeEx (encode x) == x </tt>.
class Store a

-- | Yields the <a>Size</a> of the buffer, in bytes, required to store the
--   encoded representation of the type.
--   
--   Note that the correctness of this function is crucial for the safety
--   of <a>poke</a>, as it does not do any bounds checking. It is the
--   responsibility of the invoker of <a>poke</a> (<a>encode</a> and
--   similar functions) to ensure that there's enough space in the output
--   buffer. If <a>poke</a> writes beyond, then arbitrary memory can be
--   overwritten, causing undefined behavior and segmentation faults.
size :: Store a => Size a

-- | Serializes a value to bytes. It is the responsibility of the caller to
--   ensure that at least the number of bytes required by <a>size</a> are
--   available. These details are handled by <a>encode</a> and similar
--   utilities.
poke :: Store a => a -> Poke ()

-- | Serialized a value from bytes, throwing exceptions if it encounters
--   invalid data or runs out of input bytes.
peek :: Store a => Peek a

-- | Yields the <a>Size</a> of the buffer, in bytes, required to store the
--   encoded representation of the type.
--   
--   Note that the correctness of this function is crucial for the safety
--   of <a>poke</a>, as it does not do any bounds checking. It is the
--   responsibility of the invoker of <a>poke</a> (<a>encode</a> and
--   similar functions) to ensure that there's enough space in the output
--   buffer. If <a>poke</a> writes beyond, then arbitrary memory can be
--   overwritten, causing undefined behavior and segmentation faults.
size :: (Store a, Generic a, GStoreSize (Rep a)) => Size a

-- | Serializes a value to bytes. It is the responsibility of the caller to
--   ensure that at least the number of bytes required by <a>size</a> are
--   available. These details are handled by <a>encode</a> and similar
--   utilities.
poke :: (Store a, Generic a, GStorePoke (Rep a)) => a -> Poke ()

-- | Serialized a value from bytes, throwing exceptions if it encounters
--   invalid data or runs out of input bytes.
peek :: (Store a, Generic a, GStorePeek (Rep a)) => Peek a

-- | <a>Poke</a> actions are useful for building sequential serializers.
--   
--   They are actions which write values to bytes into memory specified by
--   a <a>Ptr</a> base. The <a>Applicative</a> and <a>Monad</a> instances
--   make it easy to write serializations, by keeping track of the
--   <a>Offset</a> of the current byte. They allow you to chain <a>Poke</a>
--   action such that subsequent <a>Poke</a>s write into subsequent
--   portions of the output.
data Poke a

-- | <a>Peek</a> actions are useful for building sequential deserializers.
--   
--   They are actions which read from memory and construct values from it.
--   The <a>Applicative</a> and <a>Monad</a> instances make it easy to
--   chain these together to get more complicated deserializers. This
--   machinery keeps track of the current <a>Ptr</a> and end-of-buffer
--   <a>Ptr</a>.
data Peek a

-- | Run the <a>Peek</a> action, with a <a>Ptr</a> to the end of the buffer
--   where data is poked, and a <a>Ptr</a> to the current position. The
--   result is the <a>Ptr</a>, along with a return value.
--   
--   May throw a <a>PeekException</a> if the memory contains invalid
--   values.
runPeek :: Peek a -> PeekState -> Ptr Word8 -> IO (PeekResult a)

-- | Exception thrown while running <a>poke</a>. Note that other types of
--   exceptions could also be thrown. Invocations of <a>fail</a> in the
--   <a>Poke</a> monad causes this exception to be thrown.
--   
--   <a>PokeException</a>s are not expected to occur in ordinary
--   circumstances, and usually indicate a programming error.
data PokeException
PokeException :: Offset -> Text -> PokeException
[pokeExByteIndex] :: PokeException -> Offset
[pokeExMessage] :: PokeException -> Text

-- | Throws a <a>PokeException</a>. These should be avoided when possible,
--   they usually indicate a programming error.
pokeException :: Text -> Poke a

-- | Exception thrown while running <a>peek</a>. Note that other types of
--   exceptions can also be thrown. Invocations of <a>fail</a> in the
--   <a>Poke</a> monad causes this exception to be thrown.
--   
--   <a>PeekException</a> is thrown when the data being decoded is invalid.
data PeekException
PeekException :: Offset -> Text -> PeekException
[peekExBytesFromEnd] :: PeekException -> Offset
[peekExMessage] :: PeekException -> Text

-- | Throws a <a>PeekException</a>.
peekException :: Text -> Peek a

-- | Throws a <a>PeekException</a> about an attempt to read too many bytes.
tooManyBytes :: Int -> Int -> String -> IO void

-- | Info about a type's serialized length. Either the length is known
--   independently of the value, or the length depends on the value.
data Size a
VarSize :: (a -> Int) -> Size a
ConstSize :: !Int -> Size a

-- | Get the number of bytes needed to store the given value. See
--   <a>size</a>.
getSize :: Store a => a -> Int

-- | Given a <a>Size</a> value and a value of the type <tt>a</tt>, returns
--   its <a>Int</a> size.
getSizeWith :: Size a -> a -> Int

-- | Create an aggregate <a>Size</a> by providing functions to split the
--   input into two pieces.
--   
--   If both of the types are <a>ConstSize</a>, the result is
--   <a>ConstSize</a> and the functions will not be used.
combineSize :: forall a b c. (Store a, Store b) => (c -> a) -> (c -> b) -> Size c

-- | Create an aggregate <a>Size</a> by providing functions to split the
--   input into two pieces, as well as <a>Size</a> values to use to measure
--   the results.
--   
--   If both of the input <a>Size</a> values are <a>ConstSize</a>, the
--   result is <a>ConstSize</a> and the functions will not be used.
combineSizeWith :: forall a b c. (c -> a) -> (c -> b) -> Size a -> Size b -> Size c

-- | Adds a constant amount to a <a>Size</a> value.
addSize :: Int -> Size a -> Size a

-- | Implement <a>size</a> for an <a>IsSequence</a> of <a>Store</a>
--   instances.
--   
--   Note that many monomorphic containers have more efficient
--   implementations (for example, via memcpy).
sizeSequence :: forall t. (IsSequence t, Store (Element t)) => Size t

-- | Implement <a>poke</a> for an <a>IsSequence</a> of <a>Store</a>
--   instances.
--   
--   Note that many monomorphic containers have more efficient
--   implementations (for example, via memcpy).
pokeSequence :: (IsSequence t, Store (Element t)) => t -> Poke ()

-- | Implement <a>peek</a> for an <a>IsSequence</a> of <a>Store</a>
--   instances.
--   
--   Note that many monomorphic containers have more efficient
--   implementations (for example, via memcpy).
peekSequence :: (IsSequence t, Store (Element t), Index t ~ Int) => Peek t

-- | Implement <a>size</a> for an <a>IsSet</a> of <a>Store</a> instances.
sizeSet :: forall t. (IsSet t, Store (Element t)) => Size t

-- | Implement <a>poke</a> for an <a>IsSequence</a> of <a>Store</a>
--   instances.
pokeSet :: (IsSet t, Store (Element t)) => t -> Poke ()

-- | Implement <a>peek</a> for an <a>IsSequence</a> of <a>Store</a>
--   instances.
peekSet :: (IsSet t, Store (Element t)) => Peek t

-- | Implement <a>size</a> for an <a>IsMap</a> of where both
--   <a>ContainerKey</a> and <a>MapValue</a> are <a>Store</a> instances.
sizeMap :: forall t. (Store (ContainerKey t), Store (MapValue t), IsMap t) => Size t

-- | Implement <a>poke</a> for an <a>IsMap</a> of where both
--   <a>ContainerKey</a> and <a>MapValue</a> are <a>Store</a> instances.
pokeMap :: (Store (ContainerKey t), Store (MapValue t), IsMap t) => t -> Poke ()

-- | Implement <a>peek</a> for an <a>IsMap</a> of where both
--   <a>ContainerKey</a> and <a>MapValue</a> are <a>Store</a> instances.
peekMap :: (Store (ContainerKey t), Store (MapValue t), IsMap t) => Peek t

-- | Like <a>sizeMap</a> but should only be used for ordered containers
--   where <a>mapToList</a> returns an ascending list.
sizeOrdMap :: forall t. (Store (ContainerKey t), Store (MapValue t), IsMap t) => Size t

-- | Like <a>pokeMap</a> but should only be used for ordered containers
--   where <a>mapToList</a> returns an ascending list.
pokeOrdMap :: (Store (ContainerKey t), Store (MapValue t), IsMap t) => t -> Poke ()

-- | Decode the results of <a>pokeOrdMap</a> using a given function to
--   construct the map.
peekOrdMapWith :: (Store (ContainerKey t), Store (MapValue t)) => ([(ContainerKey t, MapValue t)] -> t) -> Peek t
sizeArray :: (Ix i, IArray a e, Store i, Store e) => Size (a i e)
pokeArray :: (Ix i, IArray a e, Store i, Store e) => a i e -> Poke ()
peekArray :: (Ix i, IArray a e, Store i, Store e) => Peek (a i e)
class GStoreSize f
genericSize :: (Generic a, GStoreSize (Rep a)) => Size a
class GStorePoke f
genericPoke :: (Generic a, GStorePoke (Rep a)) => a -> Poke ()
class GStorePeek f
genericPeek :: (Generic a, GStorePeek (Rep a)) => Peek a

-- | Skip n bytes forward.
skip :: Int -> Peek ()

-- | Isolate the input to n bytes, skipping n bytes forward. Fails if
--   <tt>m</tt> advances the offset beyond the isolated region.
isolate :: Int -> Peek a -> Peek a

-- | Ensure the presence of a given magic value.
--   
--   Throws a <a>PeekException</a> if the value isn't present.
peekMagic :: (Eq a, Show a, Store a) => String -> a -> Peek ()
class KnownNat n => IsStaticSize n a
toStaticSize :: IsStaticSize n a => a -> Maybe (StaticSize n a)
newtype StaticSize (n :: Nat) a
StaticSize :: a -> StaticSize (n :: Nat) a
[unStaticSize] :: StaticSize (n :: Nat) a -> a
toStaticSizeEx :: IsStaticSize n a => a -> StaticSize n a
liftStaticSize :: forall n a. (KnownNat n, Lift a) => TypeQ -> StaticSize n a -> ExpQ
staticByteStringExp :: ByteString -> ExpQ
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Info
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Dec
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Name
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.OccName
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.NameFlavour
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Clause
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Pat
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Lit
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Type
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.TyVarBndr
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.TyLit
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Exp
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Match
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Body
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Guard
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Stmt
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Range
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Con
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Bang
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.SourceUnpackedness
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.SourceStrictness
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.DerivClause
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.DerivStrategy
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.FunDep
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Overlap
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Foreign
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Callconv
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Safety
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Fixity
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.FixityDirection
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Pragma
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Inline
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.RuleMatch
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Phases
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.RuleBndr
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.AnnTarget
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.TySynEqn
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.TypeFamilyHead
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.FamilyResultSig
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.InjectivityAnn
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Role
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.PatSynArgs
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.PatSynDir
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.ModName
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.NameSpace
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.PkgName
instance Data.Store.Impl.Store Foreign.C.Types.CBool
instance Data.Store.Impl.Store Foreign.C.Types.CChar
instance Data.Store.Impl.Store Foreign.C.Types.CClock
instance Data.Store.Impl.Store Foreign.C.Types.CDouble
instance Data.Store.Impl.Store Foreign.C.Types.CFloat
instance Data.Store.Impl.Store Foreign.C.Types.CInt
instance Data.Store.Impl.Store Foreign.C.Types.CIntMax
instance Data.Store.Impl.Store Foreign.C.Types.CIntPtr
instance Data.Store.Impl.Store Foreign.C.Types.CLLong
instance Data.Store.Impl.Store Foreign.C.Types.CLong
instance Data.Store.Impl.Store Foreign.C.Types.CPtrdiff
instance Data.Store.Impl.Store Foreign.C.Types.CSChar
instance Data.Store.Impl.Store Foreign.C.Types.CSUSeconds
instance Data.Store.Impl.Store Foreign.C.Types.CShort
instance Data.Store.Impl.Store Foreign.C.Types.CSigAtomic
instance Data.Store.Impl.Store Foreign.C.Types.CSize
instance Data.Store.Impl.Store Foreign.C.Types.CTime
instance Data.Store.Impl.Store Foreign.C.Types.CUChar
instance Data.Store.Impl.Store Foreign.C.Types.CUInt
instance Data.Store.Impl.Store Foreign.C.Types.CUIntMax
instance Data.Store.Impl.Store Foreign.C.Types.CUIntPtr
instance Data.Store.Impl.Store Foreign.C.Types.CULLong
instance Data.Store.Impl.Store Foreign.C.Types.CULong
instance Data.Store.Impl.Store Foreign.C.Types.CUSeconds
instance Data.Store.Impl.Store Foreign.C.Types.CUShort
instance Data.Store.Impl.Store Foreign.C.Types.CWchar
instance Data.Store.Impl.Store Foreign.Ptr.IntPtr
instance Data.Store.Impl.Store Foreign.Ptr.WordPtr
instance Data.Store.Impl.Store GHC.Fingerprint.Type.Fingerprint
instance Data.Store.Impl.Store GHC.Int.Int16
instance Data.Store.Impl.Store GHC.Int.Int32
instance Data.Store.Impl.Store GHC.Int.Int8
instance Data.Store.Impl.Store (GHC.Ptr.FunPtr a)
instance Data.Store.Impl.Store (GHC.Ptr.Ptr a)
instance Data.Store.Impl.Store (GHC.Stable.StablePtr a)
instance Data.Store.Impl.Store GHC.Word.Word16
instance Data.Store.Impl.Store GHC.Word.Word64
instance Data.Store.Impl.Store System.Posix.Types.CBlkCnt
instance Data.Store.Impl.Store System.Posix.Types.CBlkSize
instance Data.Store.Impl.Store System.Posix.Types.CCc
instance Data.Store.Impl.Store System.Posix.Types.CClockId
instance Data.Store.Impl.Store System.Posix.Types.CDev
instance Data.Store.Impl.Store System.Posix.Types.CFsBlkCnt
instance Data.Store.Impl.Store System.Posix.Types.CFsFilCnt
instance Data.Store.Impl.Store System.Posix.Types.CGid
instance Data.Store.Impl.Store System.Posix.Types.CId
instance Data.Store.Impl.Store System.Posix.Types.CIno
instance Data.Store.Impl.Store System.Posix.Types.CKey
instance Data.Store.Impl.Store System.Posix.Types.CMode
instance Data.Store.Impl.Store System.Posix.Types.CNfds
instance Data.Store.Impl.Store System.Posix.Types.CNlink
instance Data.Store.Impl.Store System.Posix.Types.COff
instance Data.Store.Impl.Store System.Posix.Types.CPid
instance Data.Store.Impl.Store System.Posix.Types.CRLim
instance Data.Store.Impl.Store System.Posix.Types.CSocklen
instance Data.Store.Impl.Store System.Posix.Types.CSpeed
instance Data.Store.Impl.Store System.Posix.Types.CSsize
instance Data.Store.Impl.Store System.Posix.Types.CTcflag
instance Data.Store.Impl.Store System.Posix.Types.CTimer
instance Data.Store.Impl.Store System.Posix.Types.CUid
instance Data.Store.Impl.Store System.Posix.Types.Fd
instance Data.Store.Impl.Store System.Clock.TimeSpec
instance Data.Store.Impl.Store GHC.Types.Double
instance Data.Store.Impl.Store GHC.Types.Float
instance Data.Store.Impl.Store Network.Socket.Types.PortNumber
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Primitive.Types.PrimStorable a)
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector c), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector d), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector e), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector f)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (a, b, c, d, e, f))
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector c), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector d), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector e)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (a, b, c, d, e))
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector c), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector d)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (a, b, c, d))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (f (g a))) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Functor.Compose.Compose f g a))
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector c)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (a, b, c))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Functor.Const.Const a b))
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Arg a b))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (f a)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Internal.Alt f a))
instance (Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a), Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector b)) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (a, b))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Complex.Complex a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Functor.Identity.Identity a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Ord.Down a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.First a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Last a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Max a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Min a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.WrappedMonoid a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Internal.Dual a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Internal.Product a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector a) => Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector (Data.Semigroup.Internal.Sum a))
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector Data.Semigroup.Internal.All)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector Data.Semigroup.Internal.Any)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Int.Int16)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Int.Int32)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Int.Int64)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Int.Int8)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Word.Word16)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Word.Word32)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Word.Word64)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Bool)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Char)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Float)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector GHC.Types.Word)
instance Data.Store.Impl.Store (Data.Vector.Unboxed.Base.Vector ())
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Functor.Const.Const a b))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Functor.Identity.Identity a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Ord.Down a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.First a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Last a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Max a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Min a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Internal.Dual a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Internal.Product a))
instance Data.Primitive.Types.Prim a => Data.Store.Impl.Store (Data.Vector.Primitive.Vector (Data.Semigroup.Internal.Sum a))
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CBool)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CChar)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CClock)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CDouble)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CFloat)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CInt)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CIntMax)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CIntPtr)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CLLong)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CLong)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CPtrdiff)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CSChar)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CSUSeconds)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CShort)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CSigAtomic)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CSize)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CTime)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUChar)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUInt)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUIntMax)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUIntPtr)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CULLong)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CULong)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUSeconds)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CUShort)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.C.Types.CWchar)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.Ptr.IntPtr)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector Foreign.Ptr.WordPtr)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Int.Int16)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Int.Int32)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Int.Int64)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Int.Int8)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector (GHC.Ptr.FunPtr a))
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector (GHC.Ptr.Ptr a))
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector (GHC.Stable.StablePtr a))
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Word.Word16)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Word.Word32)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Word.Word64)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Word.Word8)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CBlkCnt)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CBlkSize)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CCc)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CClockId)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CDev)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CFsBlkCnt)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CFsFilCnt)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CGid)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CId)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CIno)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CKey)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CMode)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CNlink)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.COff)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CPid)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CRLim)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CSpeed)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CSsize)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CTcflag)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CTimer)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.CUid)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector System.Posix.Types.Fd)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Types.Char)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Types.Double)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Types.Float)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Types.Int)
instance Data.Store.Impl.Store (Data.Vector.Primitive.Vector GHC.Types.Word)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Complex.Complex a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Functor.Identity.Identity a)
instance Data.Store.Impl.Store Data.Semigroup.Internal.All
instance Data.Store.Impl.Store Data.Semigroup.Internal.Any
instance Data.Store.Impl.Store Data.Void.Void
instance Data.Store.Impl.Store GHC.Types.Bool
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b) => Data.Store.Impl.Store (Data.Either.Either a b)
instance Data.Store.Impl.Store Data.Time.Clock.Internal.AbsoluteTime.AbsoluteTime
instance Data.Store.Impl.Store Data.Time.Calendar.Days.Day
instance Data.Store.Impl.Store Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Data.Store.Impl.Store Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Data.Store.Impl.Store Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Data.Store.Impl.Store Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.Store.Impl.Store Data.Time.Clock.Internal.UniversalTime.UniversalTime
instance Data.Store.Impl.Store Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Data.Store.Impl.Store Data.Time.Format.Locale.TimeLocale
instance Data.Store.Impl.Store Data.Time.Clock.Internal.SystemTime.SystemTime
instance Data.Store.Impl.Store Data.Time.Calendar.CalendarDiffDays.CalendarDiffDays
instance Data.Store.Impl.Store Data.Time.LocalTime.Internal.CalendarDiffTime.CalendarDiffTime
instance Data.Store.Impl.Store Data.Time.Format.ISO8601.FormatExtension
instance Data.Store.Impl.Store (Data.Fixed.Fixed a)
instance Data.Store.Impl.Store Data.Time.Clock.Internal.DiffTime.DiffTime
instance Data.Store.Impl.Store Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Data.Store.Impl.Store ()
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Semigroup.Internal.Dual a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Semigroup.Internal.Sum a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Semigroup.Internal.Product a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Monoid.First a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Monoid.Last a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (GHC.Maybe.Maybe a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Functor.Const.Const a b)
instance GHC.Generics.Generic (Data.Store.Internal.StaticSize n a)
instance (GHC.TypeNats.KnownNat n, Data.Data.Data a) => Data.Data.Data (Data.Store.Internal.StaticSize n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Store.Internal.StaticSize n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Store.Internal.StaticSize n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Store.Internal.StaticSize n a)
instance GHC.TypeNats.KnownNat n => Data.Store.Internal.IsStaticSize n Data.ByteString.Internal.ByteString
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Store.Internal.StaticSize n a)
instance GHC.TypeNats.KnownNat n => Data.Store.Impl.Store (Data.Store.Internal.StaticSize n Data.ByteString.Internal.ByteString)
instance Data.Store.Impl.Store GHC.Int.Int64
instance Data.Store.Impl.Store GHC.Word.Word32
instance Data.Store.Impl.Store GHC.Word.Word8
instance Data.Store.Impl.Store GHC.Types.Char
instance Data.Store.Impl.Store GHC.Types.Int
instance Data.Store.Impl.Store GHC.Types.Word
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Vector.Vector a)
instance Foreign.Storable.Storable a => Data.Store.Impl.Store (Data.Vector.Storable.Vector a)
instance Data.Store.Impl.Store Data.ByteString.Internal.ByteString
instance Data.Store.Impl.Store Language.Haskell.TH.Syntax.Bytes
instance Data.Store.Impl.Store Data.ByteString.Short.Internal.ShortByteString
instance Data.Store.Impl.Store Data.ByteString.Lazy.Internal.ByteString
instance Data.Store.Impl.Store Data.Text.Internal.Text
instance Data.Store.Impl.Store a => Data.Store.Impl.Store [a]
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (GHC.Base.NonEmpty a)
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.Sequence.Internal.Seq a)
instance (Data.Store.Impl.Store a, GHC.Classes.Ord a) => Data.Store.Impl.Store (Data.Set.Internal.Set a)
instance Data.Store.Impl.Store Data.IntSet.Internal.IntSet
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (Data.IntMap.Internal.IntMap a)
instance (GHC.Classes.Ord k, Data.Store.Impl.Store k, Data.Store.Impl.Store a) => Data.Store.Impl.Store (Data.Map.Internal.Map k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Data.Store.Impl.Store k, Data.Store.Impl.Store a) => Data.Store.Impl.Store (Data.HashMap.Internal.HashMap k a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.Store.Impl.Store a) => Data.Store.Impl.Store (Data.HashSet.Internal.HashSet a)
instance (GHC.Ix.Ix i, Data.Store.Impl.Store i, Data.Store.Impl.Store e) => Data.Store.Impl.Store (GHC.Arr.Array i e)
instance (GHC.Ix.Ix i, Data.Array.Base.IArray Data.Array.Base.UArray e, Data.Store.Impl.Store i, Data.Store.Impl.Store e) => Data.Store.Impl.Store (Data.Array.Base.UArray i e)
instance Data.Store.Impl.Store GHC.Integer.Type.Integer
instance Data.Store.Impl.Store GHC.Natural.Natural
instance Data.Store.Impl.Store a => Data.Store.Impl.Store (GHC.Real.Ratio a)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b) => Data.Store.Impl.Store (a, b)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b, Data.Store.Impl.Store c) => Data.Store.Impl.Store (a, b, c)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b, Data.Store.Impl.Store c, Data.Store.Impl.Store d) => Data.Store.Impl.Store (a, b, c, d)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b, Data.Store.Impl.Store c, Data.Store.Impl.Store d, Data.Store.Impl.Store e) => Data.Store.Impl.Store (a, b, c, d, e)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b, Data.Store.Impl.Store c, Data.Store.Impl.Store d, Data.Store.Impl.Store e, Data.Store.Impl.Store f) => Data.Store.Impl.Store (a, b, c, d, e, f)
instance (Data.Store.Impl.Store a, Data.Store.Impl.Store b, Data.Store.Impl.Store c, Data.Store.Impl.Store d, Data.Store.Impl.Store e, Data.Store.Impl.Store f, Data.Store.Impl.Store g) => Data.Store.Impl.Store (a, b, c, d, e, f, g)


-- | This is the main public API of the store package. The functions
--   exported here are more likely to be stable between versions.
--   
--   Usually you won't need to write your own <a>Store</a> instances, and
--   instead can rely on either using the <tt>Generic</tt> deriving
--   approach or <a>Data.Store.TH</a> for defining <a>Store</a> instances
--   for your datatypes. There are some tradeoffs here - the generics
--   instances do not require <tt>-XTemplateHaskell</tt>, but they do not
--   optimize as well for sum types that only require a constant number of
--   bytes.
--   
--   If you need streaming encode / decode of multiple store encoded
--   messages, take a look at the <tt>store-streaming</tt> package.
--   
--   <h1>Gotchas</h1>
--   
--   Store is best used for communication between trusted processes and
--   local caches. It can certainly be used for other purposes, but the
--   builtin set of instances have some gotchas to be aware of:
--   
--   <ul>
--   <li>Store's builtin instances serialize in a format which depends on
--   machine endianness.</li>
--   <li>Store's builtin instances trust the data when deserializing. For
--   example, the deserialization of <tt>Vector</tt> will read the vector's
--   link from the first 8 bytes. It will then allocate enough memory to
--   store all the elements. Malicious or malformed input could cause
--   allocation of large amounts of memory. See
--   <a>https://github.com/fpco/store/issues/122</a></li>
--   </ul>
module Data.Store

-- | Serializes a value to a <a>ByteString</a>. In order to do this, it
--   first allocates a <a>ByteString</a> of the correct size (based on
--   <a>size</a>), and then uses <a>poke</a> to fill it.
--   
--   Safety of this function depends on correctness of the <a>Store</a>
--   instance. If <a>size</a> returns a. The good news is that this isn't
--   an issue if you use well-tested manual instances (such as those from
--   this package) combined with auomatic definition of instances.
encode :: Store a => a -> ByteString

-- | Decodes a value from a <a>ByteString</a>. Returns an exception if
--   there's an error while decoding, or if decoding undershoots /
--   overshoots the end of the buffer.
decode :: Store a => ByteString -> Either PeekException a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeWith :: Peek a -> ByteString -> Either PeekException a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions. It is an exception to not consume all input.
decodeEx :: Store a => ByteString -> a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeExWith :: Peek a -> ByteString -> a

-- | Similar to <a>decodeExWith</a>, but it allows there to be more of the
--   buffer remaining. The <a>Offset</a> of the buffer contents immediately
--   after the decoded value is returned.
decodeExPortionWith :: Peek a -> ByteString -> (Offset, a)

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions. It is an exception to not consume all input.
decodeIO :: Store a => ByteString -> IO a

-- | Decodes a value from a <a>ByteString</a>, potentially throwing
--   exceptions, and taking a <a>Peek</a> to run. It is an exception to not
--   consume all input.
decodeIOWith :: Peek a -> ByteString -> IO a

-- | Similar to <a>decodeExPortionWith</a>, but runs in the <a>IO</a>
--   monad.
decodeIOPortionWith :: Peek a -> ByteString -> IO (Offset, a)

-- | The <a>Store</a> typeclass provides efficient serialization and
--   deserialization to raw pointer addresses.
--   
--   The <a>peek</a> and <a>poke</a> methods should be defined such that
--   <tt> decodeEx (encode x) == x </tt>.
class Store a

-- | Yields the <a>Size</a> of the buffer, in bytes, required to store the
--   encoded representation of the type.
--   
--   Note that the correctness of this function is crucial for the safety
--   of <a>poke</a>, as it does not do any bounds checking. It is the
--   responsibility of the invoker of <a>poke</a> (<a>encode</a> and
--   similar functions) to ensure that there's enough space in the output
--   buffer. If <a>poke</a> writes beyond, then arbitrary memory can be
--   overwritten, causing undefined behavior and segmentation faults.
size :: Store a => Size a

-- | Serializes a value to bytes. It is the responsibility of the caller to
--   ensure that at least the number of bytes required by <a>size</a> are
--   available. These details are handled by <a>encode</a> and similar
--   utilities.
poke :: Store a => a -> Poke ()

-- | Serialized a value from bytes, throwing exceptions if it encounters
--   invalid data or runs out of input bytes.
peek :: Store a => Peek a

-- | Yields the <a>Size</a> of the buffer, in bytes, required to store the
--   encoded representation of the type.
--   
--   Note that the correctness of this function is crucial for the safety
--   of <a>poke</a>, as it does not do any bounds checking. It is the
--   responsibility of the invoker of <a>poke</a> (<a>encode</a> and
--   similar functions) to ensure that there's enough space in the output
--   buffer. If <a>poke</a> writes beyond, then arbitrary memory can be
--   overwritten, causing undefined behavior and segmentation faults.
size :: (Store a, Generic a, GStoreSize (Rep a)) => Size a

-- | Serializes a value to bytes. It is the responsibility of the caller to
--   ensure that at least the number of bytes required by <a>size</a> are
--   available. These details are handled by <a>encode</a> and similar
--   utilities.
poke :: (Store a, Generic a, GStorePoke (Rep a)) => a -> Poke ()

-- | Serialized a value from bytes, throwing exceptions if it encounters
--   invalid data or runs out of input bytes.
peek :: (Store a, Generic a, GStorePeek (Rep a)) => Peek a

-- | Info about a type's serialized length. Either the length is known
--   independently of the value, or the length depends on the value.
data Size a
VarSize :: (a -> Int) -> Size a
ConstSize :: !Int -> Size a

-- | <a>Poke</a> actions are useful for building sequential serializers.
--   
--   They are actions which write values to bytes into memory specified by
--   a <a>Ptr</a> base. The <a>Applicative</a> and <a>Monad</a> instances
--   make it easy to write serializations, by keeping track of the
--   <a>Offset</a> of the current byte. They allow you to chain <a>Poke</a>
--   action such that subsequent <a>Poke</a>s write into subsequent
--   portions of the output.
data Poke a

-- | <a>Peek</a> actions are useful for building sequential deserializers.
--   
--   They are actions which read from memory and construct values from it.
--   The <a>Applicative</a> and <a>Monad</a> instances make it easy to
--   chain these together to get more complicated deserializers. This
--   machinery keeps track of the current <a>Ptr</a> and end-of-buffer
--   <a>Ptr</a>.
data Peek a
class GStoreSize f
class GStorePoke f
class GStorePeek f

-- | Exception thrown while running <a>peek</a>. Note that other types of
--   exceptions can also be thrown. Invocations of <a>fail</a> in the
--   <a>Poke</a> monad causes this exception to be thrown.
--   
--   <a>PeekException</a> is thrown when the data being decoded is invalid.
data PeekException
PeekException :: Offset -> Text -> PeekException
[peekExBytesFromEnd] :: PeekException -> Offset
[peekExMessage] :: PeekException -> Text

-- | Throws a <a>PeekException</a>.
peekException :: Text -> Peek a

module Data.Store.TypeHash.Internal
newtype Tagged a
Tagged :: a -> Tagged a
[unTagged] :: Tagged a -> a
newtype TypeHash
TypeHash :: StaticSize 20 ByteString -> TypeHash
[unTypeHash] :: TypeHash -> StaticSize 20 ByteString
reifyManyTyDecls :: ((Name, Info) -> Q (Bool, [Name])) -> [Name] -> Q [(Name, Info)]

-- | At compiletime, this yields a hash of the specified datatypes. Not
--   only does this cover the datatypes themselves, but also all transitive
--   dependencies.
--   
--   The resulting expression is a literal of type <a>TypeHash</a>.
typeHashForNames :: [Name] -> Q Exp

-- | At compiletime, this yields a cryptographic hash of the specified
--   <a>Type</a>, including the definition of things it references
--   (transitively).
--   
--   The resulting expression is a literal of type <a>TypeHash</a>.
hashOfType :: Type -> Q Exp
getTypeInfosRecursively :: [Name] -> Q [(Name, Info)]
getConNames :: Data a => a -> [Name]
getVarNames :: Data a => a -> [Name]
class HasTypeHash a
typeHash :: HasTypeHash a => Proxy a -> TypeHash

-- | <i>Deprecated: Use of Data.Store.TypeHash isn't recommended, as the
--   hashes are too unstable for most uses. Please instead consider using
--   Data.Store.Version. See
--   <a>https://github.com/fpco/store/issues/53</a></i>
mkHasTypeHash :: Type -> Q [Dec]

-- | <i>Deprecated: Use of Data.Store.TypeHash isn't recommended, as the
--   hashes are too unstable for most uses. Please instead consider using
--   Data.Store.Version. See
--   <a>https://github.com/fpco/store/issues/53</a></i>
mkManyHasTypeHash :: [Q Type] -> Q [Dec]
combineTypeHashes :: [TypeHash] -> TypeHash
instance GHC.Generics.Generic (Data.Store.TypeHash.Internal.Tagged a)
instance Data.Data.Data a => Data.Data.Data (Data.Store.TypeHash.Internal.Tagged a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Store.TypeHash.Internal.Tagged a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Store.TypeHash.Internal.Tagged a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Store.TypeHash.Internal.Tagged a)
instance GHC.Generics.Generic Data.Store.TypeHash.Internal.TypeHash
instance Data.Store.Impl.Store Data.Store.TypeHash.Internal.TypeHash
instance GHC.Show.Show Data.Store.TypeHash.Internal.TypeHash
instance GHC.Classes.Ord Data.Store.TypeHash.Internal.TypeHash
instance GHC.Classes.Eq Data.Store.TypeHash.Internal.TypeHash
instance Data.Data.Data Data.Store.TypeHash.Internal.TypeHash
instance (Data.Store.Impl.Store a, Data.Store.TypeHash.Internal.HasTypeHash a) => Data.Store.Impl.Store (Data.Store.TypeHash.Internal.Tagged a)
instance Control.DeepSeq.NFData Data.Store.TypeHash.Internal.TypeHash
instance Language.Haskell.TH.Syntax.Lift Data.Store.TypeHash.Internal.TypeHash
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Store.TypeHash.Internal.Tagged a)

module Data.Store.TypeHash
newtype Tagged a
Tagged :: a -> Tagged a
[unTagged] :: Tagged a -> a
data TypeHash
class HasTypeHash a
typeHash :: HasTypeHash a => Proxy a -> TypeHash

-- | <i>Deprecated: Use of Data.Store.TypeHash isn't recommended, as the
--   hashes are too unstable for most uses. Please instead consider using
--   Data.Store.Version. See
--   <a>https://github.com/fpco/store/issues/53</a></i>
mkHasTypeHash :: Type -> Q [Dec]

-- | <i>Deprecated: Use of Data.Store.TypeHash isn't recommended, as the
--   hashes are too unstable for most uses. Please instead consider using
--   Data.Store.Version. See
--   <a>https://github.com/fpco/store/issues/53</a></i>
mkManyHasTypeHash :: [Q Type] -> Q [Dec]


-- | This module provides utilities which help ensure that we aren't
--   attempting to de-serialize data that is an older or newer version. The
--   <tt>WithVersion</tt> utility wraps up a datatype along with a version
--   tag. This version tag can either be provided by the user
--   (<a>namedVersionConfig</a>), or use a computed hash
--   (<a>hashedVersionConfig</a>).
--   
--   The magic here is using an SYB traversal (<a>Data</a>) to get the
--   structure of all the data-types involved. This info is rendered to
--   text and hashed to yield a hash which describes it.
--   
--   NOTE that this API is still quite new and so is likely to break
--   compatibility in the future. It should also be expected that the
--   computed hashes may change between major version bumps, though this
--   will be minimized when directly feasible.
module Data.Store.Version
newtype StoreVersion
StoreVersion :: ByteString -> StoreVersion
[unStoreVersion] :: StoreVersion -> ByteString

-- | Configuration for the version checking of a particular type.
data VersionConfig a
VersionConfig :: Maybe String -> Maybe String -> Set String -> Map String String -> VersionConfig a

-- | When set, specifies the hash which is expected to be computed.
[vcExpectedHash] :: VersionConfig a -> Maybe String

-- | When set, specifies the name to instead use to tag the data.
[vcManualName] :: VersionConfig a -> Maybe String

-- | DataTypes to ignore.
[vcIgnore] :: VersionConfig a -> Set String

-- | Allowed renamings of datatypes, useful when they move.
[vcRenames] :: VersionConfig a -> Map String String
hashedVersionConfig :: String -> VersionConfig a
namedVersionConfig :: String -> String -> VersionConfig a
encodeWithVersionQ :: Data a => VersionConfig a -> Q Exp
decodeWithVersionQ :: Data a => VersionConfig a -> Q Exp
instance Data.Store.Impl.Store Data.Store.Version.StoreVersion
instance GHC.Generics.Generic Data.Store.Version.StoreVersion
instance Data.Data.Data Data.Store.Version.StoreVersion
instance GHC.Classes.Ord Data.Store.Version.StoreVersion
instance GHC.Show.Show Data.Store.Version.StoreVersion
instance GHC.Classes.Eq Data.Store.Version.StoreVersion
instance GHC.Generics.Generic (Data.Store.Version.VersionConfig a)
instance Data.Data.Data a => Data.Data.Data (Data.Store.Version.VersionConfig a)
instance GHC.Show.Show (Data.Store.Version.VersionConfig a)
instance GHC.Classes.Eq (Data.Store.Version.VersionConfig a)


-- | A <a>ByteBuffer</a> is a simple buffer for bytes. It supports two
--   operations: refilling with the contents of a <a>ByteString</a>, and
--   consuming a fixed number of bytes.
--   
--   It is implemented as a pointer, together with counters that keep track
--   of the offset and the number of bytes in the buffer. Note that the
--   counters are simple <a>IORef</a>s, so <a>ByteBuffer</a>s are not
--   thread-safe!
--   
--   A <a>ByteBuffer</a> is constructed by <a>new</a> with a given starting
--   length, and will grow (by repeatedly multiplying its size by 1.5)
--   whenever it is being fed a <a>ByteString</a> that is too large.
module System.IO.ByteBuffer
type ByteBuffer = IORef (Either ByteBufferException BBRef)

-- | Allocates a new ByteBuffer with a given buffer size filling from the
--   given FillBuffer.
--   
--   Note that <a>ByteBuffer</a>s created with <a>new</a> have to be
--   deallocated explicitly using <a>free</a>. For automatic deallocation,
--   consider using <a>with</a> instead.
new :: MonadIO m => Maybe Int -> m ByteBuffer

-- | Free a byte buffer.
free :: MonadIO m => ByteBuffer -> m ()

-- | Perform some action with a bytebuffer, with automatic allocation and
--   deallocation.
with :: (MonadIO m, MonadBaseControl IO m) => Maybe Int -> (ByteBuffer -> m a) -> m a
totalSize :: MonadIO m => ByteBuffer -> m Int
isEmpty :: MonadIO m => ByteBuffer -> m Bool

-- | Number of available bytes in a <a>ByteBuffer</a> (that is, bytes that
--   have been copied to, but not yet read from the <a>ByteBuffer</a>.
availableBytes :: MonadIO m => ByteBuffer -> m Int

-- | Copy the contents of a <a>ByteString</a> to a <a>ByteBuffer</a>.
--   
--   If necessary, the <a>ByteBuffer</a> is enlarged and/or already
--   consumed bytes are dropped.
copyByteString :: MonadIO m => ByteBuffer -> ByteString -> m ()

-- | Will read at most n bytes from the given <a>Fd</a>, in a non-blocking
--   fashion. This function is intended to be used with non-blocking
--   <tt>Socket</tt>s, such the ones created by the <tt>network</tt>
--   package.
--   
--   Returns how many bytes could be read non-blockingly.
fillFromFd :: (MonadIO m, MonadFail m) => ByteBuffer -> Fd -> Int -> m Int

-- | As <a>unsafeConsume</a>, but instead of returning a <a>Ptr</a> into
--   the contents of the <a>ByteBuffer</a>, it returns a <a>ByteString</a>
--   containing the next <tt>n</tt> bytes in the buffer. This involves
--   allocating a new <a>ByteString</a> and copying the <tt>n</tt> bytes to
--   it.
consume :: MonadIO m => ByteBuffer -> Int -> m (Either Int ByteString)

-- | Try to get a pointer to <tt>n</tt> bytes from the <a>ByteBuffer</a>.
--   
--   Note that the pointer should be used before any other actions are
--   performed on the <a>ByteBuffer</a>. It points to some address within
--   the buffer, so operations such as enlarging the buffer or feeding it
--   new data will change the data the pointer points to. This is why this
--   function is called unsafe.
unsafeConsume :: MonadIO m => ByteBuffer -> Int -> m (Either Int (Ptr Word8))

-- | Exception that is thrown when an invalid <a>ByteBuffer</a> is being
--   used that is no longer valid.
--   
--   A <a>ByteBuffer</a> is considered to be invalid if
--   
--   <ul>
--   <li>it has explicitly been freed</li>
--   <li>an Exception has occured during an operation that modified it</li>
--   </ul>
data ByteBufferException
ByteBufferException :: !String -> !String -> ByteBufferException

-- | function name that caused the exception
[_bbeLocation] :: ByteBufferException -> !String

-- | printed representation of the exception
[_bbeException] :: ByteBufferException -> !String
instance GHC.Classes.Eq System.IO.ByteBuffer.ByteBufferException
instance GHC.Show.Show System.IO.ByteBuffer.ByteBufferException
instance GHC.Exception.Type.Exception System.IO.ByteBuffer.ByteBufferException
