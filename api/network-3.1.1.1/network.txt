-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Low-level networking interface
--   
--   This package provides a low-level networking interface.
--   
--   <h3>High-Level Packages</h3>
--   
--   Other packages provide higher level interfaces:
--   
--   <ul>
--   <li>connection</li>
--   <li>hookup</li>
--   <li>network-simple</li>
--   </ul>
--   
--   <h3>Extended Packages</h3>
--   
--   <tt>network</tt> seeks to provide a cross-platform core for
--   networking. As such some APIs live in extended libraries. Packages in
--   the <tt>network</tt> ecosystem are often prefixed with
--   <tt>network-</tt>.
--   
--   <h4><tt>network-bsd</tt></h4>
--   
--   In <tt>network-3.0.0.0</tt> the <tt>Network.BSD</tt> module was split
--   off into its own package, <tt>network-bsd-3.0.0.0</tt>.
--   
--   <h4><tt>network-uri</tt></h4>
--   
--   In <tt>network-2.6</tt> the <tt>Network.URI</tt> module was split off
--   into its own package, <tt>network-uri-2.6</tt>. If you're using the
--   <tt>Network.URI</tt> module you can automatically get it from the
--   right package by adding this to your <tt>.cabal</tt> file:
--   
--   <pre>
--   library
--     build-depends: network-uri-flag
--   </pre>
@package network
@version 3.1.1.1


-- | A module containing semi-public <a>Socket</a> internals. Modules which
--   extend the <a>Socket</a> module will need to use this module while
--   ideally most users will be able to make do with the public interface.
module Network.Socket.Internal

-- | Throw an <a>IOError</a> corresponding to the current socket error.
throwSocketError :: String -> IO a

-- | Like <a>throwSocketError</a>, but the error code is supplied as an
--   argument.
--   
--   On Windows, do not use errno. Use a system error code instead.
throwSocketErrorCode :: String -> CInt -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>. Discards the result of
--   the IO action after error handling.
throwSocketErrorIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation.
throwSocketErrorIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Discards the result of the IO action after
--   error handling.
throwSocketErrorIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Checks for operations that would block and
--   executes an alternative action before retrying in that case.
throwSocketErrorIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO b -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   read-ready, and try again.
throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   write-ready, and try again.
throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | With older versions of the <tt>network</tt> library (version 2.6.0.2
--   or earlier) on Windows operating systems, the networking subsystem
--   must be initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   <a>withSocketsDo</a> is not necessary for the current network library.
--   However, for compatibility with older versions on Windows, it is good
--   practice to always call <a>withSocketsDo</a> (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Zero a structure.
zeroMemory :: Ptr a -> CSize -> IO ()


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket
--   import Network.Socket.ByteString
--   </pre>
module Network.Socket.ByteString

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
send :: Socket -> ByteString -> IO Int

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Unlike <a>send</a>, this function continues to send data until
--   either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
sendAll :: Socket -> ByteString -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendTo :: Socket -> ByteString -> SockAddr -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Unlike <a>sendTo</a>,
--   this function continues to send data until either all data has been
--   sent or an error occurs. On error, an exception is raised, and there
--   is no way to determine how much data, if any, was successfully sent.
sendAllTo :: Socket -> ByteString -> SockAddr -> IO ()

-- | Send data to the socket. The socket must be in a connected state. The
--   data is sent as if the parts have been concatenated. This function
--   continues to send data until either all data has been sent or an error
--   occurs. On error, an exception is raised, and there is no way to
--   determine how much data, if any, was successfully sent.
sendMany :: Socket -> [ByteString] -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. The data is sent as if
--   the parts have been concatenated. This function continues to send data
--   until either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
sendManyTo :: Socket -> [ByteString] -> SockAddr -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
recv :: Socket -> Int -> IO ByteString

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, address)</tt> where <tt>bytes</tt> is a
--   <a>ByteString</a> representing the data received and <tt>address</tt>
--   is a <a>SockAddr</a> representing the address of the sending socket.
recvFrom :: Socket -> Int -> IO (ByteString, SockAddr)


-- | This module provides extensible APIs for socket addresses.
module Network.Socket.Address

-- | The core typeclass to unify socket addresses.
class SocketAddress sa
sizeOfSocketAddress :: SocketAddress sa => sa -> Int
peekSocketAddress :: SocketAddress sa => Ptr sa -> IO sa
pokeSocketAddress :: SocketAddress sa => Ptr a -> sa -> IO ()

-- | Getting peer's socket address.
getPeerName :: SocketAddress sa => Socket -> IO sa

-- | Getting my socket address.
getSocketName :: SocketAddress sa => Socket -> IO sa

-- | Connect to a remote socket at address.
connect :: SocketAddress sa => Socket -> sa -> IO ()

-- | Bind the socket to an address. The socket must not already be bound.
--   The <a>Family</a> passed to <tt>bind</tt> must be the same as that
--   passed to <a>socket</a>. If the special port number <a>defaultPort</a>
--   is passed then the system assigns the next available use port.
bind :: SocketAddress sa => Socket -> sa -> IO ()

-- | Accept a connection. The socket must be bound to an address and
--   listening for connections. The return value is a pair <tt>(conn,
--   address)</tt> where <tt>conn</tt> is a new socket object usable to
--   send and receive data on the connection, and <tt>address</tt> is the
--   address bound to the socket on the other end of the connection. On
--   Unix, FD_CLOEXEC is set to the new <a>Socket</a>.
accept :: SocketAddress sa => Socket -> IO (Socket, sa)

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendTo :: SocketAddress sa => Socket -> ByteString -> sa -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Unlike <a>sendTo</a>,
--   this function continues to send data until either all data has been
--   sent or an error occurs. On error, an exception is raised, and there
--   is no way to determine how much data, if any, was successfully sent.
sendAllTo :: SocketAddress sa => Socket -> ByteString -> sa -> IO ()

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, address)</tt> where <tt>bytes</tt> is a
--   <a>ByteString</a> representing the data received and <tt>address</tt>
--   is a <a>SockAddr</a> representing the address of the sending socket.
--   
--   If the first return value is zero, it means EOF.
recvFrom :: SocketAddress sa => Socket -> Int -> IO (ByteString, sa)

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendBufTo :: SocketAddress sa => Socket -> Ptr a -> Int -> sa -> IO Int

-- | Receive data from the socket, writing it into buffer instead of
--   creating a new string. The socket need not be in a connected state.
--   Returns <tt>(nbytes, address)</tt> where <tt>nbytes</tt> is the number
--   of bytes received and <tt>address</tt> is a <a>SockAddr</a>
--   representing the address of the sending socket.
--   
--   If the first return value is zero, it means EOF.
--   
--   For <a>Stream</a> sockets, the second return value would be invalid.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)
recvBufFrom :: SocketAddress sa => Socket -> Ptr a -> Int -> IO (Int, sa)


-- | This is the main module of the network package supposed to be used
--   with either <a>Network.Socket.ByteString</a> or
--   <a>Network.Socket.ByteString.Lazy</a> for sending/receiving.
--   
--   Here are two minimal example programs using the TCP/IP protocol:
--   
--   <ul>
--   <li>a server that echoes all data that it receives back</li>
--   <li>a client using it</li>
--   </ul>
--   
--   <pre>
--   -- Echo server program
--   module Main (main) where
--   
--   import Control.Concurrent (forkFinally)
--   import qualified Control.Exception as E
--   import Control.Monad (unless, forever, void)
--   import qualified Data.ByteString as S
--   import Network.Socket
--   import Network.Socket.ByteString (recv, sendAll)
--   
--   main :: IO ()
--   main = runTCPServer Nothing "3000" talk
--     where
--       talk s = do
--           msg &lt;- recv s 1024
--           unless (S.null msg) $ do
--             sendAll s msg
--             talk s
--   
--   -- from the "network-run" package.
--   runTCPServer :: Maybe HostName -&gt; ServiceName -&gt; (Socket -&gt; IO a) -&gt; IO a
--   runTCPServer mhost port server = withSocketsDo $ do
--       addr &lt;- resolve
--       E.bracket (open addr) close loop
--     where
--       resolve = do
--           let hints = defaultHints {
--                   addrFlags = [AI_PASSIVE]
--                 , addrSocketType = Stream
--                 }
--           head &lt;$&gt; getAddrInfo (Just hints) mhost (Just port)
--       open addr = do
--           sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--           setSocketOption sock ReuseAddr 1
--           withFdSocket sock $ setCloseOnExecIfNeeded
--           bind sock $ addrAddress addr
--           listen sock 1024
--           return sock
--       loop sock = forever $ do
--           (conn, _peer) &lt;- accept sock
--           void $ forkFinally (server conn) (const $ gracefulClose conn 5000)
--   </pre>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   -- Echo client program
--   module Main (main) where
--   
--   import qualified Control.Exception as E
--   import qualified Data.ByteString.Char8 as C
--   import Network.Socket
--   import Network.Socket.ByteString (recv, sendAll)
--   
--   main :: IO ()
--   main = runTCPClient "127.0.0.1" "3000" $ \s -&gt; do
--       sendAll s "Hello, world!"
--       msg &lt;- recv s 1024
--       putStr "Received: "
--       C.putStrLn msg
--   
--   -- from the "network-run" package.
--   runTCPClient :: HostName -&gt; ServiceName -&gt; (Socket -&gt; IO a) -&gt; IO a
--   runTCPClient host port client = withSocketsDo $ do
--       addr &lt;- resolve
--       E.bracket (open addr) close client
--     where
--       resolve = do
--           let hints = defaultHints { addrSocketType = Stream }
--           head &lt;$&gt; getAddrInfo (Just hints) (Just host) (Just port)
--       open addr = do
--           sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--           connect sock $ addrAddress addr
--           return sock
--   </pre>
--   
--   The proper programming model is that one <a>Socket</a> is handled by a
--   single thread. If multiple threads use one <a>Socket</a> concurrently,
--   unexpected things would happen. There is one exception for multiple
--   threads vs a single <a>Socket</a>: one thread reads data from a
--   <a>Socket</a> only and the other thread writes data to the
--   <a>Socket</a> only.
module Network.Socket

-- | With older versions of the <tt>network</tt> library (version 2.6.0.2
--   or earlier) on Windows operating systems, the networking subsystem
--   must be initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   <a>withSocketsDo</a> is not necessary for the current network library.
--   However, for compatibility with older versions on Windows, it is good
--   practice to always call <a>withSocketsDo</a> (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Resolve a host or service name to one or more addresses. The
--   <a>AddrInfo</a> values that this function returns contain
--   <a>SockAddr</a> values that you can pass directly to <tt>connect</tt>
--   or <tt>bind</tt>.
--   
--   This function is protocol independent. It can return both IPv4 and
--   IPv6 address information.
--   
--   The <a>AddrInfo</a> argument specifies the preferred query behaviour,
--   socket options, or protocol. You can override these conveniently using
--   Haskell's record update syntax on <a>defaultHints</a>, for example as
--   follows:
--   
--   <pre>
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
--   </pre>
--   
--   You must provide a <a>Just</a> value for at least one of the
--   <a>HostName</a> or <a>ServiceName</a> arguments. <a>HostName</a> can
--   be either a numeric network address (dotted quad for IPv4,
--   colon-separated hex for IPv6) or a hostname. In the latter case, its
--   addresses will be looked up unless <a>AI_NUMERICHOST</a> is specified
--   as a hint. If you do not provide a <a>HostName</a> value <i>and</i> do
--   not set <a>AI_PASSIVE</a> as a hint, network addresses in the result
--   will contain the address of the loopback interface.
--   
--   If the query fails, this function throws an IO exception instead of
--   returning an empty list. Otherwise, it returns a non-empty list of
--   <a>AddrInfo</a> values.
--   
--   There are several reasons why a query might result in several values.
--   For example, the queried-for host could be multihomed, or the service
--   might be available via several protocols.
--   
--   Note: the order of arguments is slightly different to that defined for
--   <tt>getaddrinfo</tt> in RFC 2553. The <a>AddrInfo</a> parameter comes
--   first to make partial application easier.
--   
--   <pre>
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
--   
--   &gt;&gt;&gt; addrAddress addr
--   127.0.0.1:80
--   </pre>
getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String

-- | Either a service name e.g., <tt>"http"</tt> or a numeric port number.
type ServiceName = String
data AddrInfo
AddrInfo :: [AddrInfoFlag] -> Family -> SocketType -> ProtocolNumber -> SockAddr -> Maybe String -> AddrInfo
[addrFlags] :: AddrInfo -> [AddrInfoFlag]
[addrFamily] :: AddrInfo -> Family
[addrSocketType] :: AddrInfo -> SocketType
[addrProtocol] :: AddrInfo -> ProtocolNumber
[addrAddress] :: AddrInfo -> SockAddr
[addrCanonName] :: AddrInfo -> Maybe String

-- | Default hints for address lookup with <a>getAddrInfo</a>. The values
--   of the <a>addrAddress</a> and <a>addrCanonName</a> fields are
--   <a>undefined</a>, and are never inspected by <a>getAddrInfo</a>.
--   
--   <pre>
--   &gt;&gt;&gt; addrFlags defaultHints
--   []
--   
--   &gt;&gt;&gt; addrFamily defaultHints
--   AF_UNSPEC
--   
--   &gt;&gt;&gt; addrSocketType defaultHints
--   NoSocketType
--   
--   &gt;&gt;&gt; addrProtocol defaultHints
--   0
--   </pre>
defaultHints :: AddrInfo

-- | Flags that control the querying behaviour of <a>getAddrInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-25</a>
data AddrInfoFlag

-- | The list of returned <a>AddrInfo</a> values will only contain IPv4
--   addresses if the local system has at least one IPv4 interface
--   configured, and likewise for IPv6. (Only some platforms support this.)
AI_ADDRCONFIG :: AddrInfoFlag

-- | If <a>AI_ALL</a> is specified, return all matching IPv6 and IPv4
--   addresses. Otherwise, this flag has no effect. (Only some platforms
--   support this.)
AI_ALL :: AddrInfoFlag

-- | The <a>addrCanonName</a> field of the first returned <a>AddrInfo</a>
--   will contain the "canonical name" of the host.
AI_CANONNAME :: AddrInfoFlag

-- | The <a>HostName</a> argument <i>must</i> be a numeric address in
--   string form, and network name lookups will not be attempted.
AI_NUMERICHOST :: AddrInfoFlag

-- | The <a>ServiceName</a> argument <i>must</i> be a port number in string
--   form, and service name lookups will not be attempted. (Only some
--   platforms support this.)
AI_NUMERICSERV :: AddrInfoFlag

-- | If no <a>HostName</a> value is provided, the network address in each
--   <a>SockAddr</a> will be left as a "wild card". This is useful for
--   server applications that will accept connections from any client.
AI_PASSIVE :: AddrInfoFlag

-- | If an IPv6 lookup is performed, and no IPv6 addresses are found,
--   IPv6-mapped IPv4 addresses will be returned. (Only some platforms
--   support this.)
AI_V4MAPPED :: AddrInfoFlag

-- | Indicate whether the given <a>AddrInfoFlag</a> will have any effect on
--   this system.
addrInfoFlagImplemented :: AddrInfoFlag -> Bool

-- | Connect to a remote socket at address.
connect :: Socket -> SockAddr -> IO ()

-- | Bind the socket to an address. The socket must not already be bound.
--   The <a>Family</a> passed to <tt>bind</tt> must be the same as that
--   passed to <tt>socket</tt>. If the special port number
--   <a>defaultPort</a> is passed then the system assigns the next
--   available use port.
bind :: Socket -> SockAddr -> IO ()

-- | Listen for connections made to the socket. The second argument
--   specifies the maximum number of queued connections and should be at
--   least 1; the maximum value is system-dependent (usually 5).
listen :: Socket -> Int -> IO ()

-- | Accept a connection. The socket must be bound to an address and
--   listening for connections. The return value is a pair <tt>(conn,
--   address)</tt> where <tt>conn</tt> is a new socket object usable to
--   send and receive data on the connection, and <tt>address</tt> is the
--   address bound to the socket on the other end of the connection. On
--   Unix, FD_CLOEXEC is set to the new <a>Socket</a>.
accept :: Socket -> IO (Socket, SockAddr)

-- | Close the socket. This function does not throw exceptions even if the
--   underlying system call returns errors.
--   
--   If multiple threads use the same socket and one uses
--   <a>unsafeFdSocket</a> and the other use <a>close</a>, unexpected
--   behavior may happen. For more information, please refer to the
--   documentation of <a>unsafeFdSocket</a>.
close :: Socket -> IO ()

-- | Close the socket. This function throws exceptions if the underlying
--   system call returns errors.
close' :: Socket -> IO ()

-- | Closing a socket gracefully. This sends TCP FIN and check if TCP FIN
--   is received from the peer. The second argument is time out to receive
--   TCP FIN in millisecond. In both normal cases and error cases, socket
--   is deallocated finally.
--   
--   Since: 3.1.1.0
gracefulClose :: Socket -> Int -> IO ()

-- | Shut down one or both halves of the connection, depending on the
--   second argument to the function. If the second argument is
--   <a>ShutdownReceive</a>, further receives are disallowed. If it is
--   <a>ShutdownSend</a>, further sends are disallowed. If it is
--   <a>ShutdownBoth</a>, further sends and receives are disallowed.
shutdown :: Socket -> ShutdownCmd -> IO ()
data ShutdownCmd
ShutdownReceive :: ShutdownCmd
ShutdownSend :: ShutdownCmd
ShutdownBoth :: ShutdownCmd

-- | Socket options for use with <a>setSocketOption</a> and
--   <a>getSocketOption</a>.
--   
--   The existence of a constructor does not imply that the relevant option
--   is supported on your system: see <a>isSupportedSocketOption</a>
data SocketOption

-- | SO_DEBUG
Debug :: SocketOption

-- | SO_REUSEADDR
ReuseAddr :: SocketOption

-- | SO_TYPE
Type :: SocketOption

-- | SO_ERROR
SoError :: SocketOption

-- | SO_DONTROUTE
DontRoute :: SocketOption

-- | SO_BROADCAST
Broadcast :: SocketOption

-- | SO_SNDBUF
SendBuffer :: SocketOption

-- | SO_RCVBUF
RecvBuffer :: SocketOption

-- | SO_KEEPALIVE
KeepAlive :: SocketOption

-- | SO_OOBINLINE
OOBInline :: SocketOption

-- | IP_TTL
TimeToLive :: SocketOption

-- | TCP_MAXSEG
MaxSegment :: SocketOption

-- | TCP_NODELAY
NoDelay :: SocketOption

-- | TCP_CORK
Cork :: SocketOption

-- | SO_LINGER: timeout in seconds, 0 means disabling/disabled.
Linger :: SocketOption

-- | SO_REUSEPORT
ReusePort :: SocketOption

-- | SO_RCVLOWAT
RecvLowWater :: SocketOption

-- | SO_SNDLOWAT
SendLowWater :: SocketOption

-- | SO_RCVTIMEO: this does not work at this moment.
RecvTimeOut :: SocketOption

-- | SO_SNDTIMEO: this does not work at this moment.
SendTimeOut :: SocketOption

-- | SO_USELOOPBACK
UseLoopBack :: SocketOption

-- | TCP_USER_TIMEOUT
UserTimeout :: SocketOption

-- | IPV6_V6ONLY: don't use this on OpenBSD.
IPv6Only :: SocketOption
CustomSockOpt :: (CInt, CInt) -> SocketOption

-- | Does the <a>SocketOption</a> exist on this system?
isSupportedSocketOption :: SocketOption -> Bool

-- | Get a socket option that gives an Int value. There is currently no API
--   to get e.g. the timeval socket options
getSocketOption :: Socket -> SocketOption -> IO Int

-- | Set a socket option that expects an Int value. There is currently no
--   API to set e.g. the timeval socket options
setSocketOption :: Socket -> SocketOption -> Int -> IO ()

-- | Basic type for a socket.
data Socket

-- | Create a new socket using the given address family, socket type and
--   protocol number. The address family is usually <a>AF_INET</a>,
--   <a>AF_INET6</a>, or <a>AF_UNIX</a>. The socket type is usually
--   <a>Stream</a> or <a>Datagram</a>. The protocol number is usually
--   <a>defaultProtocol</a>. If <a>AF_INET6</a> is used and the socket type
--   is <a>Stream</a> or <a>Datagram</a>, the <a>IPv6Only</a> socket option
--   is set to 0 so that both IPv4 and IPv6 can be handled with one socket.
--   
--   <pre>
--   &gt;&gt;&gt; import Network.Socket
--   
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
--   
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
--   
--   &gt;&gt;&gt; sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--   
--   &gt;&gt;&gt; Network.Socket.bind sock (addrAddress addr)
--   
--   &gt;&gt;&gt; getSocketName sock
--   127.0.0.1:5000
--   </pre>
socket :: Family -> SocketType -> ProtocolNumber -> IO Socket

-- | Get a file descriptor from a <a>Socket</a>. The socket will never be
--   closed automatically before <tt>withFdSocket</tt> completes, but it
--   may still be closed by an explicit call to <a>close</a> or
--   <a>close</a>`, either before or during the call.
--   
--   The file descriptor must not be used after <tt>withFdSocket</tt>
--   returns, because the <a>Socket</a> may have been garbage-collected,
--   invalidating the file descriptor.
--   
--   Since: 3.1.0.0
withFdSocket :: Socket -> (CInt -> IO r) -> IO r

-- | Getting a file descriptor from a socket.
--   
--   If a <a>Socket</a> is shared with multiple threads and one uses
--   <a>unsafeFdSocket</a>, unexpected issues may happen. Consider the
--   following scenario:
--   
--   1) Thread A acquires a <a>Fd</a> from <a>Socket</a> by
--   <a>unsafeFdSocket</a>.
--   
--   2) Thread B close the <a>Socket</a>.
--   
--   3) Thread C opens a new <a>Socket</a>. Unfortunately it gets the same
--   <a>Fd</a> number which thread A is holding.
--   
--   In this case, it is safer for Thread A to clone <a>Fd</a> by
--   <a>dup</a>. But this would still suffer from a race condition between
--   <a>unsafeFdSocket</a> and <a>close</a>.
--   
--   If you use this function, you need to guarantee that the <a>Socket</a>
--   does not get garbage-collected until after you finish using the file
--   descriptor. <a>touchSocket</a> can be used for this purpose.
--   
--   A safer option is to use <a>withFdSocket</a> instead.
unsafeFdSocket :: Socket -> IO CInt

-- | Ensure that the given <a>Socket</a> stays alive (i.e. not
--   garbage-collected) at the given place in the sequence of IO actions.
--   This function can be used in conjunction with <a>unsafeFdSocket</a> to
--   guarantee that the file descriptor is not prematurely freed.
--   
--   <pre>
--   fd &lt;- unsafeFdSocket sock
--   -- using fd with blocking operations such as accept(2)
--   touchSocket sock
--   </pre>
touchSocket :: Socket -> IO ()

-- | Socket is closed and a duplicated file descriptor is returned. The
--   duplicated descriptor is no longer subject to the possibility of
--   unexpectedly being closed if the socket is finalized. It is now the
--   caller's responsibility to ultimately close the duplicated file
--   descriptor.
socketToFd :: Socket -> IO CInt

-- | Currently, this is an alias of <a>unsafeFdSocket</a>.

-- | <i>Deprecated: Use withFdSocket or unsafeFdSocket instead</i>
fdSocket :: Socket -> IO CInt

-- | Creating a socket from a file descriptor.
mkSocket :: CInt -> IO Socket

-- | Turns a Socket into an <a>Handle</a>. By default, the new handle is
--   unbuffered. Use <a>hSetBuffering</a> to change the buffering.
--   
--   Note that since a <a>Handle</a> is automatically closed by a finalizer
--   when it is no longer referenced, you should avoid doing any more
--   operations on the <a>Socket</a> after calling <a>socketToHandle</a>.
--   To close the <a>Socket</a> after <a>socketToHandle</a>, call
--   <a>hClose</a> on the <a>Handle</a>.
socketToHandle :: Socket -> IOMode -> IO Handle

-- | Socket Types.
--   
--   The existence of a constructor does not necessarily imply that that
--   socket type is supported on your system: see
--   <a>isSupportedSocketType</a>.
data SocketType

-- | 0, used in getAddrInfo hints, for example
NoSocketType :: SocketType

-- | SOCK_STREAM
Stream :: SocketType

-- | SOCK_DGRAM
Datagram :: SocketType

-- | SOCK_RAW
Raw :: SocketType

-- | SOCK_RDM
RDM :: SocketType

-- | SOCK_SEQPACKET
SeqPacket :: SocketType

-- | Does the SOCK_ constant corresponding to the given SocketType exist on
--   this system?
isSupportedSocketType :: SocketType -> Bool

-- | Get the <a>SocketType</a> of an active socket.
--   
--   Since: 3.0.1.0
getSocketType :: Socket -> IO SocketType

-- | Address families.
--   
--   A constructor being present here does not mean it is supported by the
--   operating system: see <a>isSupportedFamily</a>.
data Family

-- | unspecified
AF_UNSPEC :: Family

-- | UNIX-domain
AF_UNIX :: Family

-- | Internet Protocol version 4
AF_INET :: Family

-- | Internet Protocol version 6
AF_INET6 :: Family

-- | Arpanet imp addresses
AF_IMPLINK :: Family

-- | pup protocols: e.g. BSP
AF_PUP :: Family

-- | mit CHAOS protocols
AF_CHAOS :: Family

-- | XEROX NS protocols
AF_NS :: Family

-- | nbs protocols
AF_NBS :: Family

-- | european computer manufacturers
AF_ECMA :: Family

-- | datakit protocols
AF_DATAKIT :: Family

-- | CCITT protocols, X.25 etc
AF_CCITT :: Family

-- | IBM SNA
AF_SNA :: Family

-- | DECnet
AF_DECnet :: Family

-- | Direct data link interface
AF_DLI :: Family

-- | LAT
AF_LAT :: Family

-- | NSC Hyperchannel
AF_HYLINK :: Family

-- | Apple Talk
AF_APPLETALK :: Family

-- | Internal Routing Protocol (aka AF_NETLINK)
AF_ROUTE :: Family

-- | NetBios-style addresses
AF_NETBIOS :: Family

-- | Network Interface Tap
AF_NIT :: Family

-- | IEEE 802.2, also ISO 8802
AF_802 :: Family

-- | ISO protocols
AF_ISO :: Family

-- | umbrella of all families used by OSI
AF_OSI :: Family

-- | DNA Network Management
AF_NETMAN :: Family

-- | CCITT X.25
AF_X25 :: Family

-- | AX25
AF_AX25 :: Family

-- | AFI
AF_OSINET :: Family

-- | US Government OSI
AF_GOSSIP :: Family

-- | Novell Internet Protocol
AF_IPX :: Family

-- | eXpress Transfer Protocol (no AF)
Pseudo_AF_XTP :: Family

-- | Common Trace Facility
AF_CTF :: Family

-- | Wide Area Network protocols
AF_WAN :: Family

-- | SGI Data Link for DLPI
AF_SDL :: Family

-- | Netware
AF_NETWARE :: Family

-- | NDD
AF_NDD :: Family

-- | Debugging use only
AF_INTF :: Family

-- | connection-oriented IP, aka ST II
AF_COIP :: Family

-- | Computer Network Technology
AF_CNT :: Family

-- | Help Identify RTIP packets
Pseudo_AF_RTIP :: Family

-- | Help Identify PIP packets
Pseudo_AF_PIP :: Family

-- | Simple Internet Protocol
AF_SIP :: Family

-- | Integrated Services Digital Network
AF_ISDN :: Family

-- | Internal key-management function
Pseudo_AF_KEY :: Family

-- | native ATM access
AF_NATM :: Family

-- | ARP (RFC 826)
AF_ARP :: Family

-- | Used by BPF to not rewrite hdrs in iface output
Pseudo_AF_HDRCMPLT :: Family

-- | ENCAP
AF_ENCAP :: Family

-- | Link layer interface
AF_LINK :: Family

-- | Link layer interface
AF_RAW :: Family

-- | raw interface
AF_RIF :: Family

-- | Amateur radio NetROM
AF_NETROM :: Family

-- | multiprotocol bridge
AF_BRIDGE :: Family

-- | ATM PVCs
AF_ATMPVC :: Family

-- | Amateur Radio X.25 PLP
AF_ROSE :: Family

-- | Netbeui 802.2LLC
AF_NETBEUI :: Family

-- | Security callback pseudo AF
AF_SECURITY :: Family

-- | Packet family
AF_PACKET :: Family

-- | Ash
AF_ASH :: Family

-- | Acorn Econet
AF_ECONET :: Family

-- | ATM SVCs
AF_ATMSVC :: Family

-- | IRDA sockets
AF_IRDA :: Family

-- | PPPoX sockets
AF_PPPOX :: Family

-- | Wanpipe API sockets
AF_WANPIPE :: Family

-- | bluetooth sockets
AF_BLUETOOTH :: Family

-- | Controller Area Network
AF_CAN :: Family

-- | Does the AF_ constant corresponding to the given family exist on this
--   system?
isSupportedFamily :: Family -> Bool

-- | Converting <a>Family</a> to <a>CInt</a>.
packFamily :: Family -> CInt

-- | Converting <a>CInt</a> to <a>Family</a>.
unpackFamily :: CInt -> Family

-- | Protocol number.
type ProtocolNumber = CInt

-- | This is the default protocol for a given service.
--   
--   <pre>
--   &gt;&gt;&gt; defaultProtocol
--   0
--   </pre>
defaultProtocol :: ProtocolNumber

-- | Socket addresses. The existence of a constructor does not necessarily
--   imply that that socket address type is supported on your system: see
--   <a>isSupportedSockAddr</a>.
data SockAddr
SockAddrInet :: !PortNumber -> !HostAddress -> SockAddr
SockAddrInet6 :: !PortNumber -> !FlowInfo -> !HostAddress6 -> !ScopeID -> SockAddr

-- | The path must have fewer than 104 characters. All of these characters
--   must have code points less than 256.
SockAddrUnix :: String -> SockAddr

-- | Is the socket address type supported on this system?
isSupportedSockAddr :: SockAddr -> Bool

-- | Getting peer's <a>SockAddr</a>.
getPeerName :: Socket -> IO SockAddr

-- | Getting my <a>SockAddr</a>.
getSocketName :: Socket -> IO SockAddr

-- | The raw network byte order number is read using host byte order.
--   Therefore on little-endian architectures the byte order is swapped.
--   For example <tt>127.0.0.1</tt> is represented as <tt>0x0100007f</tt>
--   on little-endian hosts and as <tt>0x7f000001</tt> on big-endian hosts.
--   
--   For direct manipulation prefer <a>hostAddressToTuple</a> and
--   <a>tupleToHostAddress</a>.
type HostAddress = Word32

-- | Converts <a>HostAddress</a> to representation-independent IPv4
--   quadruple. For example for <tt>127.0.0.1</tt> the function will return
--   <tt>(0x7f, 0, 0, 1)</tt> regardless of host endianness.
hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)

-- | Converts IPv4 quadruple to <a>HostAddress</a>.
tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress

-- | Independent of endianness. For example <tt>::1</tt> is stored as
--   <tt>(0, 0, 0, 1)</tt>.
--   
--   For direct manipulation prefer <a>hostAddress6ToTuple</a> and
--   <a>tupleToHostAddress6</a>.
type HostAddress6 = (Word32, Word32, Word32, Word32)

-- | Converts <a>HostAddress6</a> to representation-independent IPv6
--   octuple.
hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16)

-- | Converts IPv6 octuple to <a>HostAddress6</a>.
tupleToHostAddress6 :: (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16) -> HostAddress6

-- | Flow information.
type FlowInfo = Word32

-- | Scope identifier.
type ScopeID = Word32

-- | Returns the index corresponding to the interface name.
--   
--   Since 2.7.0.0.
ifNameToIndex :: String -> IO (Maybe Int)

-- | Returns the interface name corresponding to the index.
--   
--   Since 2.7.0.0.
ifIndexToName :: Int -> IO (Maybe String)

-- | Port number. Use the <tt>Num</tt> instance (i.e. use a literal) to
--   create a <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber

-- | Default port number.
--   
--   <pre>
--   &gt;&gt;&gt; defaultPort
--   0
--   </pre>
defaultPort :: PortNumber

-- | Getting the port of socket.
socketPortSafe :: Socket -> IO (Maybe PortNumber)

-- | Getting the port of socket. <a>IOError</a> is thrown if a port is not
--   available.
socketPort :: Socket -> IO PortNumber

-- | Whether or not UNIX-domain sockets are available.
--   
--   Since 2.7.0.0.
isUnixDomainSocketAvailable :: Bool

-- | Build a pair of connected socket objects. For portability, use this
--   function in the case where <a>isUnixDomainSocketAvailable</a> is
--   <a>True</a> and specify <a>AF_UNIX</a> to the first argument.
socketPair :: Family -> SocketType -> ProtocolNumber -> IO (Socket, Socket)

-- | Send a file descriptor over a UNIX-domain socket. Use this function in
--   the case where <a>isUnixDomainSocketAvailable</a> is <a>True</a>.
sendFd :: Socket -> CInt -> IO ()

-- | Receive a file descriptor over a UNIX-domain socket. Note that the
--   resulting file descriptor may have to be put into non-blocking mode in
--   order to be used safely. See <a>setNonBlockIfNeeded</a>. Use this
--   function in the case where <a>isUnixDomainSocketAvailable</a> is
--   <a>True</a>.
recvFd :: Socket -> IO CInt

-- | Getting process ID, user ID and group ID for UNIX-domain sockets.
--   
--   This is implemented with SO_PEERCRED on Linux and getpeereid() on BSD
--   variants. Unfortunately, on some BSD variants getpeereid() returns
--   unexpected results, rather than an error, for AF_INET sockets. It is
--   the user's responsibility to make sure that the socket is a
--   UNIX-domain socket. Also, on some BSD variants, getpeereid() does not
--   return credentials for sockets created via <a>socketPair</a>, only
--   separately created and then explicitly connected UNIX-domain sockets
--   work on such systems.
--   
--   Since 2.7.0.0.
getPeerCredential :: Socket -> IO (Maybe CUInt, Maybe CUInt, Maybe CUInt)

-- | Resolve an address to a host or service name. This function is
--   protocol independent. The list of <a>NameInfoFlag</a> values controls
--   query behaviour.
--   
--   If a host or service's name cannot be looked up, then the numeric form
--   of the address or service will be returned.
--   
--   If the query fails, this function throws an IO exception.
--   
--   <pre>
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just defaultHints) (Just "127.0.0.1") (Just "http")
--   
--   &gt;&gt;&gt; getNameInfo [NI_NUMERICHOST, NI_NUMERICSERV] True True $ addrAddress addr
--   (Just "127.0.0.1",Just "80")
--   </pre>
getNameInfo :: [NameInfoFlag] -> Bool -> Bool -> SockAddr -> IO (Maybe HostName, Maybe ServiceName)

-- | Flags that control the querying behaviour of <a>getNameInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-30</a>
data NameInfoFlag

-- | Resolve a datagram-based service name. This is required only for the
--   few protocols that have different port numbers for their
--   datagram-based versions than for their stream-based versions.
NI_DGRAM :: NameInfoFlag

-- | If the hostname cannot be looked up, an IO error is thrown.
NI_NAMEREQD :: NameInfoFlag

-- | If a host is local, return only the hostname part of the FQDN.
NI_NOFQDN :: NameInfoFlag

-- | The name of the host is not looked up. Instead, a numeric
--   representation of the host's address is returned. For an IPv4 address,
--   this will be a dotted-quad string. For IPv6, it will be
--   colon-separated hexadecimal.
NI_NUMERICHOST :: NameInfoFlag

-- | The name of the service is not looked up. Instead, a numeric
--   representation of the service is returned.
NI_NUMERICSERV :: NameInfoFlag

-- | Set the close_on_exec flag on Unix. On Windows, nothing is done.
--   
--   Since 2.7.0.0.
setCloseOnExecIfNeeded :: CInt -> IO ()

-- | Get the close_on_exec flag. On Windows, this function always returns
--   <a>False</a>.
--   
--   Since 2.7.0.0.
getCloseOnExec :: CInt -> IO Bool

-- | Set the nonblocking flag on Unix. On Windows, nothing is done.
setNonBlockIfNeeded :: CInt -> IO ()

-- | Get the nonblocking flag. On Windows, this function always returns
--   <a>False</a>.
--   
--   Since 2.7.0.0.
getNonBlock :: CInt -> IO Bool

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
sendBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   The return value is the length of received data. Zero means EOF.
--   Historical note: Version 2.8.x.y or earlier, an EOF error was thrown.
--   This was changed in version 3.0.
recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendBufTo :: Socket -> Ptr a -> Int -> SockAddr -> IO Int

-- | Receive data from the socket, writing it into buffer instead of
--   creating a new string. The socket need not be in a connected state.
--   Returns <tt>(nbytes, address)</tt> where <tt>nbytes</tt> is the number
--   of bytes received and <tt>address</tt> is a <a>SockAddr</a>
--   representing the address of the sending socket.
--   
--   If the first return value is zero, it means EOF.
--   
--   For <a>Stream</a> sockets, the second return value would be invalid.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)
recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)

-- | This is the value of SOMAXCONN, typically 128. 128 is good enough for
--   normal network servers but is too small for high performance servers.
maxListenQueue :: Int


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket
--   import Network.Socket.ByteString.Lazy
--   import Prelude hiding (getContents)
--   </pre>
module Network.Socket.ByteString.Lazy
send :: Socket -> ByteString -> IO Int64
sendAll :: Socket -> ByteString -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   Data is received on demand, in chunks; each chunk will be sized to
--   reflect the amount of data received by individual <a>recv</a> calls.
--   
--   All remaining data from the socket is consumed. When there is no more
--   data to be received, the receiving side of the socket is shut down. If
--   there is an error and an exception is thrown, the socket is not shut
--   down.
getContents :: Socket -> IO ByteString

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the received
--   data is longer than the specified length, it may be discarded
--   depending on the type of socket. This function may block until a
--   message arrives.
--   
--   If there is no more data to be received, returns an empty
--   <a>ByteString</a>.
recv :: Socket -> Int64 -> IO ByteString
