-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Make composable workflows
--   
--   See README at <a>https://github.com/tweag/funflow</a>
@package funflow
@version 2.0.0

module Funflow.Config
type ConfigKey = Text
type ConfigMap = Object
type EnvConfigMap = HashMap Text String
data ExternalConfig
ExternalConfig :: ConfigMap -> EnvConfigMap -> ExternalConfig
[fileConfig] :: ExternalConfig -> ConfigMap
[envConfig] :: ExternalConfig -> EnvConfigMap

-- | A value which is intended to be populated using an external source
--   (e.g. a config file)
data Configurable a

-- | Define a configurable which will be loaded from a config file using
--   the given key
[ConfigFromFile] :: FromJSON a => ConfigKey -> Configurable a

-- | Define a configurable which will be loaded from the specified
--   environment variable
[ConfigFromEnv] :: FromJSON a => ConfigKey -> Configurable a

-- | A literal value which does not need to be loaded from an external
--   config source
[Literal] :: a -> Configurable a

-- | Render a Configurable into a Literal value using a set of external
--   configurations, returning an error message if rendering failed.
render :: forall a. Configurable a -> ExternalConfig -> Either String (Configurable a)

-- | Gets the config key for a configurable value, if it exists.
getConfigKey :: Configurable a -> Maybe ConfigKey

-- | Stores ConfigKey values by their declared sources.
data ConfigKeysBySource
ConfigKeysBySource :: HashSet Text -> HashSet Text -> ConfigKeysBySource
[fileConfigKeys] :: ConfigKeysBySource -> HashSet Text
[envConfigKeys] :: ConfigKeysBySource -> HashSet Text

-- | Get the key of a <a>Configurable</a> as a <a>ConfigKeysBySource</a>.
configKeyBySource :: Configurable a -> ConfigKeysBySource

-- | Get a list of any ConfigKeys which don't exist in their corresponding
--   field in the providedExternalConfig
missing :: ExternalConfig -> ConfigKeysBySource -> [ConfigKey]

-- | Construct an HashMap containing specified environment variable values.
readEnv :: MonadIO m => ConfigKey -> m (HashMap Text String)

-- | Convenience function for calling readEnv on a list of ConfigKeys
readEnvs :: MonadIO m => [ConfigKey] -> m (HashMap Text String)

-- | Construct a HashMap containing the content of a yaml file. Is just an
--   Alias for <a>decodeFileThrow</a>.
readYamlFileConfig :: (MonadIO m, FromJSON a) => FilePath -> m a
instance GHC.Show.Show Funflow.Config.ExternalConfig
instance GHC.Show.Show Funflow.Config.ConfigKeysBySource
instance GHC.Base.Semigroup Funflow.Config.ConfigKeysBySource
instance GHC.Base.Monoid Funflow.Config.ConfigKeysBySource

module Funflow.Run.Orphans
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Docker.API.Client.Internal.Types.ContainerSpec
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Docker.API.Client.Internal.Types.DockerClientError
instance GHC.Exception.Type.Exception Docker.API.Client.Internal.Types.DockerClientError


-- | Run commands using Docker
module Funflow.Tasks.Docker

-- | Configure what task to run in Docker
data DockerTaskConfig
DockerTaskConfig :: Text -> Text -> [Arg] -> DockerTaskConfig

-- | The name of the docker image
[image] :: DockerTaskConfig -> Text

-- | The command to run
[command] :: DockerTaskConfig -> Text

-- | The arguments to pass to the command run inside of the container
[args] :: DockerTaskConfig -> [Arg]
data DockerTask i o
[DockerTask] :: DockerTaskConfig -> DockerTask DockerTaskInput Item

-- | Input to a Docker task to finalize its configuration
data DockerTaskInput
DockerTaskInput :: [VolumeBinding] -> Map String Text -> DockerTaskInput

-- | Input items to mount on the container
[inputBindings] :: DockerTaskInput -> [VolumeBinding]

-- | A map representing how to fill the argument placeholders (placeholder
--   label -&gt; argument value)
[argsVals] :: DockerTaskInput -> Map String Text

-- | Represent how to bind a directory from cas-store (<tt>CS.Item</tt>) to
--   a container internal file system
data VolumeBinding
VolumeBinding :: Item -> Path Abs Dir -> VolumeBinding
[item] :: VolumeBinding -> Item
[mount] :: VolumeBinding -> Path Abs Dir

-- | Represent an argument to pass to the command run inside of a Docker
--   container
data Arg

-- | Raw text argument
Arg :: Configurable Text -> Arg

-- | A placeholder for an argument to be passed as runtime input to the
--   task (filled by <tt>argsVals</tt>)
Placeholder :: String -> Arg

-- | Renders an Arg with external configurations
renderArg :: ExternalConfig -> Arg -> Either String Arg

-- | Extracts a ConfigKey from an Arg, if it exists.
getIdFromArg :: Arg -> Maybe ConfigKeysBySource
instance GHC.Show.Show Funflow.Tasks.Docker.VolumeBinding
instance GHC.Classes.Ord Funflow.Tasks.Docker.VolumeBinding
instance GHC.Classes.Eq Funflow.Tasks.Docker.VolumeBinding
instance GHC.Show.Show Funflow.Tasks.Docker.DockerTaskInput
instance GHC.Classes.Eq Funflow.Tasks.Docker.DockerTaskInput
instance GHC.Base.Semigroup Funflow.Tasks.Docker.DockerTaskInput
instance GHC.Base.Monoid Funflow.Tasks.Docker.DockerTaskInput
instance Data.String.IsString Funflow.Tasks.Docker.Arg


-- | Run a pure function or an IO monadic continuation
module Funflow.Tasks.Simple
data SimpleTask i o
[PureTask] :: (i -> o) -> SimpleTask i o
[IOTask] :: (i -> IO o) -> SimpleTask i o


-- | Run a pure function or an IO monadic continuation
module Funflow.Tasks.Store
data StoreTask i o
[PutDir] :: StoreTask (Path Abs Dir) Item
[GetDir] :: StoreTask Item (Path Abs Dir)

module Funflow.Type.Family.List
type Ã˜ = '[]
type (:<) = '(:)
infixr 5 :<

-- | Type-level singleton list.
type Only a = '[a]
type family Null (as :: [k]) :: Bool

-- | Appends two type-level lists.
type family (as :: [k]) ++ (bs :: [k]) :: [k]
infixr 5 ++
type family Concat (ls :: [[k]]) :: [k]

module Funflow.Flow

-- | Flow is the main type of Funflow. It is a task that takes an input
--   value of type <tt>input</tt> and produces an output value of type
--   <tt>output</tt>. It can use any named task (strand) that is defined in
--   <tt>RequiredStrands</tt>.
type Flow input output = ExtendedFlow '[] input output

-- | Allows to add other strands on top of the existing strands used by
--   funflow's <tt>Flow</tt> defined by <tt>RequiredStrands</tt>. Thoses
--   additional strands should be weaved before passing the resulting loose
--   rope to runFlow. See the advanced tutorial on extending funflow's
--   <tt>Flow</tt>.
type ExtendedFlow additionalStrands input output = forall m. (MonadIO m) => AnyRopeWith (additionalStrands ++ RequiredStrands) (RequiredCore m) input output

-- | The constraints on the set of "strands" These will be "interpreted"
--   into "core tasks" (which have contraints defined below).
type RequiredStrands = '[ '("simple", SimpleTask), '("store", StoreTask), '("docker", DockerTask)]

-- | The class constraints on the "core task". The "core task" is the task
--   used to run any kind of "binary task" ("strand")
type RequiredCore m = '[Arrow, ArrowChoice, ThrowEffect SomeException, TryEffect SomeException, ThrowEffect StringException, TryEffect StringException, ThrowEffect DockerClientError, TryEffect DockerClientError, HasKleisli m, ProvidesCaching]

-- | Allows to register on which strand a binary task should be
class IsFlow binEff
toFlow :: IsFlow binEff => binEff i o -> Flow i o

-- | Make a flow from a pure function
pureFlow :: (i -> o) -> Flow i o

-- | Make a flow from an IO monad
ioFlow :: (i -> IO o) -> Flow i o

-- | Make a flow from the configuration of a Docker task
dockerFlow :: DockerTaskConfig -> Flow DockerTaskInput Item

-- | Make a flow to put a directory into the content store
putDirFlow :: Flow (Path Abs Dir) Item

-- | Make a flow to get the absolute path of the directory storing the data
--   of an item in the content store
getDirFlow :: Flow Item (Path Abs Dir)

-- | Make a flow that throws an exception with a message
throwStringFlow :: Flow String ()

-- | Return a result at the end of a flow
returnFlow :: Flow a a
instance Funflow.Flow.IsFlow Funflow.Tasks.Simple.SimpleTask
instance Funflow.Flow.IsFlow Funflow.Tasks.Docker.DockerTask
instance Funflow.Flow.IsFlow Funflow.Tasks.Store.StoreTask

module System.Directory.Funflow

-- | Move all the directories and files from a source directory to a target
--   directory
moveDirectoryContent :: Path Abs Dir -> Path Abs Dir -> IO ()


-- | This module defines how to run your flows
module Funflow.Run

-- | Run a flow with the default configuration
runFlow :: LooseRopeWith RequiredStrands (RequiredCore IO) input output -> input -> IO output

-- | Run a flow, parsing any required <a>Configurable</a> values from their
--   respective sources. This flow executor includes interpreters for the
--   following tasks:
--   
--   <ul>
--   <li><a>SimpleTask</a></li>
--   <li><a>StoreTask</a></li>
--   <li><a>DockerTask</a> - The container is run with working directory
--   '/workdir'. Files written to this directory are included in the
--   tasks's <a>Item</a> output.</li>
--   </ul>
runFlowWithConfig :: RunFlowConfig -> LooseRopeWith RequiredStrands (RequiredCore IO) input output -> input -> IO output

-- | Flow execution configuration
data RunFlowConfig
RunFlowConfig :: Path Abs Dir -> Maybe (Path Abs File) -> RunFlowConfig
[storePath] :: RunFlowConfig -> Path Abs Dir
[configFile] :: RunFlowConfig -> Maybe (Path Abs File)


-- | Composable computational workflows. See
--   <a>https://github.com/tweag/funflow</a>
--   
--   This module re-exports other modules for conveniency.
module Funflow

-- | Left-to-right composition
(>>>) :: forall k cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Any rope whose core provides caching can run cached tasks. The task is
--   identified by an explicit identifier
caching :: forall (core :: Type -> Type -> Type) ident a b (r :: RopeRec) (mantle :: [Strand]). (Arrow core, ProvidesCaching core, ContentHashable IO ident, ContentHashable IO a, Store b) => ident -> Rope r mantle core a b -> Rope r mantle core a b
tryE :: TryEffect ex eff => eff a b -> eff a (Either ex b)
throwE :: ThrowEffect ex eff => eff (Either ex b) b


-- | Aliases which behave similarly to their funflow 1.x counterparts.
module Funflow.Compat
stepIO :: (i -> IO o) -> Flow i o
stepIO' :: (Show i, ContentHashable IO i, ContentHashable IO ident, Store o) => ident -> (i -> IO o) -> Flow i o
docker :: DockerTaskConfig -> Flow DockerTaskInput Item
putInStore :: Flow (Path Abs Dir) Item
getFromStore :: Flow Item (Path Abs Dir)
