-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support library for Template Haskell
--   
--   This package provides modules containing facilities for manipulating
--   Haskell source code using Template Haskell.
--   
--   See <a>http://www.haskell.org/haskellwiki/Template_Haskell</a> for
--   more information.
@package template-haskell
@version 2.16.0.0


-- | Language extensions known to GHC
module Language.Haskell.TH.LanguageExtensions

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name
mkNameS :: String -> Name

-- | Discard the type annotation and produce a plain Template Haskell
--   expression
--   
--   Levity-polymorphic since <i>template-haskell-2.16.0.0</i>.
unTypeQ :: forall (r :: RuntimeRep) (a :: TYPE r). Q (TExp a) -> Q Exp

-- | Annotate the Template Haskell expression with a type
--   
--   This is unsafe because GHC cannot check for you that the expression
--   really does have the type you claim it has.
--   
--   Levity-polymorphic since <i>template-haskell-2.16.0.0</i>.
unsafeTExpCoerce :: forall (r :: RuntimeRep) (a :: TYPE r). Q Exp -> Q (TExp a)
liftString :: String -> Q Exp

-- | A <a>Lift</a> instance can have any of its values turned into a
--   Template Haskell expression. This is needed when a value used within a
--   Template Haskell quotation is bound outside the Oxford brackets
--   (<tt>[| ... |]</tt> or <tt>[|| ... ||]</tt>) but not at the top level.
--   As an example:
--   
--   <pre>
--   add1 :: Int -&gt; Q (TExp Int)
--   add1 x = [|| x + 1 ||]
--   </pre>
--   
--   Template Haskell has no way of knowing what value <tt>x</tt> will take
--   on at splice-time, so it requires the type of <tt>x</tt> to be an
--   instance of <a>Lift</a>.
--   
--   A <a>Lift</a> instance must satisfy <tt>$(lift x) ≡ x</tt> and
--   <tt>$$(liftTyped x) ≡ x</tt> for all <tt>x</tt>, where <tt>$(...)</tt>
--   and <tt>$$(...)</tt> are Template Haskell splices. It is additionally
--   expected that <tt><a>lift</a> x ≡ <a>unTypeQ</a> (<a>liftTyped</a>
--   x)</tt>.
--   
--   <a>Lift</a> instances can be derived automatically by use of the
--   <tt>-XDeriveLift</tt> GHC language extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveLift #-}
--   module Foo where
--   
--   import Language.Haskell.TH.Syntax
--   
--   data Bar a = Bar1 a (Bar a) | Bar2 String
--     deriving Lift
--   </pre>
--   
--   Levity-polymorphic since <i>template-haskell-2.16.0.0</i>.
class Lift (t :: TYPE r)

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: Lift t => t -> Q Exp

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: (Lift t, r ~ 'LiftedRep) => t -> Q Exp

-- | Turn a value into a Template Haskell typed expression, suitable for
--   use in a typed splice.
liftTyped :: Lift t => t -> Q (TExp t)
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (1,)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   TupE [Just (LitE (IntegerL 1)),Nothing]
--   </pre>
TupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (# 'c', #)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   UnboxedTupE [Just (LitE (CharL 'c')),Nothing]
--   </pre>
UnboxedTupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { mdo { x &lt;- e1 y; y &lt;- e2 x; } }
--   </pre>
MDoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
newtype Q a
Q :: (forall m. Quasi m => m a) -> Q a
[unQ] :: Q a -> forall m. Quasi m => m a

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;type&gt;
--   </pre>
ForallVisT :: [TyVarBndr] -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (#,#), (#,,#), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   (#|#), (#||#), etc.
--   </pre>
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { type TypeRep :: k -&gt; Type }
--   </pre>
KiSigD :: Name -> Kind -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {-# INLINE [1] foo #-} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { data family T a b c :: * }
--   </pre>
DataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | <pre>
--   { type family T a b c = (r :: *) | r -&gt; a b }
--   </pre>
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | <tt>{ pattern P v1 v2 .. vn &lt;- p }</tt> unidirectional or <tt>{
--   pattern P v1 v2 .. vn = p }</tt> implicit bidirectional or <tt>{
--   pattern P v1 v2 .. vn &lt;- p where P v1 v2 .. vn = e }</tt> explicit
--   bidirectional
--   
--   also, besides prefix pattern synonyms, both infix and record pattern
--   synonyms are supported. See <a>PatSynArgs</a> for details
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Represents an expression which has type <tt>a</tt>. Built on top of
--   <a>Exp</a>, typed expressions allow for type-safe splicing via:
--   
--   <ul>
--   <li>typed quotes, written as <tt>[|| ... ||]</tt> where <tt>...</tt>
--   is an expression; if that expression has type <tt>a</tt>, then the
--   quotation has type <tt><a>Q</a> (<a>TExp</a> a)</tt></li>
--   <li>typed splices inside of typed quotes, written as <tt>$$(...)</tt>
--   where <tt>...</tt> is an arbitrary expression of type <tt><a>Q</a>
--   (<a>TExp</a> a)</tt></li>
--   </ul>
--   
--   Traditional expression quotes and splices let us construct ill-typed
--   expressions:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [| True == $( [| "foo" |] ) |]
--   GHC.Types.True GHC.Classes.== "foo"
--   
--   &gt;&gt;&gt; GHC.Types.True GHC.Classes.== "foo"
--   &lt;interactive&gt; error:
--       • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
--       • In the second argument of ‘(==)’, namely ‘"foo"’
--         In the expression: True == "foo"
--         In an equation for ‘it’: it = True == "foo"
--   </pre>
--   
--   With typed expressions, the type error occurs when <i>constructing</i>
--   the Template Haskell expression:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [|| True == $$( [|| "foo" ||] ) ||]
--   &lt;interactive&gt; error:
--       • Couldn't match type ‘[Char]’ with ‘Bool’
--         Expected type: Q (TExp Bool)
--           Actual type: Q (TExp [Char])
--       • In the Template Haskell quotation [|| "foo" ||]
--         In the expression: [|| "foo" ||]
--         In the Template Haskell splice $$([|| "foo" ||])
--   </pre>
newtype TExp (a :: TYPE (r :: RuntimeRep))
TExp :: Exp -> TExp (a :: TYPE (r :: RuntimeRep))

-- | Underlying untyped Template Haskell expression
[unType] :: TExp (a :: TYPE (r :: RuntimeRep)) -> Exp

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlappable</a> and <a>Overlappable</a>, and pick an
--   arbitrary one if multiple choices are available.
Incoherent :: Overlap

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr -> FamilyResultSig
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>VarStrictType</a> has
--   been replaced by <a>VarBangType</a>.
type VarStrictType = VarBangType

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>StrictType</a> has been
--   replaced by <a>BangType</a>.
type StrictType = BangType

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
type VarBangType = (Name, Bang, Type)
type BangType = (Bang, Type)
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness that the compiler
--   chooses for a data constructor field, which may be different from what
--   is written in source code. See <a>reifyConStrictness</a> for more
--   information.
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness
type Cxt = [Pred] " @(Eq a, Ord b)@"
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body

-- | Raw bytes embedded into the binary.
--   
--   Avoid using Bytes constructor directly as it is likely to change in
--   the future. Use helpers such as <tt>mkBytes</tt> in
--   Language.Haskell.TH.Lib instead.
data Bytes
Bytes :: ForeignPtr Word8 -> Word -> Word -> Bytes

-- | Pointer to the data
[bytesPtr] :: Bytes -> ForeignPtr Word8

-- | Offset from the pointer
[bytesOffset] :: Bytes -> Word

-- | Number of bytes Maybe someday: , bytesAlignement :: Word -- ^
--   Alignement constraint , bytesReadOnly :: Bool -- ^ Shall we embed into
--   a read-only -- section or not , bytesInitialized :: Bool -- ^ False:
--   only use <a>bytesSize</a> to allocate -- an uninitialized region
[bytesSize] :: Bytes -> Word
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type <a>Addr#</a>
StringPrimL :: [Word8] -> Lit

-- | Some raw bytes, type <a>Addr#</a>:
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
data Fixity
Fixity :: Int -> FixityDirection -> Fixity

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info
type CharPos = (Int, Int) " Line and character position"
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs

-- | <tt>Uniq</tt> is used by GHC to distinguish names from each other.
type Uniq = Integer
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: !Uniq -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: !Uniq -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
newtype OccName
OccName :: String -> OccName

-- | Obtained from <a>reifyModule</a> and <a>thisModule</a>.
data Module
Module :: PkgName -> ModName -> Module
newtype PkgName
PkgName :: String -> PkgName
newtype ModName
ModName :: String -> ModName
class (MonadIO m, MonadFail m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyFixity :: Quasi m => Name -> m (Maybe Fixity)
qReifyType :: Quasi m => Name -> m Type
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qReifyConStrictness :: Quasi m => Name -> m [DecidedStrictness]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTempFile :: Quasi m => String -> m FilePath
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddForeignFilePath :: Quasi m => ForeignSrcLang -> String -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qAddCorePlugin :: Quasi m => String -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
qIsExtEnabled :: Quasi m => Extension -> m Bool
qExtsEnabled :: Quasi m => m [Extension]
badIO :: String -> IO a
counter :: IORef Uniq
runQ :: Quasi m => Q a -> m a

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyType nm</tt> attempts to find the type or kind of
--   <tt>nm</tt>. For example, <tt>reifyType 'not</tt> returns <tt>Bool
--   -&gt; Bool</tt>, and <tt>reifyType ''Bool</tt> returns <tt>Type</tt>.
--   This works even if there's no explicit signature and the type or kind
--   is inferred.
reifyType :: Name -> Q Type

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | The location at which this computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | Obtain a temporary file path with the given suffix. The compiler will
--   delete this file after compilation.
addTempFile :: String -> Q FilePath

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()


-- | <i>Deprecated: Use <a>addForeignSource</a> instead</i>
addForeignFile :: ForeignSrcLang -> String -> Q ()

-- | Emit a foreign file which will be compiled and linked to the object
--   for the current module. Currently only languages that can be compiled
--   with the C compiler are supported, and the flags passed as part of
--   -optc will be also applied to the C compiler invocation that will
--   compile them.
--   
--   Note that for non-C languages (for example C++) <tt>extern
--   <a>C</a></tt> directives must be used to get symbols that we can
--   access from Haskell.
--   
--   To get better errors, it is recommended to use #line pragmas when
--   emitting C files, e.g.
--   
--   <pre>
--   {-# LANGUAGE CPP #-}
--   ...
--   addForeignSource LangC $ unlines
--     [ "#line " ++ show (562 + 1) ++ " " ++ show "libraries/template-haskell/./Language/Haskell/TH/Syntax.hs"
--     , ...
--     ]
--   </pre>
addForeignSource :: ForeignSrcLang -> String -> Q ()

-- | Same as <a>addForeignSource</a>, but expects to receive a path
--   pointing to the foreign file instead of a <a>String</a> of its
--   contents. Consider using this in conjunction with <a>addTempFile</a>.
--   
--   This is a good alternative to <a>addForeignSource</a> when you are
--   trying to directly link in an object file.
addForeignFilePath :: ForeignSrcLang -> FilePath -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
--   
--   The finalizer is given the local type environment at the splice point.
--   Thus <a>reify</a> is able to find the local definitions when executed
--   inside the finalizer.
addModFinalizer :: Q () -> Q ()

-- | Adds a core plugin to the compilation pipeline.
--   
--   <tt>addCorePlugin m</tt> has almost the same effect as passing
--   <tt>-fplugin=m</tt> to ghc in the command line. The major difference
--   is that the plugin module <tt>m</tt> must not belong to the current
--   package. When TH executes, it is too late to tell the compiler that we
--   needed to compile first a plugin module in the current package.
addCorePlugin :: String -> Q ()

-- | Get state from the <a>Q</a> monad. Note that the state is local to the
--   Haskell module in which the Template Haskell expression is executed.
getQ :: Typeable a => Q (Maybe a)

-- | Replace the state in the <a>Q</a> monad. Note that the state is local
--   to the Haskell module in which the Template Haskell expression is
--   executed.
putQ :: Typeable a => a -> Q ()

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
nonemptyName :: Name

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: forall a k q. Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>liftData</a> is a variant of <a>lift</a> in the <a>Lift</a> type
--   class which works for any type with a <a>Data</a> instance.
liftData :: Data a => a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
mkModName :: String -> ModName
modString :: ModName -> String
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
mkOccName :: String -> OccName
occString :: OccName -> String

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name
mk_tup_name :: Int -> NameSpace -> Bool -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
cmpEq :: Ordering -> Bool
thenCmp :: Ordering -> Ordering -> Ordering

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModName
instance Data.Data.Data Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModName
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PkgName
instance Data.Data.Data Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PkgName
instance GHC.Show.Show Language.Haskell.TH.Syntax.PkgName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Module
instance Data.Data.Data Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Module
instance GHC.Show.Show Language.Haskell.TH.Syntax.Module
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.OccName
instance Data.Data.Data Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.OccName
instance GHC.Show.Show Language.Haskell.TH.Syntax.OccName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameSpace
instance Data.Data.Data Language.Haskell.TH.Syntax.NameSpace
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameSpace
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameFlavour
instance Data.Data.Data Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Name
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Name
instance Data.Data.Data Language.Haskell.TH.Syntax.Name
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Loc
instance Data.Data.Data Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Loc
instance GHC.Show.Show Language.Haskell.TH.Syntax.Loc
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModuleInfo
instance Data.Data.Data Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FixityDirection
instance Data.Data.Data Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Show.Show Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Fixity
instance Data.Data.Data Language.Haskell.TH.Syntax.Fixity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Fixity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bytes
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bytes
instance Data.Data.Data Language.Haskell.TH.Syntax.Bytes
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bytes
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bytes
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Lit
instance Data.Data.Data Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Lit
instance GHC.Show.Show Language.Haskell.TH.Syntax.Lit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Overlap
instance Data.Data.Data Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Overlap
instance GHC.Show.Show Language.Haskell.TH.Syntax.Overlap
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FunDep
instance Data.Data.Data Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FunDep
instance GHC.Show.Show Language.Haskell.TH.Syntax.FunDep
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Callconv
instance Data.Data.Data Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Callconv
instance GHC.Show.Show Language.Haskell.TH.Syntax.Callconv
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Safety
instance Data.Data.Data Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Safety
instance GHC.Show.Show Language.Haskell.TH.Syntax.Safety
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Inline
instance Data.Data.Data Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Inline
instance GHC.Show.Show Language.Haskell.TH.Syntax.Inline
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleMatch
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Phases
instance Data.Data.Data Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Phases
instance GHC.Show.Show Language.Haskell.TH.Syntax.Phases
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnTarget
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceUnpackedness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DecidedStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bang
instance Data.Data.Data Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bang
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynArgs
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.InjectivityAnn
instance Data.Data.Data Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Show.Show Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyLit
instance Data.Data.Data Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyLit
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyLit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Role
instance Data.Data.Data Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Role
instance GHC.Show.Show Language.Haskell.TH.Syntax.Role
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnLookup
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyVarBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Type
instance Data.Data.Data Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Type
instance GHC.Show.Show Language.Haskell.TH.Syntax.Type
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FamilyResultSig
instance Data.Data.Data Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Show.Show Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TypeFamilyHead
instance Data.Data.Data Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Show.Show Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Con
instance Data.Data.Data Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Con
instance GHC.Show.Show Language.Haskell.TH.Syntax.Con
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Foreign
instance Data.Data.Data Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Foreign
instance GHC.Show.Show Language.Haskell.TH.Syntax.Foreign
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TySynEqn
instance Data.Data.Data Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Show.Show Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivStrategy
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivClause
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivClause
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivClause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pragma
instance Data.Data.Data Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pragma
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pragma
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pat
instance Data.Data.Data Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pat
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pat
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Match
instance Data.Data.Data Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Match
instance GHC.Show.Show Language.Haskell.TH.Syntax.Match
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Range
instance Data.Data.Data Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Range
instance GHC.Show.Show Language.Haskell.TH.Syntax.Range
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Exp
instance Data.Data.Data Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Exp
instance GHC.Show.Show Language.Haskell.TH.Syntax.Exp
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Stmt
instance Data.Data.Data Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Stmt
instance GHC.Show.Show Language.Haskell.TH.Syntax.Stmt
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Guard
instance Data.Data.Data Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Guard
instance GHC.Show.Show Language.Haskell.TH.Syntax.Guard
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Body
instance Data.Data.Data Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Body
instance GHC.Show.Show Language.Haskell.TH.Syntax.Body
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Clause
instance Data.Data.Data Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Clause
instance GHC.Show.Show Language.Haskell.TH.Syntax.Clause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynDir
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Dec
instance Data.Data.Data Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Dec
instance GHC.Show.Show Language.Haskell.TH.Syntax.Dec
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Info
instance Data.Data.Data Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Info
instance GHC.Show.Show Language.Haskell.TH.Syntax.Info
instance Language.Haskell.TH.Syntax.Lift GHC.Integer.Type.Integer
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Int
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Int#
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int8
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int16
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int32
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int64
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Word#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Word
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word8
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word16
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word32
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word64
instance Language.Haskell.TH.Syntax.Lift GHC.Natural.Natural
instance GHC.Real.Integral a => Language.Haskell.TH.Syntax.Lift (GHC.Real.Ratio a)
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Float
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Float#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Double
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Double#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Char
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Char#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Bool
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Addr#
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Maybe.Maybe a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Data.Either.Either a b)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift [a]
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Base.NonEmpty a)
instance Language.Haskell.TH.Syntax.Lift Data.Void.Void
instance Language.Haskell.TH.Syntax.Lift ()
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a, b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (a, b, c)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (a, b, c, d)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f, g)
instance Language.Haskell.TH.Syntax.Lift (# #)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (# a #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (# a, b #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (# a, b, c #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e, f #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e, f, g #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (# a | b #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (# a | b | c #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e | f #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e | f | g #)
instance Language.Haskell.TH.Syntax.Quasi GHC.Types.IO
instance GHC.Base.Monad Language.Haskell.TH.Syntax.Q
instance Control.Monad.Fail.MonadFail Language.Haskell.TH.Syntax.Q
instance GHC.Base.Functor Language.Haskell.TH.Syntax.Q
instance GHC.Base.Applicative Language.Haskell.TH.Syntax.Q
instance Control.Monad.IO.Class.MonadIO Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Quasi Language.Haskell.TH.Syntax.Q
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Name
instance GHC.Show.Show Language.Haskell.TH.Syntax.Name


-- | Template Haskell supports quasiquoting, which permits users to
--   construct program fragments by directly writing concrete syntax. A
--   quasiquoter is essentially a function with takes a string to a
--   Template Haskell AST. This module defines the <a>QuasiQuoter</a>
--   datatype, which specifies a quasiquoter <tt>q</tt> which can be
--   invoked using the syntax <tt>[q| ... string to parse ... |]</tt> when
--   the <tt>QuasiQuotes</tt> language extension is enabled, and some
--   utility functions for manipulating quasiquoters. Nota bene: this
--   package does not define any parsers, that is up to you.
module Language.Haskell.TH.Quote

-- | The <a>QuasiQuoter</a> type, a value <tt>q</tt> of this type can be
--   used in the syntax <tt>[q| ... string to parse ...|]</tt>. In fact,
--   for convenience, a <a>QuasiQuoter</a> actually defines multiple
--   quasiquoters to be used in different splice contexts; if you are only
--   interested in defining a quasiquoter to be used for expressions, you
--   would define a <a>QuasiQuoter</a> with only <a>quoteExp</a>, and leave
--   the other fields stubbed out with errors.
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter

-- | Quasi-quoter for expressions, invoked by quotes like <tt>lhs =
--   $[q|...]</tt>
[quoteExp] :: QuasiQuoter -> String -> Q Exp

-- | Quasi-quoter for patterns, invoked by quotes like <tt>f $[q|...] =
--   rhs</tt>
[quotePat] :: QuasiQuoter -> String -> Q Pat

-- | Quasi-quoter for types, invoked by quotes like <tt>f :: $[q|...]</tt>
[quoteType] :: QuasiQuoter -> String -> Q Type

-- | Quasi-quoter for declarations, invoked by top-level quotes
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f|foo.s|] will take input from file
--   <tt>"foo.s"</tt> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: forall a k q. Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A "::" string
dcolon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A "-&gt;" string
arrow :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance GHC.Show.Show Language.Haskell.TH.PprLib.Doc
instance GHC.Base.Functor Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Applicative Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Monad Language.Haskell.TH.PprLib.PprM


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
opPrec :: Precedence
unopPrec :: Precedence
sigPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc

-- | Pretty prints a pattern synonym type signature
pprPatSynSig :: Name -> PatSynType -> Doc

-- | Pretty prints a pattern synonym's type; follows the usual conventions
--   to print a pattern synonym type compactly, yet unambiguously. See the
--   note on <a>PatSynType</a> and the section on pattern synonyms in the
--   GHC user's guide for more information.
pprPatSynType :: PatSynType -> Doc
pprPrefixOcc :: Name -> Doc
isSymOcc :: Name -> Bool
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprMatchPat :: Pat -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_deriv_strategy :: DerivStrategy -> Doc
ppr_overlap :: Overlap -> Doc
ppr_data :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> [Con] -> [DerivClause] -> Doc
ppr_newtype :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> Con -> [DerivClause] -> Doc
ppr_deriv_clause :: DerivClause -> Doc
ppr_tySyn :: Doc -> Maybe Name -> Doc -> Type -> Doc
ppr_tf_head :: TypeFamilyHead -> Doc
ppr_bndrs :: Maybe [TyVarBndr] -> Doc
commaSepApplied :: [Name] -> Doc
pprForall :: [TyVarBndr] -> Cxt -> Doc
pprForallVis :: [TyVarBndr] -> Cxt -> Doc
pprForall' :: ForallVisFlag -> [TyVarBndr] -> Cxt -> Doc
pprRecFields :: [(Name, Strict, Type)] -> Type -> Doc
pprGadtRHS :: [(Strict, Type)] -> Type -> Doc
pprVarBangType :: VarBangType -> Doc
pprBangType :: BangType -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>pprVarBangType</a> instead.</i>
pprVarStrictType :: (Name, Strict, Type) -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>pprBangType</a> instead.</i>
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprUInfixT :: Type -> Doc
pprParendTypeArg :: TypeArg -> Doc
pprTyApp :: (Type, [TypeArg]) -> Doc
pprFunArgType :: Type -> Doc
data ForallVisFlag
ForallVis :: ForallVisFlag
ForallInvis :: ForallVisFlag
data TypeArg
TANormal :: Type -> TypeArg
TyArg :: Kind -> TypeArg
split :: Type -> (Type, [TypeArg])
pprTyLit :: TyLit -> Doc
pprCxt :: Cxt -> Doc
ppr_cxt_preds :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
commaSep :: Ppr a => [a] -> Doc
commaSepWith :: (a -> Doc) -> [a] -> Doc
semiSep :: Ppr a => [a] -> Doc
unboxedSumBars :: Doc -> SumAlt -> SumArity -> Doc
bar :: Doc
instance GHC.Show.Show Language.Haskell.TH.Ppr.ForallVisFlag
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Ppr.TypeArg
instance Language.Haskell.TH.Ppr.Ppr a => Language.Haskell.TH.Ppr.Ppr [a]
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Info
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Module
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.ModuleInfo
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Exp
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Stmt
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Match
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pat
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Dec
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FunDep
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FamilyResultSig
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.InjectivityAnn
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pragma
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Inline
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleMatch
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Phases
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Clause
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynDir
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynArgs
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Bang
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceUnpackedness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.DecidedStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyLit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyVarBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Role
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Range
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Loc


-- | Language.Haskell.TH.Lib.Internal exposes some additional functionality
--   that is used internally in GHC's integration with Template Haskell.
--   This is not a part of the public API, and as such, there are no API
--   guarantees for this module from version to version.
module Language.Haskell.TH.Lib.Internal
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyVarBndrQ = Q TyVarBndr
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type Role = Role
type InjectivityAnn = InjectivityAnn
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
charPrimL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
bytesPrimL :: Bytes -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
unboxedSumP :: PatQ -> SumAlt -> SumArity -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
recS :: [StmtQ] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
appTypeE :: ExpQ -> TypeQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [Maybe ExpQ] -> ExpQ
unboxedTupE :: [Maybe ExpQ] -> ExpQ
unboxedSumE :: ExpQ -> SumAlt -> SumArity -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
mdoE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
unboundVarE :: Name -> ExpQ
labelE :: String -> ExpQ
implicitParamVarE :: String -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndrQ] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndrQ] -> Maybe KindQ -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndrQ] -> Maybe KindQ -> ConQ -> [DerivClauseQ] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndrQ] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
instanceWithOverlapD :: Maybe Overlap -> CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
kiSigD :: Name -> KindQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> Maybe [TyVarBndrQ] -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
pragCompleteD :: [Name] -> Maybe Name -> DecQ
dataInstD :: CxtQ -> Maybe [TyVarBndrQ] -> TypeQ -> Maybe KindQ -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeInstD :: CxtQ -> Maybe [TyVarBndrQ] -> TypeQ -> Maybe KindQ -> ConQ -> [DerivClauseQ] -> DecQ
tySynInstD :: TySynEqnQ -> DecQ
dataFamilyD :: Name -> [TyVarBndrQ] -> Maybe KindQ -> DecQ
openTypeFamilyD :: Name -> [TyVarBndrQ] -> FamilyResultSigQ -> Maybe InjectivityAnn -> DecQ
closedTypeFamilyD :: Name -> [TyVarBndrQ] -> FamilyResultSigQ -> Maybe InjectivityAnn -> [TySynEqnQ] -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
standaloneDerivWithStrategyD :: Maybe DerivStrategyQ -> CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ

-- | Pattern synonym declaration
patSynD :: Name -> PatSynArgsQ -> PatSynDirQ -> PatQ -> DecQ

-- | Pattern synonym type signature
patSynSigD :: Name -> TypeQ -> DecQ

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: String -> ExpQ -> DecQ
tySynEqn :: Maybe [TyVarBndrQ] -> TypeQ -> TypeQ -> TySynEqnQ
cxt :: [PredQ] -> CxtQ
derivClause :: Maybe DerivStrategyQ -> [PredQ] -> DerivClauseQ
stockStrategy :: DerivStrategyQ
anyclassStrategy :: DerivStrategyQ
newtypeStrategy :: DerivStrategyQ
viaStrategy :: TypeQ -> DerivStrategyQ
normalC :: Name -> [BangTypeQ] -> ConQ
recC :: Name -> [VarBangTypeQ] -> ConQ
infixC :: Q (Bang, Type) -> Name -> Q (Bang, Type) -> ConQ
forallC :: [TyVarBndrQ] -> CxtQ -> ConQ -> ConQ
gadtC :: [Name] -> [StrictTypeQ] -> TypeQ -> ConQ
recGadtC :: [Name] -> [VarStrictTypeQ] -> TypeQ -> ConQ
forallT :: [TyVarBndrQ] -> CxtQ -> TypeQ -> TypeQ
forallVisT :: [TyVarBndrQ] -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
infixT :: TypeQ -> Name -> TypeQ -> TypeQ
uInfixT :: TypeQ -> Name -> TypeQ -> TypeQ
parensT :: TypeQ -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
appKindT :: TypeQ -> KindQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
litT :: TyLitQ -> TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
unboxedSumT :: SumArity -> TypeQ
sigT :: TypeQ -> KindQ -> TypeQ
equalityT :: TypeQ
wildCardT :: TypeQ
implicitParamT :: String -> TypeQ -> TypeQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
noSourceUnpackedness :: SourceUnpackednessQ
sourceNoUnpack :: SourceUnpackednessQ
sourceUnpack :: SourceUnpackednessQ
noSourceStrictness :: SourceStrictnessQ
sourceLazy :: SourceStrictnessQ
sourceStrict :: SourceStrictnessQ

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Q Strict
bang :: SourceUnpackednessQ -> SourceStrictnessQ -> BangQ
bangType :: BangQ -> TypeQ -> BangTypeQ
varBangType :: Name -> BangTypeQ -> VarBangTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Q Strict -> TypeQ -> StrictTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
plainTV :: Name -> TyVarBndrQ
kindedTV :: Name -> KindQ -> TyVarBndrQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: KindQ
constraintK :: KindQ
noSig :: FamilyResultSigQ
kindSig :: KindQ -> FamilyResultSigQ
tyVarSig :: TyVarBndrQ -> FamilyResultSigQ
injectivityAnn :: Name -> [Name] -> InjectivityAnn
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
unidir :: PatSynDirQ
implBidir :: PatSynDirQ
explBidir :: [ClauseQ] -> PatSynDirQ
prefixPatSyn :: [Name] -> PatSynArgsQ
recordPatSyn :: [Name] -> PatSynArgsQ
infixPatSyn :: Name -> Name -> PatSynArgsQ
appsE :: [ExpQ] -> ExpQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module


-- | Language.Haskell.TH.Lib contains lots of useful helper functions for
--   generating and manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyVarBndrQ = Q TyVarBndr
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
charPrimL :: Char -> Lit
bytesPrimL :: Bytes -> Lit

-- | Create a Bytes datatype representing raw bytes to be embedded into the
--   program/library binary.
mkBytes :: ForeignPtr Word8 -> Word -> Word -> Bytes
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
unboxedSumP :: PatQ -> SumAlt -> SumArity -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ
varE :: Name -> ExpQ
unboundVarE :: Name -> ExpQ
labelE :: String -> ExpQ
implicitParamVarE :: String -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
appTypeE :: ExpQ -> TypeQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
unboxedSumE :: ExpQ -> SumAlt -> SumArity -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
mdoE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
recS :: [StmtQ] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
forallVisT :: [TyVarBndrQ] -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
appKindT :: TypeQ -> KindQ -> TypeQ
arrowT :: TypeQ
infixT :: TypeQ -> Name -> TypeQ -> TypeQ
uInfixT :: TypeQ -> Name -> TypeQ -> TypeQ
parensT :: TypeQ -> TypeQ
equalityT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
unboxedSumT :: SumArity -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
litT :: TyLitQ -> TypeQ
wildCardT :: TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
implicitParamT :: String -> TypeQ -> TypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
noSourceUnpackedness :: SourceUnpackednessQ
sourceNoUnpack :: SourceUnpackednessQ
sourceUnpack :: SourceUnpackednessQ
noSourceStrictness :: SourceStrictnessQ
sourceLazy :: SourceStrictnessQ
sourceStrict :: SourceStrictnessQ

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Q Strict
bang :: SourceUnpackednessQ -> SourceStrictnessQ -> BangQ
bangType :: BangQ -> TypeQ -> BangTypeQ
varBangType :: Name -> BangTypeQ -> VarBangTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Q Strict -> TypeQ -> StrictTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [BangTypeQ] -> ConQ
recC :: Name -> [VarBangTypeQ] -> ConQ
infixC :: Q (Bang, Type) -> Name -> Q (Bang, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
gadtC :: [Name] -> [StrictTypeQ] -> TypeQ -> ConQ
recGadtC :: [Name] -> [VarStrictTypeQ] -> TypeQ -> ConQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> ConQ -> [DerivClauseQ] -> DecQ
derivClause :: Maybe DerivStrategy -> [PredQ] -> DerivClauseQ

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
stockStrategy :: DerivStrategyQ
anyclassStrategy :: DerivStrategyQ
newtypeStrategy :: DerivStrategyQ
viaStrategy :: TypeQ -> DerivStrategyQ

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
instanceWithOverlapD :: Maybe Overlap -> CxtQ -> TypeQ -> [DecQ] -> DecQ

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlappable</a> and <a>Overlappable</a>, and pick an
--   arbitrary one if multiple choices are available.
Incoherent :: Overlap
sigD :: Name -> TypeQ -> DecQ
kiSigD :: Name -> KindQ -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
standaloneDerivWithStrategyD :: Maybe DerivStrategy -> CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
dataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> DecQ
openTypeFamilyD :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> DecQ
closedTypeFamilyD :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> [TySynEqnQ] -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> ConQ -> [DerivClauseQ] -> DecQ
tySynInstD :: TySynEqnQ -> DecQ
tySynEqn :: Maybe [TyVarBndr] -> TypeQ -> TypeQ -> TySynEqnQ
injectivityAnn :: Name -> [Name] -> InjectivityAnn
noSig :: FamilyResultSig
kindSig :: Kind -> FamilyResultSig
tyVarSig :: TyVarBndr -> FamilyResultSig
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
pragCompleteD :: [Name] -> Maybe Name -> DecQ

-- | Pattern synonym declaration
patSynD :: Name -> PatSynArgsQ -> PatSynDirQ -> PatQ -> DecQ

-- | Pattern synonym type signature
patSynSigD :: Name -> TypeQ -> DecQ
unidir :: PatSynDirQ
implBidir :: PatSynDirQ
explBidir :: [ClauseQ] -> PatSynDirQ
prefixPatSyn :: [Name] -> PatSynArgsQ
infixPatSyn :: Name -> Name -> PatSynArgsQ
recordPatSyn :: [Name] -> PatSynArgsQ

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: String -> ExpQ -> DecQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyType nm</tt> attempts to find the type or kind of
--   <tt>nm</tt>. For example, <tt>reifyType 'not</tt> returns <tt>Bool
--   -&gt; Bool</tt>, and <tt>reifyType ''Bool</tt> returns <tt>Type</tt>.
--   This works even if there's no explicit signature and the type or kind
--   is inferred.
reifyType :: Name -> Q Type

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | Represents an expression which has type <tt>a</tt>. Built on top of
--   <a>Exp</a>, typed expressions allow for type-safe splicing via:
--   
--   <ul>
--   <li>typed quotes, written as <tt>[|| ... ||]</tt> where <tt>...</tt>
--   is an expression; if that expression has type <tt>a</tt>, then the
--   quotation has type <tt><a>Q</a> (<a>TExp</a> a)</tt></li>
--   <li>typed splices inside of typed quotes, written as <tt>$$(...)</tt>
--   where <tt>...</tt> is an arbitrary expression of type <tt><a>Q</a>
--   (<a>TExp</a> a)</tt></li>
--   </ul>
--   
--   Traditional expression quotes and splices let us construct ill-typed
--   expressions:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [| True == $( [| "foo" |] ) |]
--   GHC.Types.True GHC.Classes.== "foo"
--   
--   &gt;&gt;&gt; GHC.Types.True GHC.Classes.== "foo"
--   &lt;interactive&gt; error:
--       • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
--       • In the second argument of ‘(==)’, namely ‘"foo"’
--         In the expression: True == "foo"
--         In an equation for ‘it’: it = True == "foo"
--   </pre>
--   
--   With typed expressions, the type error occurs when <i>constructing</i>
--   the Template Haskell expression:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [|| True == $$( [|| "foo" ||] ) ||]
--   &lt;interactive&gt; error:
--       • Couldn't match type ‘[Char]’ with ‘Bool’
--         Expected type: Q (TExp Bool)
--           Actual type: Q (TExp [Char])
--       • In the Template Haskell quotation [|| "foo" ||]
--         In the expression: [|| "foo" ||]
--         In the Template Haskell splice $$([|| "foo" ||])
--   </pre>
data TExp (a :: TYPE (r :: RuntimeRep))

-- | Underlying untyped Template Haskell expression
unType :: TExp a -> Exp

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { type TypeRep :: k -&gt; Type }
--   </pre>
KiSigD :: Name -> Kind -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {-# INLINE [1] foo #-} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { data family T a b c :: * }
--   </pre>
DataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | <pre>
--   { type family T a b c = (r :: *) | r -&gt; a b }
--   </pre>
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | <tt>{ pattern P v1 v2 .. vn &lt;- p }</tt> unidirectional or <tt>{
--   pattern P v1 v2 .. vn = p }</tt> implicit bidirectional or <tt>{
--   pattern P v1 v2 .. vn &lt;- p where P v1 v2 .. vn = e }</tt> explicit
--   bidirectional
--   
--   also, besides prefix pattern synonyms, both infix and record pattern
--   synonyms are supported. See <a>PatSynArgs</a> for details
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness that the compiler
--   chooses for a data constructor field, which may be different from what
--   is written in source code. See <a>reifyConStrictness</a> for more
--   information.
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (1,)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   TupE [Just (LitE (IntegerL 1)),Nothing]
--   </pre>
TupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (# 'c', #)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   UnboxedTupE [Just (LitE (CharL 'c')),Nothing]
--   </pre>
UnboxedTupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { mdo { x &lt;- e1 y; y &lt;- e2 x; } }
--   </pre>
MDoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type <a>Addr#</a>
StringPrimL :: [Word8] -> Lit

-- | Some raw bytes, type <a>Addr#</a>:
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;type&gt;
--   </pre>
ForallVisT :: [TyVarBndr] -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (#,#), (#,,#), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   (#|#), (#||#), etc.
--   </pre>
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = [Pred] " @(Eq a, Ord b)@"

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr -> FamilyResultSig

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
