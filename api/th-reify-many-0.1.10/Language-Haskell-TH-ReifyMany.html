<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Language.Haskell.TH.ReifyMany</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">th-reify-many-0.1.10: Recurseively reify template haskell datatype info</span><ul class="links" id="page-menu"><li><a href="src/Language.Haskell.TH.ReifyMany.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Language.Haskell.TH.ReifyMany</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p><code>th-reify-many</code> provides functions for recursively reifying top
 level declarations.  The main intended use case is for enumerating
 the names of datatypes reachable from an initial datatype, and
 passing these names to some function which generates instances.</p><p>For example, in order to define <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#v:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code>
 instances for two mutually recursive datatypes, I could write
 something like:</p><pre>{-# LANGUAGE TemplateHaskell #-}
import Language.Haskell.TH.ReifyMany (reifyManyWithoutInstances)
import Language.Haskell.TH.Lift (Lift(..), deriveLiftMany)

data A = A B

data B = B Int

$(reifyManyWithoutInstances ''Lift [''A] (const True) &gt;&gt;= deriveLiftMany)</pre><p>One interesting feature of this is that it attempts to omit the
 types which already have an instance defined.  For example, if
 <code>$(deriveLift ''B)</code> is used before <code>deriveLiftMany</code>, it will omit
 the instance for B.</p><p>Of course, the intended usecase for this involves many more
 datatypes - for example, syntax trees such as those found in TH.</p><p>Note that <code><a href="Language-Haskell-TH-ReifyMany.html#v:reifyManyWithoutInstances" title="Language.Haskell.TH.ReifyMany">reifyManyWithoutInstances</a></code> is rather imperfect in its
 testing of whether an instance exists, and whether an instance
 should exist.  See this function's docs for details.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:reifyManyWithoutInstances">reifyManyWithoutInstances</a> :: <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; (<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>]</li><li class="src short"><a href="#v:reifyManyTyCons">reifyManyTyCons</a> :: ((<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> (<a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>])) -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [(<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>)]</li><li class="src short"><a href="#v:reifyMany">reifyMany</a> :: ((<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> (<a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>])) -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [(<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>)]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:reifyManyWithoutInstances" class="def">reifyManyWithoutInstances</a> :: <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; (<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] <a href="src/Language.Haskell.TH.ReifyMany.html#reifyManyWithoutInstances" class="link">Source</a> <a href="#v:reifyManyWithoutInstances" class="selflink">#</a></p><div class="doc"><p>Recursively enumerates type constructor declarations, halting
 when datatypes appear to already have an instance for the typeclass
 specified by the first <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></code> parameter.  It guesses that an
 instance exists for a given datatype if it's used in the top
 constructor of any of its parameters (see <code><a href="Language-Haskell-TH-ReifyMany-Internal.html#v:instanceMatches" title="Language.Haskell.TH.ReifyMany.Internal">instanceMatches</a></code>).</p><p>This function is useful for bulk defining typeclass instances like
 <code>Binary</code>, <code>Lift</code>, <code>Data</code>, <code>Typeable</code>, etc.  It isn't very clever,
 though - in particular it has the following limitations:</p><ul><li>It only works well when type constructors mentioned in
   fields should all have instances defined for them.</li><li>It ignores data type / constructor constraints.</li><li>It ignores data / type families.</li></ul><p>It also takes a user-defined predicate, which is useful in
 situations where this attempts to descend into datatypes which do
 not need instances defined for them.</p><p>Note that this will always initially yield the <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></code>s of the
 initial types, regardless of whether they are instances or not.</p></div></div><div class="top"><p class="src"><a id="v:reifyManyTyCons" class="def">reifyManyTyCons</a> :: ((<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> (<a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>])) -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [(<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>)] <a href="src/Language.Haskell.TH.ReifyMany.html#reifyManyTyCons" class="link">Source</a> <a href="#v:reifyManyTyCons" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Language-Haskell-TH-ReifyMany.html#v:reifyMany" title="Language.Haskell.TH.ReifyMany">reifyMany</a></code>, but specialized for recursively enumerating
 type constructor declarations, omitting <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#v:PrimTyConI" title="Language.Haskell.TH.Syntax">PrimTyConI</a></code>.</p><p>In order to have this behave like <code><a href="Language-Haskell-TH-ReifyMany.html#v:reifyManyWithoutInstances" title="Language.Haskell.TH.ReifyMany">reifyManyWithoutInstances</a></code>, but
 not do any instance filtering, use it with the <code><a href="Language-Haskell-TH-ReifyMany-Internal.html#v:isDataDec" title="Language.Haskell.TH.ReifyMany.Internal">isDataDec</a></code> and
 <code><a href="Language-Haskell-TH-ReifyMany-Internal.html#v:decConcreteNames" title="Language.Haskell.TH.ReifyMany.Internal">decConcreteNames</a></code> internal utilities.  For example:</p><pre>{-# LANGUAGE TemplateHaskell #-}
import Language.Haskell.TH
import Language.Haskell.TH.ReifyMany
import Language.Haskell.TH.ReifyMany.Internal

$(do results &lt;- reifyManyTyCons
         (\(_, dec) -&gt; return (isDataDec dec, decConcreteNames dec))
         [''Exp]
     -- Display the results
     reportError (show (map fst results))
     -- This TH splice doesn't generate any code.
     return []
 )</pre></div></div><div class="top"><p class="src"><a id="v:reifyMany" class="def">reifyMany</a> :: ((<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>) -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> (<a href="../base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>])) -&gt; [<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [(<a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>, <a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Info" title="Language.Haskell.TH.Syntax">Info</a>)] <a href="src/Language.Haskell.TH.ReifyMany.html#reifyMany" class="link">Source</a> <a href="#v:reifyMany" class="selflink">#</a></p><div class="doc"><p>Starting from a set of initial top level declarations, specified
 by <code>[Name]</code>, recursively enumerate other related declarations.  The
 provided function determines whether the current info be included
 in the list of results, and which <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></code>s to lookup next. This
 function handles keeping track of which <code><a href="../template-haskell-2.16.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></code>s have already been
 visited.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>