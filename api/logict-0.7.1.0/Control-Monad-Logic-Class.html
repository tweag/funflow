<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Control.Monad.Logic.Class</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">logict-0.7.1.0: A backtracking logic-programming monad.</span><ul class="links" id="page-menu"><li><a href="src/Control.Monad.Logic.Class.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2007-2014 Dan Doel<br />(c) 2011-2013 Edward Kmett<br />(c) 2014      Roman Cheplyaka<br />(c) 2020-2021 Andrew Lelechenko<br />(c) 2020-2021 Kevin Quick</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Andrew Lelechenko &lt;andrew.lelechenko@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Monad.Logic.Class</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Adapted from the paper
 <a href="http://okmij.org/ftp/papers/LogicT.pdf">Backtracking, Interleaving, and Terminating Monad Transformers</a>
 by Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, Amr Sabry.
 Note that the paper uses <code><a href="../base-4.14.3.0/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code> vocabulary
 (<code><a href="../base-4.14.3.0/Control-Monad.html#v:mzero" title="Control.Monad">mzero</a></code> and <code><a href="../base-4.14.3.0/Control-Monad.html#v:mplus" title="Control.Monad">mplus</a></code>),
 while examples below prefer <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> and <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>
 from <code><a href="../base-4.14.3.0/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> (<a href="../base-4.14.3.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.14.3.0/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m) =&gt; <a href="#t:MonadLogic">MonadLogic</a> m <span class="keyword">where</span><ul class="subs"><li><a href="#v:msplit">msplit</a> :: m a -&gt; m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, m a))</li><li><a href="#v:interleave">interleave</a> :: m a -&gt; m a -&gt; m a</li><li><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: m a -&gt; (a -&gt; m b) -&gt; m b</li><li><a href="#v:once">once</a> :: m a -&gt; m a</li><li><a href="#v:lnot">lnot</a> :: m a -&gt; m ()</li><li><a href="#v:ifte">ifte</a> :: m a -&gt; (a -&gt; m b) -&gt; m b -&gt; m b</li></ul></li><li class="src short"><a href="#v:reflect">reflect</a> :: <a href="../base-4.14.3.0/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; <a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, m a) -&gt; m a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../base-4.14.3.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.14.3.0/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m) =&gt; <a id="t:MonadLogic" class="def">MonadLogic</a> m <span class="keyword">where</span> <a href="src/Control.Monad.Logic.Class.html#MonadLogic" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></p><div class="doc"><p>A backtracking, logic programming monad.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Control-Monad-Logic-Class.html#v:msplit" title="Control.Monad.Logic.Class">msplit</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:msplit" class="def">msplit</a> :: m a -&gt; m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, m a)) <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><div class="doc"><p>Attempts to <strong>split</strong> the computation, giving access to the first
   result. Satisfies the following laws:</p><pre>msplit empty          == pure Nothing
msplit (pure a &lt;|&gt; m) == pure (Just (a, m))</pre></div><p class="src"><a id="v:interleave" class="def">interleave</a> :: m a -&gt; m a -&gt; m a <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><div class="doc"><p><strong>Fair disjunction.</strong> It is possible for a logical computation
   to have an infinite number of potential results, for instance:</p><pre>odds = pure 1 &lt;|&gt; fmap (+ 2) odds</pre><p>Such computations can cause problems in some circumstances. Consider:</p><pre>two = do x &lt;- odds &lt;|&gt; pure 2
         if even x then pure x else empty</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observe two
</code></strong>...never completes...
</pre><p>Such a computation may never consider <code><a href="../base-4.14.3.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> <code>2</code>, and
   therefore even <code><a href="Control-Monad-Logic.html#v:observe" title="Control.Monad.Logic">observe</a></code> <code>two</code> will
   never return any results. By
   contrast, using <code><a href="Control-Monad-Logic-Class.html#v:interleave" title="Control.Monad.Logic.Class">interleave</a></code> in place of
   <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> ensures fair consideration of both
   branches of a disjunction.</p><pre>fairTwo = do x &lt;- odds `interleave` pure 2
             if even x then pure x else empty</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observe fairTwo
</code></strong>2
</pre><p>Note that even with <code><a href="Control-Monad-Logic-Class.html#v:interleave" title="Control.Monad.Logic.Class">interleave</a></code> this computation will never
   terminate after returning 2: only the first value can be
   safely observed, after which each odd value becomes <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>
   (equivalent to
   <a href="http://lpn.swi-prolog.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse45">Prolog's fail</a>)
   which does not stop the evaluation but indicates there is no
   value to return yet.</p><p>Unlike <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>, <code><a href="Control-Monad-Logic-Class.html#v:interleave" title="Control.Monad.Logic.Class">interleave</a></code> is not associative:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = [1,2,3]; y = [4,5,6]; z = [7,8,9] :: [Int]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>x `interleave` y
</code></strong>[1,4,2,5,3,6]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(x `interleave` y) `interleave` z
</code></strong>[1,7,4,8,2,9,5,3,6]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>y `interleave` z
</code></strong>[4,7,5,8,6,9]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>x `interleave` (y `interleave` z)
</code></strong>[1,4,2,7,3,5,8,6,9]
</pre></div><p class="src"><a id="v:-62--62--45-" class="def">(&gt;&gt;-)</a> :: m a -&gt; (a -&gt; m b) -&gt; m b <span class="fixity">infixl 1</span><span class="rightedge"></span> <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><div class="doc"><p><strong>Fair conjunction.</strong> Similarly to the previous function, consider
   the distributivity law, naturally expected from <code><a href="../base-4.14.3.0/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>:</p><pre>(a &lt;|&gt; b) &gt;&gt;= k = (a &gt;&gt;= k) &lt;|&gt; (b &gt;&gt;= k)</pre><p>If <code>a</code> <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code> <code>k</code> can backtrack arbitrarily many times, <code>b</code> <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code> <code>k</code>
   may never be considered. In logic statements,
   &quot;backtracking&quot; is the process of discarding the current
   possible solution value and returning to a previous decision
   point where a new value can be obtained and tried.  For
   example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>do { x &lt;- pure 0 &lt;|&gt; pure 1 &lt;|&gt; pure 2; if even x then pure x else empty } :: [Int]
</code></strong>[0,2]
</pre><p>Here, the <code>x</code> value can be produced three times, where
   <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> represents the decision points of that
   production.  The subsequent <code>if</code> statement specifies
   <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> (fail)
   if <code>x</code> is odd, causing it to be discarded and a return
   to an <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> decision point to get the next <code>x</code>.</p><p>The statement &quot;<code>a</code> <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code> <code>k</code> can backtrack arbitrarily many
   times&quot; means that the computation is resulting in <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> and
   that <code>a</code> has an infinite number of <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> applications to
   return to.  This is called a conjunctive computation because
   the logic for <code>a</code> <em>and</em> <code>k</code> must both succeed (i.e. <code><a href="../base-4.14.3.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code>
   a value instead of <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>).</p><p>Similar to the way <code><a href="Control-Monad-Logic-Class.html#v:interleave" title="Control.Monad.Logic.Class">interleave</a></code> allows both branches of a
   disjunctive computation, the <code><a href="Control-Monad-Logic-Class.html#v:-62--62--45-" title="Control.Monad.Logic.Class">&gt;&gt;-</a></code> operator takes care to
   consider both branches of a conjunctive computation.</p><p>Consider the operation:</p><pre>odds = pure 1 &lt;|&gt; fmap (2 +) odds

oddsPlus n = odds &gt;&gt;= \a -&gt; pure (a + n)

g = do x &lt;- (pure 0 &lt;|&gt; pure 1) &gt;&gt;= oddsPlus
       if even x then pure x else empty</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeMany 3 g
</code></strong>...never completes...
</pre><p>This will never produce any value because all values produced
   by the <code>do</code> program come from the <code><a href="../base-4.14.3.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> <code>1</code> driven operation
   (adding one to the sequence of odd values, resulting in the
   even values that are allowed by the test in the second line),
   but the <code><a href="../base-4.14.3.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> <code>0</code> input to <code>oddsPlus</code> generates an infinite
   number of <code><a href="../base-4.14.3.0/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> failures so the even values generated by
   the <code><a href="../base-4.14.3.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> <code>1</code> alternative are never seen.  Using
   <code><a href="Control-Monad-Logic-Class.html#v:interleave" title="Control.Monad.Logic.Class">interleave</a></code> here instead of <code><a href="../base-4.14.3.0/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> does not help due
   to the aforementioned distributivity law.</p><p>Also note that the <code>do</code> notation desugars to <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code> bind
   operations, so the following would also fail:</p><pre>do a &lt;- pure 0 &lt;|&gt; pure 1
   x &lt;- oddsPlus a
   if even x then pure x else empty</pre><p>The solution is to use the <code><a href="Control-Monad-Logic-Class.html#v:-62--62--45-" title="Control.Monad.Logic.Class">&gt;&gt;-</a></code> in place of the normal
   monadic bind operation <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code> when fairness between
   alternative productions is needed in a conjunction of
   statements (rules):</p><pre>h = do x &lt;- (pure 0 &lt;|&gt; pure 1) &gt;&gt;- oddsPlus
       if even x then pure x else empty</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeMany 3 h
</code></strong>[2,4,6]
</pre><p>However, a bit of care is needed when using <code><a href="Control-Monad-Logic-Class.html#v:-62--62--45-" title="Control.Monad.Logic.Class">&gt;&gt;-</a></code> because,
   unlike <code><a href="../base-4.14.3.0/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code>, it is not associative.  For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let m = [2,7] :: [Int]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let k x = [x, x + 1]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let h x = [x, x * 2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h)
</code></strong>[2,4,3,6,7,14,8,16]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(m &gt;&gt;= k) &gt;&gt;= h -- same as above
</code></strong>[2,4,3,6,7,14,8,16]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>m &gt;&gt;- (\x -&gt; k x &gt;&gt;- h)
</code></strong>[2,7,3,8,4,14,6,16]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(m &gt;&gt;- k) &gt;&gt;- h -- central elements are different
</code></strong>[2,7,4,3,14,8,6,16]
</pre><p>This means that the following will be productive:</p><pre>(pure 0 &lt;|&gt; pure 1) &gt;&gt;-
  oddsPlus &gt;&gt;-
    \x -&gt; if even x then pure x else empty</pre><p>Which is equivalent to</p><pre>((pure 0 &lt;|&gt; pure 1) &gt;&gt;- oddsPlus) &gt;&gt;-
  (\x -&gt; if even x then pure x else empty)</pre><p>But the following will <em>not</em> be productive:</p><pre>(pure 0 &lt;|&gt; pure 1) &gt;&gt;-
  (\a -&gt; (oddsPlus a &gt;&gt;- \x -&gt; if even x then pure x else empty))</pre><p>Since do notation desugaring results in the latter, the
   <code>RebindableSyntax</code> language pragma cannot easily be used
   either.  Instead, it is recommended to carefully use explicit
   <code><a href="Control-Monad-Logic-Class.html#v:-62--62--45-" title="Control.Monad.Logic.Class">&gt;&gt;-</a></code> only when needed.</p></div><p class="src"><a id="v:once" class="def">once</a> :: m a -&gt; m a <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><div class="doc"><p><strong>Pruning.</strong> Selects one result out of many. Useful for when multiple
   results of a computation will be equivalent, or should be treated as
   such.</p><p>As an example, here's a way to determine if a number is
   <a href="https://wikipedia.org/wiki/Composite_number">composite</a>
   (has non-trivial integer divisors, i.e. not a
   prime number):</p><pre>choose = foldr ((&lt;|&gt;) . pure) empty

divisors n = do a &lt;- choose [2..n-1]
                b &lt;- choose [2..n-1]
                guard (a * b == n)
                pure (a, b)

composite_ v = do _ &lt;- divisors v
                  pure &quot;Composite&quot;</pre><p>While this works as intended, it actually does too much work:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (composite_ 20)
</code></strong>[&quot;Composite&quot;, &quot;Composite&quot;, &quot;Composite&quot;, &quot;Composite&quot;]
</pre><p>Because there are multiple divisors of 20, and they can also
   occur in either order:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (divisors 20)
</code></strong>[(2,10), (4,5), (5,4), (10,2)]
</pre><p>Clearly one could just use <code><a href="Control-Monad-Logic.html#v:observe" title="Control.Monad.Logic">observe</a></code> here to get the first
   non-prime result, but if the call to <code>composite</code> is in the
   middle of other logic code then use <code><a href="Control-Monad-Logic-Class.html#v:once" title="Control.Monad.Logic.Class">once</a></code> instead.</p><pre>composite v = do _ &lt;- once (divisors v)
                 pure &quot;Composite&quot;</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (composite 20)
</code></strong>[&quot;Composite&quot;]
</pre></div><p class="src"><a id="v:lnot" class="def">lnot</a> :: m a -&gt; m () <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><div class="doc"><p><strong>Inverts</strong> a logic computation. If <code>m</code> succeeds with at least one value,
   <code><a href="Control-Monad-Logic-Class.html#v:lnot" title="Control.Monad.Logic.Class">lnot</a></code> <code>m</code> fails. If <code>m</code> fails, then <code><a href="Control-Monad-Logic-Class.html#v:lnot" title="Control.Monad.Logic.Class">lnot</a></code> <code>m</code> succeeds with the value <code>()</code>.</p><p>For example, evaluating if a number is prime can be based on
   the failure to find divisors of a number:</p><pre>choose = foldr ((&lt;|&gt;) . pure) empty

divisors n = do d &lt;- choose [2..n-1]
                guard (n `rem` d == 0)
                pure d

prime v = do _ &lt;- lnot (divisors v)
             pure True</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (prime 20)
</code></strong>[]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (prime 19)
</code></strong>[True]
</pre><p>Here if <code>divisors</code> never succeeds, then the <code><a href="Control-Monad-Logic-Class.html#v:lnot" title="Control.Monad.Logic.Class">lnot</a></code> will
   succeed and the number will be declared as prime.</p></div><p class="src"><a id="v:ifte" class="def">ifte</a> :: m a -&gt; (a -&gt; m b) -&gt; m b -&gt; m b <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p><div class="doc"><p>Logical <strong>conditional.</strong> The equivalent of
   <a href="http://lpn.swi-prolog.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse44">Prolog's soft-cut</a>.
   If its first argument succeeds at all,
   then the results will be fed into the success
   branch. Otherwise, the failure branch is taken.  The failure
   branch is never considered if the first argument has any
   successes.  The <code><a href="Control-Monad-Logic-Class.html#v:ifte" title="Control.Monad.Logic.Class">ifte</a></code> function satisfies the following laws:</p><pre>ifte (pure a) th el       == th a
ifte empty th el          == el
ifte (pure a &lt;|&gt; m) th el == th a &lt;|&gt; (m &gt;&gt;= th)</pre><p>For example, the previous <code>prime</code> function returned nothing
   if the number was not prime, but if it should return <code><a href="../base-4.14.3.0/Data-Bool.html#v:False" title="Data.Bool">False</a></code>
   instead, the following can be used:</p><pre>choose = foldr ((&lt;|&gt;) . pure) empty

divisors n = do d &lt;- choose [2..n-1]
                guard (n `rem` d == 0)
                pure d

prime v = once (ifte (divisors v)
                  (const (pure True))
                  (pure False))</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (prime 20)
</code></strong>[False]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>observeAll (prime 19)
</code></strong>[True]
</pre><p>Notice that this cannot be done with a simple <code>if-then-else</code>
   because <code>divisors</code> either generates values or it does not, so
   there's no &quot;false&quot; condition to check with a simple <code>if</code>
   statement.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadLogic">Instances</h4><details id="i:MonadLogic" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadLogic:MonadLogic:1"></span> <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> []</span> <a href="src/Control.Monad.Logic.Class.html#line-333" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadLogic:MonadLogic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Monad-Logic-Class.html">Control.Monad.Logic.Class</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:msplit">msplit</a> :: [a] -&gt; [<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a])] <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><p class="src"><a href="#v:interleave">interleave</a> :: [a] -&gt; [a] -&gt; [a] <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><p class="src"><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: [a] -&gt; (a -&gt; [b]) -&gt; [b] <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><p class="src"><a href="#v:once">once</a> :: [a] -&gt; [a] <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><p class="src"><a href="#v:lnot">lnot</a> :: [a] -&gt; [()] <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><p class="src"><a href="#v:ifte">ifte</a> :: [a] -&gt; (a -&gt; [b]) -&gt; [b] -&gt; [b] <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadLogic:MonadLogic:2"></span> <a href="../base-4.14.3.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> (<a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m)</span> <a href="src/Control.Monad.Logic.html#line-261" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadLogic:MonadLogic:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Monad-Logic.html">Control.Monad.Logic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:msplit">msplit</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a)) <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><p class="src"><a href="#v:interleave">interleave</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><p class="src"><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; (a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m b) -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m b <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><p class="src"><a href="#v:once">once</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><p class="src"><a href="#v:lnot">lnot</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m () <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><p class="src"><a href="#v:ifte">ifte</a> :: <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m a -&gt; (a -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m b) -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m b -&gt; <a href="Control-Monad-Logic.html#t:LogicT" title="Control.Monad.Logic">LogicT</a> m b <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadLogic:MonadLogic:3"></span> <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> m =&gt; <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> (<a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m)</span> <a href="src/Control.Monad.Logic.Class.html#line-346" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></td><td class="doc"><p>Note that splitting a transformer does
 not allow you to provide different input
 to the monadic object returned.
 For instance, in:</p><pre>let Just (_, rm') = runReaderT (msplit rm) r in runReaderT rm' r'</pre><p><code>r'</code> will be ignored, because <code>r</code> was already threaded through the
 computation.</p></td></tr><tr><td colspan="2"><details id="i:ic:MonadLogic:MonadLogic:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Monad-Logic-Class.html">Control.Monad.Logic.Class</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:msplit">msplit</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a)) <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><p class="src"><a href="#v:interleave">interleave</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><p class="src"><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m b <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><p class="src"><a href="#v:once">once</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><p class="src"><a href="#v:lnot">lnot</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m () <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><p class="src"><a href="#v:ifte">ifte</a> :: <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m b -&gt; <a href="../mtl-2.2.2/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> e m b <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadLogic:MonadLogic:4"></span> (<a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> m, <a href="../base-4.14.3.0/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m) =&gt; <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> (<a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m)</span> <a href="src/Control.Monad.Logic.Class.html#line-374" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></td><td class="doc"><p>See note on splitting above.</p></td></tr><tr><td colspan="2"><details id="i:ic:MonadLogic:MonadLogic:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Monad-Logic-Class.html">Control.Monad.Logic.Class</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:msplit">msplit</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a)) <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><p class="src"><a href="#v:interleave">interleave</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><p class="src"><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m b <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><p class="src"><a href="#v:once">once</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><p class="src"><a href="#v:lnot">lnot</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m () <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><p class="src"><a href="#v:ifte">ifte</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m b -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> s m b <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadLogic:MonadLogic:5"></span> (<a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> m, <a href="../base-4.14.3.0/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m) =&gt; <a href="Control-Monad-Logic-Class.html#t:MonadLogic" title="Control.Monad.Logic.Class">MonadLogic</a> (<a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m)</span> <a href="src/Control.Monad.Logic.Class.html#line-353" class="link">Source</a> <a href="#t:MonadLogic" class="selflink">#</a></td><td class="doc"><p>See note on splitting above.</p></td></tr><tr><td colspan="2"><details id="i:ic:MonadLogic:MonadLogic:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Monad-Logic-Class.html">Control.Monad.Logic.Class</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:msplit">msplit</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m (<a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a)) <a href="src/Control.Monad.Logic.Class.html#msplit" class="link">Source</a> <a href="#v:msplit" class="selflink">#</a></p><p class="src"><a href="#v:interleave">interleave</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a <a href="src/Control.Monad.Logic.Class.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><p class="src"><a href="#v:-62--62--45-">(&gt;&gt;-)</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m b <a href="src/Control.Monad.Logic.Class.html#%3E%3E-" class="link">Source</a> <a href="#v:-62--62--45-" class="selflink">#</a></p><p class="src"><a href="#v:once">once</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a <a href="src/Control.Monad.Logic.Class.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><p class="src"><a href="#v:lnot">lnot</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m () <a href="src/Control.Monad.Logic.Class.html#lnot" class="link">Source</a> <a href="#v:lnot" class="selflink">#</a></p><p class="src"><a href="#v:ifte">ifte</a> :: <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m a -&gt; (a -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m b) -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m b -&gt; <a href="../mtl-2.2.2/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m b <a href="src/Control.Monad.Logic.Class.html#ifte" class="link">Source</a> <a href="#v:ifte" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:reflect" class="def">reflect</a> :: <a href="../base-4.14.3.0/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> m =&gt; <a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, m a) -&gt; m a <a href="src/Control.Monad.Logic.Class.html#reflect" class="link">Source</a> <a href="#v:reflect" class="selflink">#</a></p><div class="doc"><p>The inverse of <code><a href="Control-Monad-Logic-Class.html#v:msplit" title="Control.Monad.Logic.Class">msplit</a></code>. Satisfies the following law:</p><pre>msplit m &gt;&gt;= reflect == m</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>