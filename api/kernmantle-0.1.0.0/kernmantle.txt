-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Composing Applicatives, Monads, Comonads and Arrows into Arrows
--   
--   Please see the README on GitHub at
--   <a>https://github.com/YPares/kernmantle#readme</a>
@package kernmantle
@version 0.1.0.0


-- | Deal with throw and try effects
module Control.Kernmantle.Error

-- | A class for binary effects that can possibly throw exceptions
class ThrowEffect ex eff
throwE :: ThrowEffect ex eff => eff (Either ex b) b

-- | A class for binary effects that can catch exceptions
class TryEffect ex eff
tryE :: TryEffect ex eff => eff a b -> eff a (Either ex b)
instance (Control.Monad.Catch.MonadCatch m, GHC.Exception.Type.Exception ex) => Control.Kernmantle.Error.TryEffect ex (Control.Arrow.Kleisli m)
instance (GHC.Base.Functor f, Control.Kernmantle.Error.TryEffect ex eff) => Control.Kernmantle.Error.TryEffect ex (Data.Profunctor.Cayley.Cayley f eff)
instance (Control.Monad.Catch.MonadThrow m, GHC.Exception.Type.Exception ex) => Control.Kernmantle.Error.ThrowEffect ex (Control.Arrow.Kleisli m)
instance (GHC.Base.Applicative f, Control.Kernmantle.Error.ThrowEffect ex eff) => Control.Kernmantle.Error.ThrowEffect ex (Data.Profunctor.Cayley.Cayley f eff)


-- | This module provides some missing classes from profunctors
--   
--   BEWARE: That part of Kernmantle API is experimental and is likely to
--   change in the future.
module Data.Profunctor.EffFunctor

-- | Functors over binary effects
type EffFunctor = BifunctorFunctor

-- | Maps the effect inside an <a>EffFunctor</a>. Various names to follow
--   the <tt>bifunctors</tt>/<tt>profunctors</tt> conventions.
effmap :: EffFunctor f => (eff :-> eff') -> f eff :-> f eff'

-- | Maps the effect inside an <a>EffFunctor</a>. Various names to follow
--   the <tt>bifunctors</tt>/<tt>profunctors</tt> conventions.
effrmap :: EffFunctor f => (eff :-> eff') -> f eff :-> f eff'

-- | Maps the effect inside an <a>EffFunctor</a>. Various names to follow
--   the <tt>bifunctors</tt>/<tt>profunctors</tt> conventions.
effsecond :: EffFunctor f => (eff :-> eff') -> f eff :-> f eff'

-- | Pointed Functors (= functors equipped with <a>pure</a>) over binary
--   effects. Doesn't have an equivalent afaik in <tt>bifunctors</tt>.
class (EffFunctor f) => EffPointedFunctor f
effpure :: EffPointedFunctor f => eff :-> f eff

-- | Would be a "<tt>BifunctorBifunctor</tt>", but that class doesn't exist
class (forall a. (Arrow a) => (EffFunctor (p a))) => EffBifunctor p
effbimap :: (EffBifunctor p, Arrow a) => (a :-> a') -> (b :-> b') -> p a b :-> p a' b'
efffirst :: (EffBifunctor p, Arrow a) => (a :-> a') -> p a b :-> p a' b

-- | Would be a "<tt>ProfunctorBifunctor</tt>", but that class doesn't
--   exist.
class (forall a. (EffFunctor (p a))) => EffProfunctor p
effdimap :: EffProfunctor p => (a' :-> a) -> (b :-> b') -> p a b :-> p a' b'
efflmap :: EffProfunctor p => (a' :-> a) -> p a b :-> p a' b
instance GHC.Base.Applicative f => Data.Profunctor.EffFunctor.EffPointedFunctor (Data.Bifunctor.Tannen.Tannen f)


-- | This module exposes the SieveTrans class and some Sieve transformers
--   based on usual Reader and Writer
module Data.Profunctor.Trans

-- | A general version of <tt>Sieve</tt> that allows mapping and
--   recursively reaching the sieve
class SieveTrans f cat | cat -> f
liftSieve :: SieveTrans f cat => (a -> f b) -> cat a b
mapSieve :: SieveTrans f cat => ((a -> f b) -> a' -> f b') -> cat a b -> cat a' b'

-- | Just an alias
type HasKleisli = SieveTrans

-- | Just an alias
liftKleisli :: HasKleisli m eff => (a -> m b) -> eff a b

-- | Just an alias
mapKleisli :: HasKleisli m eff => ((a -> m b) -> a' -> m b') -> eff a b -> eff a' b'
type HasKleisliIO m eff = (HasKleisli m eff, MonadIO m)

-- | When you want to lift some IO action in a Sieve of any MonadIO
liftKleisliIO :: HasKleisliIO m eff => (a -> IO b) -> eff a b

-- | An alias to make signatures more readable
type (~>) = Cayley
infixr 1 ~>
type Reader r = Reader r
type Writer w = Writer w
fmapping :: Functor f => f t -> (t -> eff a b) -> (f ~> eff) a b

-- | mapCayley in profunctors maps the functor. mapCayleyEff maps the
--   effect in it.
mapCayleyEff :: Functor f => (eff a b -> eff' a' b') -> (f ~> eff) a b -> (f ~> eff') a' b'
reading :: (t -> eff a b) -> (Reader t ~> eff) a b
mapReader :: (t' -> eff a b -> (t, eff' a' b')) -> (Reader t ~> eff) a b -> (Reader t' ~> eff') a' b'
mapReader_ :: (t -> eff a b -> eff' a' b') -> (Reader t ~> eff) a b -> (Reader t ~> eff') a' b'
runReader :: t -> (Reader t ~> eff) a b -> eff a b
writing :: w -> eff :-> (Writer w ~> eff)
mapWriter :: (w -> eff a b -> (w', eff' a' b')) -> (Writer w ~> eff) a b -> (Writer w' ~> eff') a' b'
mapWriter_ :: (w -> eff a b -> eff' a' b') -> (Writer w ~> eff) a b -> (Writer w ~> eff') a' b'
runWriter :: (Writer w ~> eff) a b -> (w, eff a b)
runWriter_ :: (Writer w ~> eff) a b -> eff a b
swap :: (a, b) -> (b, a)
returning :: Arrow eff => b -> eff a b

-- | Just a flipped variant of runKleisli
perform :: a -> Kleisli m a b -> m b
instance Data.Profunctor.Trans.SieveTrans f (Data.Profunctor.Types.Star f)
instance Data.Profunctor.Trans.SieveTrans m (Control.Arrow.Kleisli m)
instance (Data.Profunctor.Trans.SieveTrans f cat, GHC.Base.Applicative f') => Data.Profunctor.Trans.SieveTrans f (Data.Profunctor.Cayley.Cayley f' cat)
instance (Data.Profunctor.Trans.SieveTrans f cat, GHC.Base.Applicative f) => Data.Profunctor.Trans.SieveTrans f (Data.Bifunctor.Tannen.Tannen f cat)


-- | Helper functions for Arrow effects
module Control.Kernmantle.Arrow

-- | Map an arrow over a list using (***)
parMapA :: ArrowChoice a => a b c -> a [b] [c]

-- | Map an arrow over a list using (&gt;&gt;&gt;) and <a>first</a>
seqMapA :: ArrowChoice a => a b c -> a [b] [c]

-- | Repeats an arrow step in order to fold a list
foldlA :: ArrowChoice a => a (b, acc) acc -> a ([b], acc) acc

-- | Filter a list given an arrow filter
filterA :: ArrowChoice a => a b Bool -> a [b] [b]

-- | If a <a>TryEffect</a> is also an <a>ArrowChoice</a>, then we can
--   implement catch
catchE :: (TryEffect ex eff, ArrowChoice eff) => eff e c -> eff (e, ex) c -> eff e c

-- | A SplitId is a ratio of two positive numbers
newtype SplitId
SplitId :: Ratio Word -> SplitId

-- | <a>split</a> defines the Calkin-Wilf tree. Its guaranteed never to
--   produce twice the same result if we split repeatedly starting from 1.
split :: (s -> SplitId) -> (s -> SplitId -> s) -> (s -> a) -> (a -> b -> c) -> (s -> b) -> s -> c

-- | The identifiers reflect the structure of the pipeline that led to some
--   task. They are <a>split</a> at every use of (.), (***), (|||) or
--   (<a>+</a>). This makes it so every task in the pipeline has a
--   different identifier.
data ArrowIdent
ArrowIdent :: {-# UNPACK #-} !SplitId -> {-# UNPACK #-} !SplitId -> {-# UNPACK #-} !SplitId -> {-# UNPACK #-} !SplitId -> ArrowIdent
[aidChoice] :: ArrowIdent -> {-# UNPACK #-} !SplitId
[aidPlus] :: ArrowIdent -> {-# UNPACK #-} !SplitId
[aidPar] :: ArrowIdent -> {-# UNPACK #-} !SplitId
[aidComp] :: ArrowIdent -> {-# UNPACK #-} !SplitId

-- | An arrow transformer that can automatically determine an identifier
--   from its position in a pipeline. It is isomorphic to a <tt>Reader
--   ArrowIdent ~&gt; arr</tt>, but we need a different Arrow instance than
--   what <a>Cayley</a> provides.
newtype AutoIdent arr a b
AutoIdent :: (ArrowIdent -> arr a b) -> AutoIdent arr a b
runAutoIdent' :: SplitId -> AutoIdent arr a b -> arr a b
runAutoIdent :: AutoIdent arr a b -> arr a b

-- | All effects that internally feature some AutoIdent
class HasAutoIdent wrappedEff eff | eff -> wrappedEff
liftAutoIdent :: HasAutoIdent wrappedEff eff => (ArrowIdent -> wrappedEff a b) -> eff a b
instance GHC.Num.Num Control.Kernmantle.Arrow.SplitId
instance GHC.Classes.Ord Control.Kernmantle.Arrow.SplitId
instance GHC.Classes.Eq Control.Kernmantle.Arrow.SplitId
instance GHC.Generics.Generic Control.Kernmantle.Arrow.SplitId
instance GHC.Classes.Ord Control.Kernmantle.Arrow.ArrowIdent
instance GHC.Classes.Eq Control.Kernmantle.Arrow.ArrowIdent
instance GHC.Generics.Generic Control.Kernmantle.Arrow.ArrowIdent
instance Control.Arrow.ArrowLoop arr => Control.Arrow.ArrowLoop (Control.Kernmantle.Arrow.AutoIdent arr)
instance Control.Arrow.ArrowZero arr => Control.Arrow.ArrowZero (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Mapping.Mapping arr => Data.Profunctor.Mapping.Mapping (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Traversing.Traversing arr => Data.Profunctor.Traversing.Traversing (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Closed.Closed arr => Data.Profunctor.Closed.Closed (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Choice.Cochoice arr => Data.Profunctor.Choice.Cochoice (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Choice.Choice arr => Data.Profunctor.Choice.Choice (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Strong.Costrong arr => Data.Profunctor.Strong.Costrong (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Strong.Strong arr => Data.Profunctor.Strong.Strong (Control.Kernmantle.Arrow.AutoIdent arr)
instance Data.Profunctor.Unsafe.Profunctor arr => Data.Profunctor.Unsafe.Profunctor (Control.Kernmantle.Arrow.AutoIdent arr)
instance Control.Kernmantle.Arrow.HasAutoIdent eff (Control.Kernmantle.Arrow.AutoIdent eff)
instance (Control.Kernmantle.Arrow.HasAutoIdent ai eff, GHC.Base.Applicative f) => Control.Kernmantle.Arrow.HasAutoIdent ai (Data.Profunctor.Cayley.Cayley f eff)
instance Control.Category.Category eff => Control.Category.Category (Control.Kernmantle.Arrow.AutoIdent eff)
instance Control.Arrow.Arrow eff => Control.Arrow.Arrow (Control.Kernmantle.Arrow.AutoIdent eff)
instance Control.Arrow.ArrowPlus eff => Control.Arrow.ArrowPlus (Control.Kernmantle.Arrow.AutoIdent eff)
instance Control.Arrow.ArrowChoice eff => Control.Arrow.ArrowChoice (Control.Kernmantle.Arrow.AutoIdent eff)
instance Data.Profunctor.Trans.SieveTrans f eff => Data.Profunctor.Trans.SieveTrans f (Control.Kernmantle.Arrow.AutoIdent eff)
instance GHC.Show.Show Control.Kernmantle.Arrow.ArrowIdent
instance GHC.Show.Show Control.Kernmantle.Arrow.SplitId

module Control.Kernmantle.Rope.Internal

-- | The kind for all binary effects. First param is usually an input
--   (contravariant) of the effect and second one an output (covariant).
type BinEff = * -> * -> *

-- | The kind for unary effects
type UnaryEff = * -> *

-- | The kind for a named binary effect. Must remain a tuple because that's
--   what vinyl expects.
type Strand = (Symbol, BinEff)
type family StrandName t
type family StrandEff t

-- | The kind for records that will contain <a>Weaver</a>s. First type
--   param will most often be <tt>Weaver someCore</tt>
type RopeRec = (Strand -> *) -> [Strand] -> *

-- | Runs one <tt>strand</tt> (* -&gt; * -&gt; * effect) in a
--   <tt>interp</tt> effect. Is parameterized over a Strand (and not just a
--   BinEffect) even if it ignores its name internally because that's what
--   is expect by the <a>RopeRec</a>
newtype Weaver (interp :: BinEff) (strand :: Strand)
Weaver :: (StrandEff strand :-> interp) -> Weaver (interp :: BinEff) (strand :: Strand)
[weaveStrand] :: Weaver (interp :: BinEff) (strand :: Strand) -> StrandEff strand :-> interp
mapWeaverInterp :: (interp :-> interp') -> Weaver interp strand -> Weaver interp' strand

-- | The internal implementation of a Rope, where <tt>interp</tt> and
--   <tt>core</tt> can be two different types (this facilitates
--   implementation of some functions).
--   
--   <tt>record</tt> holds the functions to interpret the <tt>strands</tt>
--   in an <tt>interp</tt> effect. And then all these interpreted effects
--   will run in a <tt>core</tt> effect.
newtype RopeRunner (record :: RopeRec) (mantle :: [Strand]) (interp :: BinEff) (core :: BinEff) a b
RopeRunner :: (record (Weaver interp) mantle -> core a b) -> RopeRunner (record :: RopeRec) (mantle :: [Strand]) (interp :: BinEff) (core :: BinEff) a b

-- | Splits a <a>RopeRunner</a> in two parts, so we can select several
--   strands to act on
splitRopeRunner :: RopeRunner Rec (mantle1 ++ mantle2) interp core :-> RopeRunner Rec mantle1 interp (RopeRunner Rec mantle2 interp core)

-- | Indicates that <tt>strands</tt> can be reordered and considered a
--   subset of <tt>strands'</tt>
type RetwinableAs record strands core strands' = (RecSubset record strands strands' (RImage strands strands'), RecSubsetFCtx record (Weaver core))
joinRopeRunner :: (RetwinableAs r mantle1 interp mantle, RetwinableAs r mantle2 interp mantle) => RopeRunner r mantle1 interp (RopeRunner r mantle2 interp core) :-> RopeRunner r mantle interp core

-- | Wrap each strand effect inside a type constructor
type family MapStrandEffs f mantle
effmapRopeRec :: EffFunctor f => Rec (Weaver interp) strands -> Rec (Weaver (f interp)) (MapStrandEffs f strands)

-- | When all the strands of a <tt>Rope</tt> are built by the same
--   <a>EffFunctor</a>, we can run them. See <tt>splitRope</tt> to isolate
--   some strands in a <tt>Rope</tt>
unwrapRopeRunner :: EffFunctor f => RopeRunner Rec (MapStrandEffs f strands) (f core) core :-> RopeRunner Rec strands core core
unwrapSomeStrands :: (EffFunctor f, RMap (MapStrandEffs f mantle1)) => (f core' :-> interp) -> (RopeRunner Rec mantle2 interp core :-> core') -> RopeRunner Rec (MapStrandEffs f mantle1 ++ mantle2) interp core :-> RopeRunner Rec mantle1 core' core'
instance Data.Profunctor.EffFunctor.EffPointedFunctor (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp)
instance Data.Bifunctor.Functor.BifunctorFunctor (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp)
instance Data.Biapplicative.Biapplicative core => Data.Biapplicative.Biapplicative (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Bifunctor.Bifunctor core => Data.Bifunctor.Bifunctor (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Monad.ProfunctorMonad (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp)
instance Data.Profunctor.Monad.ProfunctorFunctor (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp)
instance Control.Kernmantle.Arrow.HasAutoIdent eff core => Control.Kernmantle.Arrow.HasAutoIdent eff (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Trans.SieveTrans f core => Data.Profunctor.Trans.SieveTrans f (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Kernmantle.Error.TryEffect ex core => Control.Kernmantle.Error.TryEffect ex (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Kernmantle.Error.ThrowEffect ex core => Control.Kernmantle.Error.ThrowEffect ex (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Traversing.Traversing core => Data.Profunctor.Traversing.Traversing (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Mapping.Mapping core => Data.Profunctor.Mapping.Mapping (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Choice.Cochoice core => Data.Profunctor.Choice.Cochoice (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Strong.Costrong core => Data.Profunctor.Strong.Costrong (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Closed.Closed core => Data.Profunctor.Closed.Closed (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Choice.Choice core => Data.Profunctor.Choice.Choice (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Strong.Strong core => Data.Profunctor.Strong.Strong (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Profunctor.Unsafe.Profunctor core => Data.Profunctor.Unsafe.Profunctor (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Arrow.ArrowPlus core => Control.Arrow.ArrowPlus (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Arrow.ArrowZero core => Control.Arrow.ArrowZero (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Arrow.ArrowLoop core => Control.Arrow.ArrowLoop (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Arrow.ArrowChoice core => Control.Arrow.ArrowChoice (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Arrow.Arrow core => Control.Arrow.Arrow (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Control.Category.Category core => Control.Category.Category (Control.Kernmantle.Rope.Internal.RopeRunner record mantle interp core)
instance Data.Vinyl.Core.RMap m => Data.Profunctor.EffFunctor.EffProfunctor (Control.Kernmantle.Rope.Internal.RopeRunner Data.Vinyl.Core.Rec m)


-- | A <a>Rope</a> connects together various effect <a>Strand</a>s that get
--   interlaced together.
--   
--   A <a>Strand</a> is an effet with a parameter and an output. No
--   constraint is placed on the <a>Strand</a>, but once combined in a
--   <a>Rope</a>, that <a>Rope</a> will be an <a>Arrow</a> and a
--   <a>Profunctor</a>. <a>Strand</a>s in a <a>Rope</a> are named via
--   labels to limit ambiguity.
--   
--   An action that targets some <a>Strand</a> can be lifted to a
--   <a>Rope</a> that contains that <a>Strand</a> with the <a>strand</a>
--   function.
module Control.Kernmantle.Rope

-- | Static arrows. Lifted by <a>Applicative</a>.
--   
--   <a>Cayley</a> has a polymorphic kind since <tt>5.6</tt>.
newtype Cayley (f :: k -> Type) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2)
Cayley :: f (p a b) -> Cayley (f :: k -> Type) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2)
[runCayley] :: Cayley (f :: k -> Type) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2) -> f (p a b)

-- | <a>Rope</a> is a free arrow built out of _several_ binary effects (ie.
--   effects with kind * -&gt; * -&gt; *). These effects are called
--   <a>Strand</a>s, they compose the <tt>mantle</tt>, can be interpreted
--   in an <tt>interp</tt> effect and can be interlaced "on top" of an
--   existing <tt>core</tt> effect.
data Rope (record :: RopeRec) (mantle :: [Strand]) (core :: BinEff) a b

-- | A <a>Rope</a> that is "tight", meaning you cannot <a>weave</a> new
--   <a>Strand</a>s to it. The <a>strand</a> function is <tt>O(1)</tt> on
--   <a>TightRope</a>s whatever the number of <a>Strand</a>s.
type TightRope = Rope ARec

-- | A <a>Rope</a> that is "loose", meaning you can <a>weave</a> new
--   <a>Strand</a>s to it. The <a>strand</a> function is <tt>O(n)</tt> on
--   <a>LooseRope</a>s, <tt>n</tt> being the number of <a>Strand</a>s.
type LooseRope = Rope Rec

-- | Turn a <a>LooseRope</a> into a <a>TightRope</a>
tighten :: (RecApplicative m, RPureConstrained (IndexableField m) m) => LooseRope m core :-> TightRope m core

-- | Turn a <a>TightRope</a> into a <a>LooseRope</a>. This is very often
--   the first step in a chain of <a>weave</a>s.
loosen :: NatToInt (RLength m) => TightRope m core :-> LooseRope m core

-- | Applies a function on the core action of the Rope
mapRopeCore :: (core a b -> core a' b') -> Rope r m core a b -> Rope r m core a' b'

-- | Merge two strands that have the same effect type. Keeps the first
--   name.
mergeStrands :: Label n1 -> Label n2 -> LooseRope ('(n1, binEff) : ('(n2, binEff) : mantle)) core :-> LooseRope ('(n1, binEff) : mantle) core

-- | The kind for all binary effects. First param is usually an input
--   (contravariant) of the effect and second one an output (covariant).
type BinEff = * -> * -> *

-- | The kind for a named binary effect. Must remain a tuple because that's
--   what vinyl expects.
type Strand = (Symbol, BinEff)

-- | Alias for Field spec
type (a :: k) ::: (b :: k1) = '(a, b)
type family StrandName t
type family StrandEff t

-- | Tells that a strand of effects '(l,eff) is present in the rope
type family InRope l eff rope

-- | Useful for functions that want to use tighten/loosen
type AllInMantle strands mantle core = (NatToInt (RLength mantle), RecApplicative mantle, RPureConstrained (IndexableField mantle) mantle, LooseRope mantle core `Entwines` strands, TightRope mantle core `Entwines` strands)
strand :: InRope l eff (Rope r m c) => Label l -> eff :-> Rope r m c
mapStrand :: InRope l eff (Rope r m c) => Label l -> (eff :-> eff) -> Rope r m c :-> Rope r m c

-- | Adds a new effect strand in the <a>Rope</a> by decribing how to
--   interpret that in the core. The interpretation function is fed the
--   fixpoint of all interpretation functions, meaning the interpretation
--   function can itself use effects in the <a>Rope</a>. For example, given
--   an effect <tt>Eff</tt>, whose label is "effect" being interpreted in a
--   core effect <tt>CoreEff</tt>, one first defines an interpretation
--   function:
--   
--   <pre>
--   interpret ::
--     (LooseRope '("effect",Eff) ': mantle) core :-&gt; CoreEff) -&gt;
--      Eff a b -&gt; CoreEff a b
--   
--   interpret ::
--     (LooseRope '("effect",Eff) ': mantle) core :-&gt; CoreEff) -&gt;
--     (Eff :-&gt; CoreEff)
--   </pre>
--   
--   where <tt>p :-&gt; q</tt> corresponds to <tt>forall a b. p a b -&gt; q
--   a b</tt>, and obtain an interpreter for the strand:
--   
--   <pre>
--   strandInterpreter ::
--     LooseRope ('("effect",Eff) ': mantle) CoreEff :-&gt;
--     LooseRope mantle CoreEff
--   strandInterpreter = weave #effect interpret
--   </pre>
weave :: forall name binEff mantle core. Label name -> ((LooseRope ('(name, binEff) : mantle) core :-> core) -> binEff :-> core) -> LooseRope ('(name, binEff) : mantle) core :-> LooseRope mantle core

-- | A version of <a>weave</a> where the strand can be directly interpreted
--   in the core with no need to trigger other effects. For example, given
--   an effect <tt>Eff</tt>, whose label is "effect" being interpreted in a
--   core effect <tt>CoreEff</tt>, one first defines an interpretation
--   function:
--   
--   <pre>
--   interpret :: Eff a b -&gt; CoreEff a b
--   interpret :: Eff :-&gt; CoreEff
--   </pre>
--   
--   and obtain an interpreter for the strand:
--   
--   <pre>
--   strandInterpreter ::
--     LooseRope ('("effect",Eff) ': mantle) CoreEff :-&gt;
--     LooseRope mantle CoreEff
--   strandInterpreter = weave' #effect interpret
--   </pre>
weave' :: forall name binEff mantle core. Label name -> (binEff :-> core) -> LooseRope ('(name, binEff) : mantle) core :-> LooseRope mantle core

-- | A shortcut for <a>weave'</a> when your core <a>HasKleisli</a>
weaveK :: HasKleisli m core => Label name -> (forall a b. binEff a b -> a -> m b) -> LooseRope ('(name, binEff) : mantle) core :-> LooseRope mantle core

-- | Supports <a>weaveAll</a> over any <a>Rope</a>
class WeaveAll mantle core

-- | Weaves all the remaining strands in the core, provided a
--   polymorphic-enough interpretation function can be provided.
--   
--   This function is notably useful to implement the "Rope-in-Rope"
--   pattern, when a <a>Rope</a> (possibly wrapped in <a>Cayley</a>) is
--   used as the code for another <a>Rope</a>. <a>weaveAll</a> in that case
--   permits to transfer all the effects of the outer <a>Rope</a> to the
--   core <a>Rope</a>.
weaveAll :: WeaveAll mantle core => (forall lbl eff. lbl -> eff :-> core) -> LooseRope mantle core :-> core

-- | Reorders the strands to match some external context. <tt>strands'</tt>
--   can contain more elements than <tt>strands</tt>. Note it works on both
--   <a>TightRope</a>s and <a>LooseRope</a>s
retwine :: RetwinableAs r strands core strands' => Rope r strands core :-> Rope r strands' core

-- | Strips a <a>Rope</a> of its empty mantle. Usually the last step of the
--   interpretation of a <a>Rope</a>.
untwine :: LooseRope '[] core :-> core

-- | A <tt>AnyRopeWith strands costraints</tt> is a <a>Rope</a> with
--   contains the strands in the variable <tt>strands</tt> , and whose core
--   effect obeys the constraints in the <tt>contraints</tt> variable.
type AnyRopeWith strands coreConstraints a b = forall mantle r core. (Rope r mantle core `Entwines` strands, core `SatisfiesAll` coreConstraints) => Rope r mantle core a b
type TightRopeWith strands coreConstraints a b = forall mantle core. (TightRope mantle core `Entwines` strands, core `SatisfiesAll` coreConstraints) => TightRope mantle core a b
type LooseRopeWith strands coreConstraints a b = forall mantle core. (LooseRope mantle core `Entwines` strands, core `SatisfiesAll` coreConstraints) => LooseRope mantle core a b

-- | Tells whether a collection of <tt>strands</tt> is in a <a>Rope</a>.
type family rope `Entwines` (strands :: [Strand]) :: Constraint

-- | Tells whether a type satisfies all the given constraints.
type family (x :: k) `SatisfiesAll` (csts :: [k -> Constraint]) :: Constraint

-- | (<a>:-&gt;</a>) has a polymorphic kind since <tt>5.6</tt>.
type (p :: k -> k1 -> Type) :-> (q :: k -> k1 -> Type) = forall (a :: k) (b :: k1). () => p a b -> q a b
infixr 0 :->

-- | Proxy for label type
data Label (a :: Symbol)
fromLabel :: IsLabel x a => a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &
mkRope :: (record (Weaver core) mantle -> core a b) -> Rope record mantle core a b
runRope :: Rope record mantle core a b -> record (Weaver core) mantle -> core a b
instance Data.Biapplicative.Biapplicative core => Data.Biapplicative.Biapplicative (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Bifunctor.Bifunctor core => Data.Bifunctor.Bifunctor (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Kernmantle.Arrow.HasAutoIdent eff core => Control.Kernmantle.Arrow.HasAutoIdent eff (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Trans.SieveTrans f core => Data.Profunctor.Trans.SieveTrans f (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Kernmantle.Error.TryEffect ex core => Control.Kernmantle.Error.TryEffect ex (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Kernmantle.Error.ThrowEffect ex core => Control.Kernmantle.Error.ThrowEffect ex (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Traversing.Traversing core => Data.Profunctor.Traversing.Traversing (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Mapping.Mapping core => Data.Profunctor.Mapping.Mapping (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Choice.Cochoice core => Data.Profunctor.Choice.Cochoice (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Strong.Costrong core => Data.Profunctor.Strong.Costrong (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Closed.Closed core => Data.Profunctor.Closed.Closed (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Choice.Choice core => Data.Profunctor.Choice.Choice (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Strong.Strong core => Data.Profunctor.Strong.Strong (Control.Kernmantle.Rope.Rope record mantle core)
instance Data.Profunctor.Unsafe.Profunctor core => Data.Profunctor.Unsafe.Profunctor (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Arrow.ArrowPlus core => Control.Arrow.ArrowPlus (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Arrow.ArrowZero core => Control.Arrow.ArrowZero (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Arrow.ArrowLoop core => Control.Arrow.ArrowLoop (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Arrow.ArrowChoice core => Control.Arrow.ArrowChoice (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Arrow.Arrow core => Control.Arrow.Arrow (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Category.Category core => Control.Category.Category (Control.Kernmantle.Rope.Rope record mantle core)
instance Control.Kernmantle.Rope.WeaveAll '[] core
instance Control.Kernmantle.Rope.WeaveAll mantle core => Control.Kernmantle.Rope.WeaveAll ((name Data.Vinyl.Derived.::: eff) : mantle) core
