-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A small compatibility shim for the transformers library
--   
--   This package includes backported versions of types that were added to
--   transformers in transformers 0.3, 0.4, and 0.5 for users who need
--   strict transformers 0.2 or 0.3 compatibility to run on old versions of
--   the platform, but also need those types.
--   
--   Those users should be able to just depend on <tt>transformers &gt;=
--   0.2</tt> and <tt>transformers-compat &gt;= 0.3</tt>.
--   
--   Note: missing methods are not supplied, but this at least permits the
--   types to be used.
@package transformers-compat
@version 0.6.6


-- | Backports orphan instances which are not provided by other modules in
--   <tt>transformers-compat</tt>.
module Control.Monad.Trans.Instances


-- | Internal functionality for <a>Data.Functor.Classes.Generic</a>.
--   
--   This is an internal module and, as such, the API is not guaranteed to
--   remain the same between any given release.
module Data.Functor.Classes.Generic.Internal

-- | Options that further configure how the functions in
--   <a>Data.Functor.Classes.Generic</a> should behave.
newtype Options
Options :: Bool -> Options

-- | If <a>True</a>, a default <a>Show1</a> implementation will show hash
--   signs (<tt>#</tt>) when showing unlifted types.
[ghc8ShowBehavior] :: Options -> Bool

-- | Options that match the behavior of the installed version of GHC.
defaultOptions :: Options

-- | Options that match the behavior of the most recent GHC release.
latestGHCOptions :: Options

-- | A sensible default <a>liftEq</a> implementation for <a>Generic1</a>
--   instances.
liftEqDefault :: (GEq1 NonV4 (Rep1 f), Generic1 f) => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Like <a>liftEqDefault</a>, but with configurable <a>Options</a>.
--   Currently, the <a>Options</a> have no effect (but this may change in
--   the future).
liftEqOptions :: (GEq1 NonV4 (Rep1 f), Generic1 f) => Options -> (a -> b -> Bool) -> f a -> f b -> Bool

-- | Class of generic representation types that can be checked for
--   equality.
class GEq1 v t
gliftEq :: GEq1 v t => Eq1Args v a b -> t a -> t b -> Bool

-- | An <a>Eq1Args</a> value either stores an <tt>Eq a</tt> dictionary (for
--   the <tt>transformers-0.4</tt> version of <a>Eq1</a>), or it stores the
--   function argument that checks the equality of occurrences of the type
--   parameter (for the non-<tt>transformers-0.4</tt> version of
--   <a>Eq1</a>).
data Eq1Args v a b
[V4Eq1Args] :: Eq a => Eq1Args V4 a a
[NonV4Eq1Args] :: (a -> b -> Bool) -> Eq1Args NonV4 a b

-- | A sensible default <a>liftCompare</a> implementation for
--   <a>Generic1</a> instances.
liftCompareDefault :: (GOrd1 NonV4 (Rep1 f), Generic1 f) => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Like <a>liftCompareDefault</a>, but with configurable <a>Options</a>.
--   Currently, the <a>Options</a> have no effect (but this may change in
--   the future).
liftCompareOptions :: (GOrd1 NonV4 (Rep1 f), Generic1 f) => Options -> (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Class of generic representation types that can be totally ordered.
class GEq1 v t => GOrd1 v t
gliftCompare :: GOrd1 v t => Ord1Args v a b -> t a -> t b -> Ordering

-- | An <a>Ord1Args</a> value either stores an <tt>Ord a</tt> dictionary
--   (for the <tt>transformers-0.4</tt> version of <a>Ord1</a>), or it
--   stores the function argument that compares occurrences of the type
--   parameter (for the non-<tt>transformers-0.4</tt> version of
--   <a>Ord1</a>).
data Ord1Args v a b
[V4Ord1Args] :: Ord a => Ord1Args V4 a a
[NonV4Ord1Args] :: (a -> b -> Ordering) -> Ord1Args NonV4 a b

-- | A sensible default <a>liftReadsPrec</a> implementation for
--   <a>Generic1</a> instances.
liftReadsPrecDefault :: (GRead1 NonV4 (Rep1 f), Generic1 f) => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | Like <a>liftReadsPrecDefault</a>, but with configurable
--   <a>Options</a>. Currently, the <a>Options</a> have no effect (but this
--   may change in the future).
liftReadsPrecOptions :: (GRead1 NonV4 (Rep1 f), Generic1 f) => Options -> (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | Class of generic representation types that can be parsed from a
--   <a>String</a>.
class GRead1 v f
gliftReadPrec :: GRead1 v f => Read1Args v a -> ReadPrec (f a)

-- | Class of generic representation types that can be parsed from a
--   <a>String</a>, and for which the <a>ConType</a> has been determined.
class GRead1Con v f
gliftReadPrecCon :: GRead1Con v f => ConType -> Read1Args v a -> ReadPrec (f a)

-- | A <a>Read1Args</a> value either stores a <tt>Read a</tt> dictionary
--   (for the <tt>transformers-0.4</tt> version of <a>Read1</a>), or it
--   stores the two function arguments that parse occurrences of the type
--   parameter (for the non-<tt>transformers-0.4</tt> version of
--   <a>Read1</a>).
data Read1Args v a
[V4Read1Args] :: Read a => Read1Args V4 a
[NonV4Read1Args] :: ReadPrec a -> ReadPrec [a] -> Read1Args NonV4 a

-- | A sensible default <a>liftShowsPrec</a> implementation for
--   <a>Generic1</a> instances.
liftShowsPrecDefault :: (GShow1 NonV4 (Rep1 f), Generic1 f) => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | Like <a>liftShowsPrecDefault</a>, but with configurable
--   <a>Options</a>.
liftShowsPrecOptions :: (GShow1 NonV4 (Rep1 f), Generic1 f) => Options -> (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | Class of generic representation types that can be converted to a
--   <a>String</a>.
class GShow1 v f
gliftShowsPrec :: GShow1 v f => Options -> Show1Args v a -> Int -> f a -> ShowS

-- | Class of generic representation types that can be converted to a
--   <a>String</a>, and for which the <a>ConType</a> has been determined.
class GShow1Con v f
gliftShowsPrecCon :: GShow1Con v f => Options -> ConType -> Show1Args v a -> Int -> f a -> ShowS

-- | A <a>Show1Args</a> value either stores a <tt>Show a</tt> dictionary
--   (for the <tt>transformers-0.4</tt> version of <a>Show1</a>), or it
--   stores the two function arguments that show occurrences of the type
--   parameter (for the non-<tt>transformers-0.4</tt> version of
--   <a>Show1</a>).
data Show1Args v a
[V4Show1Args] :: Show a => Show1Args V4 a
[NonV4Show1Args] :: (Int -> a -> ShowS) -> ([a] -> ShowS) -> Show1Args NonV4 a

-- | An adapter newtype, suitable for <tt>DerivingVia</tt>. Its <a>Eq1</a>,
--   <a>Ord1</a>, <a>Read1</a>, and <a>Show1</a> instances leverage
--   <a>Generic1</a>-based defaults.
newtype FunctorClassesDefault f a
FunctorClassesDefault :: f a -> FunctorClassesDefault f a
[getFunctorClassesDefault] :: FunctorClassesDefault f a -> f a

-- | A type-level indicator that the <tt>transformers-0.4</tt> version of a
--   class method is being derived generically.
data V4

-- | A type-level indicator that the non-<tt>transformers-0.4</tt> version
--   of a class method is being derived generically.
data NonV4

-- | Whether a constructor is a record (<a>Rec</a>), a tuple (<a>Tup</a>),
--   is prefix (<a>Pref</a>), or infix (<a>Inf</a>).
data ConType
Rec :: ConType
Tup :: ConType
Pref :: ConType
Inf :: String -> ConType

-- | Class of generic representation types that represent a data type with
--   zero or more constructors.
class IsNullaryDataType f

-- | Returns <a>True</a> if the data type has no constructors.
isNullaryDataType :: IsNullaryDataType f => f a -> Bool

-- | Class of generic representation types that represent a constructor
--   with zero or more fields.
class IsNullaryCon f

-- | Returns <a>True</a> if the constructor has no fields.
isNullaryCon :: IsNullaryCon f => f a -> Bool
instance (GHC.Generics.Constructor c, Data.Functor.Classes.Generic.Internal.GRead1Con v f, Data.Functor.Classes.Generic.Internal.IsNullaryCon f) => Data.Functor.Classes.Generic.Internal.GRead1 v (GHC.Generics.C1 c f)
instance (GHC.Generics.Constructor c, Data.Functor.Classes.Generic.Internal.GShow1Con v f, Data.Functor.Classes.Generic.Internal.IsNullaryCon f) => Data.Functor.Classes.Generic.Internal.GShow1 v (GHC.Generics.C1 c f)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.U1
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.Par1
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon (GHC.Generics.K1 i c)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon f => Data.Functor.Classes.Generic.Internal.IsNullaryCon (GHC.Generics.S1 s f)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon (GHC.Generics.Rec1 f)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon (f GHC.Generics.:*: g)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon (f GHC.Generics.:.: g)
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.UChar
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.UDouble
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.UFloat
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.UInt
instance Data.Functor.Classes.Generic.Internal.IsNullaryCon GHC.Generics.UWord
instance (Data.Functor.Classes.Generic.Internal.GRead1 v f, Data.Functor.Classes.Generic.Internal.IsNullaryDataType f) => Data.Functor.Classes.Generic.Internal.GRead1 v (GHC.Generics.D1 d f)
instance Data.Functor.Classes.Generic.Internal.IsNullaryDataType (f GHC.Generics.:+: g)
instance Data.Functor.Classes.Generic.Internal.IsNullaryDataType (GHC.Generics.C1 c f)
instance Data.Functor.Classes.Generic.Internal.IsNullaryDataType GHC.Generics.V1
instance Data.Functor.Classes.Generic.Internal.GRead1Con v GHC.Generics.U1
instance GHC.Read.Read c => Data.Functor.Classes.Generic.Internal.GRead1Con v (GHC.Generics.K1 i c)
instance (GHC.Generics.Selector s, Data.Functor.Classes.Generic.Internal.GRead1Con v f) => Data.Functor.Classes.Generic.Internal.GRead1Con v (GHC.Generics.S1 s f)
instance (Data.Functor.Classes.Generic.Internal.GRead1Con v f, Data.Functor.Classes.Generic.Internal.GRead1Con v g) => Data.Functor.Classes.Generic.Internal.GRead1Con v (f GHC.Generics.:*: g)
instance Data.Functor.Classes.Generic.Internal.GRead1Con Data.Functor.Classes.Generic.Internal.NonV4 GHC.Generics.Par1
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Generic.Internal.GRead1Con Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rec1 f)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Generic.Internal.GRead1Con Data.Functor.Classes.Generic.Internal.NonV4 g) => Data.Functor.Classes.Generic.Internal.GRead1Con Data.Functor.Classes.Generic.Internal.NonV4 (f GHC.Generics.:.: g)
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.U1
instance GHC.Show.Show c => Data.Functor.Classes.Generic.Internal.GShow1Con v (GHC.Generics.K1 i c)
instance (GHC.Generics.Selector s, Data.Functor.Classes.Generic.Internal.GShow1Con v f) => Data.Functor.Classes.Generic.Internal.GShow1Con v (GHC.Generics.S1 s f)
instance (Data.Functor.Classes.Generic.Internal.GShow1Con v f, Data.Functor.Classes.Generic.Internal.GShow1Con v g) => Data.Functor.Classes.Generic.Internal.GShow1Con v (f GHC.Generics.:*: g)
instance Data.Functor.Classes.Generic.Internal.GShow1Con Data.Functor.Classes.Generic.Internal.NonV4 GHC.Generics.Par1
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Generic.Internal.GShow1Con Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rec1 f)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Generic.Internal.GShow1Con Data.Functor.Classes.Generic.Internal.NonV4 g) => Data.Functor.Classes.Generic.Internal.GShow1Con Data.Functor.Classes.Generic.Internal.NonV4 (f GHC.Generics.:.: g)
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.UChar
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.UDouble
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.UFloat
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.UInt
instance Data.Functor.Classes.Generic.Internal.GShow1Con v GHC.Generics.UWord
instance (Data.Functor.Classes.Generic.Internal.GEq1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rep1 f), GHC.Generics.Generic1 f) => Data.Functor.Classes.Eq1 (Data.Functor.Classes.Generic.Internal.FunctorClassesDefault f)
instance (Data.Functor.Classes.Generic.Internal.GOrd1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rep1 f), GHC.Generics.Generic1 f) => Data.Functor.Classes.Ord1 (Data.Functor.Classes.Generic.Internal.FunctorClassesDefault f)
instance (Data.Functor.Classes.Generic.Internal.GRead1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rep1 f), GHC.Generics.Generic1 f) => Data.Functor.Classes.Read1 (Data.Functor.Classes.Generic.Internal.FunctorClassesDefault f)
instance (Data.Functor.Classes.Generic.Internal.GShow1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rep1 f), GHC.Generics.Generic1 f) => Data.Functor.Classes.Show1 (Data.Functor.Classes.Generic.Internal.FunctorClassesDefault f)
instance Data.Functor.Classes.Generic.Internal.GShow1 v f => Data.Functor.Classes.Generic.Internal.GShow1 v (GHC.Generics.D1 d f)
instance Data.Functor.Classes.Generic.Internal.GShow1 v GHC.Generics.V1
instance (Data.Functor.Classes.Generic.Internal.GShow1 v f, Data.Functor.Classes.Generic.Internal.GShow1 v g) => Data.Functor.Classes.Generic.Internal.GShow1 v (f GHC.Generics.:+: g)
instance Data.Functor.Classes.Generic.Internal.GRead1 v GHC.Generics.V1
instance (Data.Functor.Classes.Generic.Internal.GRead1 v f, Data.Functor.Classes.Generic.Internal.GRead1 v g) => Data.Functor.Classes.Generic.Internal.GRead1 v (f GHC.Generics.:+: g)
instance GHC.Classes.Ord c => Data.Functor.Classes.Generic.Internal.GOrd1 v (GHC.Generics.K1 i c)
instance (Data.Functor.Classes.Generic.Internal.GOrd1 v f, Data.Functor.Classes.Generic.Internal.GOrd1 v g) => Data.Functor.Classes.Generic.Internal.GOrd1 v (f GHC.Generics.:*: g)
instance (Data.Functor.Classes.Generic.Internal.GOrd1 v f, Data.Functor.Classes.Generic.Internal.GOrd1 v g) => Data.Functor.Classes.Generic.Internal.GOrd1 v (f GHC.Generics.:+: g)
instance Data.Functor.Classes.Generic.Internal.GOrd1 v f => Data.Functor.Classes.Generic.Internal.GOrd1 v (GHC.Generics.M1 i c f)
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.U1
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.V1
instance Data.Functor.Classes.Generic.Internal.GOrd1 Data.Functor.Classes.Generic.Internal.NonV4 GHC.Generics.Par1
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Generic.Internal.GOrd1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rec1 f)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Generic.Internal.GOrd1 Data.Functor.Classes.Generic.Internal.NonV4 g) => Data.Functor.Classes.Generic.Internal.GOrd1 Data.Functor.Classes.Generic.Internal.NonV4 (f GHC.Generics.:.: g)
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UAddr
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UChar
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UDouble
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UFloat
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UInt
instance Data.Functor.Classes.Generic.Internal.GOrd1 v GHC.Generics.UWord
instance GHC.Classes.Eq c => Data.Functor.Classes.Generic.Internal.GEq1 v (GHC.Generics.K1 i c)
instance (Data.Functor.Classes.Generic.Internal.GEq1 v f, Data.Functor.Classes.Generic.Internal.GEq1 v g) => Data.Functor.Classes.Generic.Internal.GEq1 v (f GHC.Generics.:*: g)
instance (Data.Functor.Classes.Generic.Internal.GEq1 v f, Data.Functor.Classes.Generic.Internal.GEq1 v g) => Data.Functor.Classes.Generic.Internal.GEq1 v (f GHC.Generics.:+: g)
instance Data.Functor.Classes.Generic.Internal.GEq1 v f => Data.Functor.Classes.Generic.Internal.GEq1 v (GHC.Generics.M1 i c f)
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.U1
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.V1
instance Data.Functor.Classes.Generic.Internal.GEq1 Data.Functor.Classes.Generic.Internal.NonV4 GHC.Generics.Par1
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Generic.Internal.GEq1 Data.Functor.Classes.Generic.Internal.NonV4 (GHC.Generics.Rec1 f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Generic.Internal.GEq1 Data.Functor.Classes.Generic.Internal.NonV4 g) => Data.Functor.Classes.Generic.Internal.GEq1 Data.Functor.Classes.Generic.Internal.NonV4 (f GHC.Generics.:.: g)
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UAddr
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UChar
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UDouble
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UFloat
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UInt
instance Data.Functor.Classes.Generic.Internal.GEq1 v GHC.Generics.UWord


-- | Functions to generically derive <a>Eq1</a>, <a>Ord1</a>, <a>Read1</a>,
--   and <a>Show1</a> instances from <a>Data.Functor.Classes</a>.
module Data.Functor.Classes.Generic

-- | Options that further configure how the functions in
--   <a>Data.Functor.Classes.Generic</a> should behave.
newtype Options
Options :: Bool -> Options

-- | If <a>True</a>, a default <a>Show1</a> implementation will show hash
--   signs (<tt>#</tt>) when showing unlifted types.
[ghc8ShowBehavior] :: Options -> Bool

-- | Options that match the behavior of the installed version of GHC.
defaultOptions :: Options

-- | Options that match the behavior of the most recent GHC release.
latestGHCOptions :: Options

-- | A sensible default <a>liftEq</a> implementation for <a>Generic1</a>
--   instances.
liftEqDefault :: (GEq1 NonV4 (Rep1 f), Generic1 f) => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Like <a>liftEqDefault</a>, but with configurable <a>Options</a>.
--   Currently, the <a>Options</a> have no effect (but this may change in
--   the future).
liftEqOptions :: (GEq1 NonV4 (Rep1 f), Generic1 f) => Options -> (a -> b -> Bool) -> f a -> f b -> Bool

-- | A sensible default <a>liftCompare</a> implementation for
--   <a>Generic1</a> instances.
liftCompareDefault :: (GOrd1 NonV4 (Rep1 f), Generic1 f) => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Like <a>liftCompareDefault</a>, but with configurable <a>Options</a>.
--   Currently, the <a>Options</a> have no effect (but this may change in
--   the future).
liftCompareOptions :: (GOrd1 NonV4 (Rep1 f), Generic1 f) => Options -> (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | A sensible default <a>liftReadsPrec</a> implementation for
--   <a>Generic1</a> instances.
liftReadsPrecDefault :: (GRead1 NonV4 (Rep1 f), Generic1 f) => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | Like <a>liftReadsPrecDefault</a>, but with configurable
--   <a>Options</a>. Currently, the <a>Options</a> have no effect (but this
--   may change in the future).
liftReadsPrecOptions :: (GRead1 NonV4 (Rep1 f), Generic1 f) => Options -> (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | A sensible default <a>liftShowsPrec</a> implementation for
--   <a>Generic1</a> instances.
liftShowsPrecDefault :: (GShow1 NonV4 (Rep1 f), Generic1 f) => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | Like <a>liftShowsPrecDefault</a>, but with configurable
--   <a>Options</a>.
liftShowsPrecOptions :: (GShow1 NonV4 (Rep1 f), Generic1 f) => Options -> (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | An adapter newtype, suitable for <tt>DerivingVia</tt>. Its <a>Eq1</a>,
--   <a>Ord1</a>, <a>Read1</a>, and <a>Show1</a> instances leverage
--   <a>Generic1</a>-based defaults.
newtype FunctorClassesDefault f a
FunctorClassesDefault :: f a -> FunctorClassesDefault f a
[getFunctorClassesDefault] :: FunctorClassesDefault f a -> f a
