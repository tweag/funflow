-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   This package contains the primitive types and operations supplied by
--   GHC.
@package ghc-prim
@version 0.6.1


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data {-# CTYPE "HsBool" #-} Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data {-# CTYPE "HsChar" #-} Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data {-# CTYPE "HsInt" #-} Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data {-# CTYPE "HsWord" #-} Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data {-# CTYPE "HsFloat" #-} Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data {-# CTYPE "HsDouble" #-} Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | (Kind) This is the kind of type-level symbols. Declared here because
--   class IP needs it
data Symbol

-- | The type constructor <a>Any</a> is type to which you can unsafely
--   coerce any lifted type, and back. More concretely, for a lifted type
--   <tt>t</tt> and value <tt>x :: t</tt>, -- <tt>unsafeCoerce
--   (unsafeCoerce x :: Any) :: t</tt> is equivalent to <tt>x</tt>.
type family Any :: k

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
class a ~~ b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible (a :: k) (b :: k)
data TYPE (a :: RuntimeRep)

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain âŠ¥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | lifted; represented by a pointer
LiftedRep :: RuntimeRep

-- | unlifted; represented by a pointer
UnliftedRep :: RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value (on 32-bit only)
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value (on 32-bit only)
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE 'LiftedRep

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem
data Module
Module :: TrName -> TrName -> Module
data TrName
TrNameS :: Addr# -> TrName
TrNameD :: [Char] -> TrName
data TyCon
TyCon :: Word# -> Word# -> Module -> TrName -> Int# -> KindRep -> TyCon
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep

-- | A de Bruijn index for a binder within a <a>KindRep</a>.
type KindBndr = Int


-- | Extra C-- routines exposed from the RTS
--   
--   Actual primops are emitted by the compiler itself. They are special
--   bits of code with backend support. The foreign functions in this
--   module aren't actual primops because the compiler doesn't care about
--   them at all: they just are extra foreign C-- calls libraries can make
--   into the RTS.
--   
--   Note that <a>Prim</a> has the same haddock section names as this
--   module, but with descriptions. Consult that module's documentation for
--   what each section means. are described over there.
module GHC.Prim.Ext
type INT64 = Int#
type WORD64 = Word#

-- | Retrieves the allocation counter for the current thread.
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, INT64 #)


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim
data Char#
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
data Int#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(quotInt# x y) *# y +# (remInt# x y) == x</tt>. The
--   behavior is undefined if the second argument is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#

-- | Unary negation. Since the negative <tt>Int#</tt> range extends one
--   further than the positive range, <tt>negateInt#</tt> of the most
--   negative number is an identity operation. This way,
--   <tt>negateInt#</tt> is always its own inverse.
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <tt>Int#</tt>; second member is zero if the true
--   sum fits in an <tt>Int#</tt>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <tt>Int#</tt>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <tt>Int#</tt>; second member is zero if
--   the true difference fits in an <tt>Int#</tt>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <tt>Int#</tt>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Int8#
extendInt8# :: Int8# -> Int#
narrowInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
data Word8#
extendWord8# :: Word8# -> Word#
narrowWord8# :: Word# -> Word8#
notWord8# :: Word8# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
data Int16#
extendInt16# :: Int16# -> Int#
narrowInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
data Word16#
extendWord16# :: Word16# -> Word#
narrowWord16# :: Word# -> Word16#
notWord16# :: Word16# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
data Word#
plusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <tt>plusWord2#</tt>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <tt>addWordC#</tt>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord# :: Word# -> Word# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord# :: Word# -> Word# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext# :: Word# -> Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word# -> Word#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word# -> Word#

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Double#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#

-- | Truncates a <tt>Double#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <tt>Double#</tt> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
data Float#
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#

-- | Truncates a <tt>Float#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <tt>Int#</tt> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
data Array# a
data MutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofArray# :: Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: MutableArray# s a -> Int#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexArray# :: Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a lifted value makes this
--   function harder to use correctly than <tt>casIntArray#</tt>. All of
--   the difficulties of using <tt>reallyUnsafePtrEquality#</tt> correctly
--   apply to <tt>casArray#</tt> as well.
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data SmallArray# a
data SmallMutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <tt>sizeofSmallMutableArray#</tt>.
shrinkSmallMutableArray# :: SmallMutableArray# s a -> Int# -> State# s -> State# s

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofSmallArray# :: SmallArray# a -> Int#

-- | Return the number of elements in the array. Note that this is
--   deprecated as it is unsafe in the presence of resize operations on the
--   same byte array.

-- | <i>Deprecated: Use <a>getSizeofSmallMutableArray#</a> instead </i>
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#

-- | Return the number of elements in the array.
getSizeofSmallMutableArray# :: SmallMutableArray# s a -> State# s -> (# State# s, Int# #)

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <tt>casArray#</tt>.
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data ByteArray#
data MutableByteArray# s

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread.
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array that the GC guarantees not to move.
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array, aligned by the specified amount, that the
--   GC guarantees not to move.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Determine whether a <tt>MutableByteArray#</tt> is guaranteed not to
--   move during GC.
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#

-- | Determine whether a <tt>ByteArray#</tt> is guaranteed not to move
--   during GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <tt>sizeofMutableByteArray#</tt>.
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <tt>MutableByteArray#</tt> is either the original
--   <tt>MutableByteArray#</tt> resized in-place or, if not possible, a
--   newly allocated (unpinned) <tt>MutableByteArray#</tt> (with the
--   original content copied over).
--   
--   To avoid undefined behaviour, the original <tt>MutableByteArray#</tt>
--   shall not be accessed anymore after a <tt>resizeMutableByteArray#</tt>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <tt>MutableByteArray#</tt> in case a new <tt>MutableByteArray#</tt>
--   had to be allocated.
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes. Note that this is deprecated as
--   it is unsafe in the presence of resize operations on the same byte
--   array.

-- | <i>Deprecated: Use <a>getSizeofMutableByteArray#</a> instead </i>
sizeofMutableByteArray# :: MutableByteArray# s -> Int#

-- | Return the number of elements in the array.
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)

-- | Read 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read 8-bit integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8Array# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit integer; offset in 16-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16Array# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit integer; offset in 32-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32Array# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit integer; offset in 64-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64Array# :: ByteArray# -> Int# -> Int#

-- | Read 8-bit word; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8Array# :: ByteArray# -> Int# -> Word#

-- | Read 16-bit word; offset in 16-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16Array# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in 32-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32Array# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in 64-bit words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64Array# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read float; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read double; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read stable pointer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read 16-bit int; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit int; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit int; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#

-- | Read int; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit word; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#

-- | Read word; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Read word; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | Write 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <tt>compareByteArrays# src1 src1_ofs src2 src2_ofs n</tt> compares
--   <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the first
--   <tt>ByteArray#</tt> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <tt>ByteArray#</tt> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <tt>Int#</tt>
--   less than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | <tt>copyByteArray# src src_ofs dst dst_ofs n</tt> copies the range
--   starting at offset <tt>src_ofs</tt> of length <tt>n</tt> from the
--   <tt>ByteArray#</tt> <tt>src</tt> to the <tt>MutableByteArray#</tt>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableByteArray# to the specified region in
--   the second MutableByteArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <tt>setByteArray# ba off len c</tt> sets the byte range <tt>[off,
--   off+len]</tt> of the <tt>MutableByteArray#</tt> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically substract the value to the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
data ArrayArray#
data MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the ArrayArray# to the specified region in the
--   MutableArrayArray#. Both arrays must fully contain the specified
--   ranges, but this is not checked. The two arrays must not be the same
--   array in different states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr#

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <tt>Addr#</tt>s are so far apart that
--   their difference doesn't fit in an <tt>Int#</tt>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <tt>Addr#</tt> arg, treated like an
--   <tt>Int#</tt>, is divided by the <tt>Int#</tt> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int.

-- | <i>Deprecated: This operation is strongly deprecated. </i>
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address.

-- | <i>Deprecated: This operation is strongly deprecated. </i>
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8OffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16OffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32OffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64OffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8OffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16OffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32OffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64OffAddr# :: Addr# -> Int# -> Word#

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | A <tt>MutVar#</tt> behaves like a single-element mutable array.
data MutVar# s a

-- | Create <tt>MutVar#</tt> with specified initial value in specified
--   state thread.
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)

-- | Read contents of <tt>MutVar#</tt>. Result is not yet evaluated.
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>MutVar#</tt>.
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#

-- | Modify the contents of a <tt>MutVar#</tt>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents. Note that this isn't strictly speaking the correct type for
--   this function; it should really be <tt>MutVar# s a -&gt; (a -&gt;
--   (a,b)) -&gt; State# s -&gt; (# State# s, a, (a, b) #)</tt>, but we
--   don't know about pairs here.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s, a, c #)

-- | Modify the contents of a <tt>MutVar#</tt>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s, a, a #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: b -> o
raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
data TVar# s a
atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Create a new <tt>TVar#</tt> holding a specified initial value.
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)

-- | Read contents of <tt>TVar#</tt>. Result is not yet evaluated.
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Read contents of <tt>TVar#</tt> outside an STM transaction
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>TVar#</tt>.
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#

-- | A shared mutable variable (<i>not</i> the same as a
--   <tt>MutVar#</tt>!). (Note: in a non-concurrent implementation,
--   <tt>(MVar# a)</tt> can be represented by <tt>(MutVar# (Maybe
--   a))</tt>.)
data MVar# s a

-- | Create new <tt>MVar#</tt>; initially empty.
newMVar# :: State# s -> (# State# s, MVar# s a #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty.
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>, and set <tt>MVar#</tt> empty.
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)

-- | If <tt>MVar#</tt> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: MVar# s a -> a -> State# s -> State# s

-- | If <tt>MVar#</tt> is full, immediately return with integer 0.
--   Otherwise, store value arg as <tt>MVar#</tt>'s new contents, and
--   return with integer 1.
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>.
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#

-- | Return 1 if <tt>MVar#</tt> is empty; 0 otherwise.
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# s -> State# s

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# s -> State# s

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# s -> State# s

-- | <tt>State#</tt> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt>State# RealWorld</tt>, or <tt>State# s</tt>,
--   where s is a type variable. The only purpose of the type parameter is
--   to keep different state threads separate. It is represented by nothing
--   at all.
data State# s

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <tt>myThreadId#</tt>. The other
--   operations can be omitted.)
data ThreadId#
fork# :: a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
data Weak# b

-- | <tt>mkWeak# k v finalizer s</tt> creates a weak reference to value
--   <tt>k</tt>, with an associated reference to some value <tt>v</tt>. If
--   <tt>k</tt> is still alive then <tt>v</tt> can be retrieved using
--   <tt>deRefWeak#</tt>. Note that the type of <tt>k</tt> must be
--   represented by a pointer (i.e. of kind <tt>TYPE 'LiftedRep</tt> or
--   <tt>TYPE 'UnliftedRep</tt>).
mkWeak# :: o -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | <tt>addCFinalizerToWeak# fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>.
--   <tt>addCFinalizerToWeak#</tt> returns 1 on success, or 0 if <tt>w</tt>
--   is already dead.
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <tt>Int#</tt> and a (possibly invalid) finalization
--   action. An <tt>Int#</tt> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: o -> State# RealWorld -> State# RealWorld
data StablePtr# a
data StableName# a
makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
data Compact#

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <tt>nullAddr#</tt> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <tt>Addr#</tt> is a pointer to previous
--   compact block of the CNF or <tt>nullAddr#</tt> to create a new CNF
--   with a single compact block.
--   
--   The resulting block is not known to the GC until
--   <tt>compactFixupPointers#</tt> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Recursively add a closure and its transitive closure to a
--   <tt>Compact#</tt> (a CNF), evaluating any unevaluated components at
--   the same time. Note: <tt>compactAdd#</tt> is not thread-safe, so only
--   one thread may call <tt>compactAdd#</tt> with a particular
--   <tt>Compact#</tt> at any given time. The primop does not enforce any
--   mutual exclusion; the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like <tt>compactAdd#</tt>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
reallyUnsafePtrEquality# :: a -> a -> Int#

-- | <i>Deprecated: Use <a>spark#</a> instead </i>
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO#

-- | Convert an <tt>Addr#</tt> to a followable Any type.
addrToAny# :: Addr# -> (# a #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   <tt>unsafeCoerce#</tt>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <tt>Addr#</tt> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO# -> (# a #)

-- | <tt>newBCO# instrs lits ptrs arity bitmap</tt> creates a new bytecode
--   object. The resulting object encodes a function of the given arity
--   with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)

-- | <tt>unpackClosure# closure</tt> copies the closure and pointers in the
--   payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | <tt>closureSize# closure</tt> returns the size of the given closure in
--   machine words.
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <tt>getCurrentCCS#</tt> being floated out by the
--   simplifier, which would result in an uninformative stack ("CAF").
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)

-- | The type constructor <tt>Proxy#</tt> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <tt>Proxy#</tt> is
--   not only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# a

-- | Witness for an unboxed <tt>Proxy#</tt> value, which has no runtime
--   representation.
proxy# :: Proxy# a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | The function <tt>unsafeCoerce#</tt> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <tt>unsafeCoerce#</tt> are supposed to work
--   (i.e. not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size.
--   (Casting between floating-point and integral types does not work. See
--   the <tt>GHC.Float</tt> module for functions to do work.)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt>Ptr Int</tt> to <tt>Ptr
--   Float</tt>, or <tt>[Int]</tt> to <tt>[Float]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <tt>unsafeCoerce#</tt> are undefined. In particular, you
--   should not use <tt>unsafeCoerce#</tt> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt>Int-&gt;Int</tt> to <tt>Bool</tt>, even if you later cast
--   that <tt>Bool</tt> back to <tt>Int-&gt;Int</tt> before applying it.
--   The reasons have to do with GHC's internal representation details (for
--   the cognoscenti, data values can be entered but function closures
--   cannot). If you want a safe type to cast things to, use <tt>Any</tt>,
--   which is not an algebraic data type.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
unsafeCoerce# :: a -> b

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# s -> State# s

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the the
--   given length passed as the second argument. The event will be emitted
--   to the <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# s -> State# s

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
--   
--   This function is runtime-representation polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt>coerce @Int @Age 42</tt>.
coerce :: Coercible a b => a -> b

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X64#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X64#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X16# :: Int# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X8# :: Int# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X4# :: Int# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X2# :: Int# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X32# :: Int# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X16# :: Int# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X8# :: Int# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X4# :: Int# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X64# :: Int# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X32# :: Int# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X16# :: Int# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X8# :: Int# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X16# :: Word# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X8# :: Word# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X4# :: Word# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X2# :: Word# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X32# :: Word# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X16# :: Word# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X8# :: Word# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X4# :: Word# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X64# :: Word# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X32# :: Word# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X16# :: Word# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X8# :: Word# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X4# :: (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X2# :: (# Int#, Int# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X4# :: (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X64# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X4# :: (# Word#, Word#, Word#, Word# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X2# :: (# Word#, Word# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X4# :: (# Word#, Word#, Word#, Word# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X64# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X16# :: Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X8# :: Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X4# :: Int32X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X2# :: Int64X2# -> (# Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X32# :: Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X16# :: Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X8# :: Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X4# :: Int64X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X64# :: Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X32# :: Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X16# :: Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X8# :: Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X16# :: Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X8# :: Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X4# :: Word32X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X2# :: Word64X2# -> (# Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X32# :: Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X16# :: Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X8# :: Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X4# :: Word64X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X64# :: Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X32# :: Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X16# :: Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X8# :: Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <a>par</a> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <a>par</a>.
--   
--   Like <tt>seq</tt>, the argument of <a>lazy</a> can have an unboxed
--   type.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Apply a function to a <tt><a>State#</a> <a>RealWorld</a></tt> token.
--   When manually applying a function to <tt>realWorld#</tt>, it is
--   necessary to use <tt>NOINLINE</tt> to prevent semantically undesirable
--   floating. <a>runRW#</a> is inlined, but only very late in compilation
--   after all floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o


-- | Primitive operations on Int64# and Word64# on platforms where
--   WORD_SIZE_IN_BITS &lt; 64.
module GHC.IntWord64


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]


-- | The tuple data types
module GHC.Tuple

-- | The unit datatype <tt>()</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()
data Unit a
Unit :: a -> Unit a
data (,) a b
(,) :: a -> b -> (,) a b
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> j2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2

module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
extendInt8# :: Int8# -> Int#
narrowInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#
quotInt8# :: Int8# -> Int8# -> Int8#
remInt8# :: Int8# -> Int8# -> Int8#
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
extendWord8# :: Word8# -> Word#
narrowWord8# :: Word# -> Word8#
notWord8# :: Word8# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#
quotWord8# :: Word8# -> Word8# -> Word8#
remWord8# :: Word8# -> Word8# -> Word8#
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
extendInt16# :: Int16# -> Int#
narrowInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#
quotInt16# :: Int16# -> Int16# -> Int16#
remInt16# :: Int16# -> Int16# -> Int16#
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
extendWord16# :: Word16# -> Word#
narrowWord16# :: Word# -> Word16#
notWord16# :: Word16# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#
quotWord16# :: Word16# -> Word16# -> Word16#
remWord16# :: Word16# -> Word16# -> Word16#
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
plusWord# :: Word# -> Word# -> Word#
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word# -> Word#
popCnt# :: Word# -> Word#
pdep8# :: Word# -> Word# -> Word#
pdep16# :: Word# -> Word# -> Word#
pdep32# :: Word# -> Word# -> Word#
pdep64# :: Word# -> Word# -> Word#
pdep# :: Word# -> Word# -> Word#
pext8# :: Word# -> Word# -> Word#
pext16# :: Word# -> Word# -> Word#
pext32# :: Word# -> Word# -> Word#
pext64# :: Word# -> Word# -> Word#
pext# :: Word# -> Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word# -> Word#
byteSwap# :: Word# -> Word#
bitReverse8# :: Word# -> Word#
bitReverse16# :: Word# -> Word#
bitReverse32# :: Word# -> Word#
bitReverse64# :: Word# -> Word#
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#
logDouble# :: Double# -> Double#
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#
logFloat# :: Float# -> Float#
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofArray# :: Array# a -> Int#
sizeofMutableArray# :: MutableArray# s a -> Int#
indexArray# :: Array# a -> Int# -> (# a #)
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# a -> Int# -> Int# -> Array# a
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
shrinkSmallMutableArray# :: SmallMutableArray# s a -> Int# -> State# s -> State# s
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofSmallArray# :: SmallArray# a -> Int#
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#
getSizeofSmallMutableArray# :: SmallMutableArray# s a -> State# s -> (# State# s, Int# #)
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
isByteArrayPinned# :: ByteArray# -> Int#
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
sizeofArrayArray# :: ArrayArray# -> Int#
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s, a, c #)
atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s, a, a #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: b -> o
raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#
newMVar# :: State# s -> (# State# s, MVar# s a #)
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
putMVar# :: MVar# s a -> a -> State# s -> State# s
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
mkWeak# :: o -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: o -> State# RealWorld -> State# RealWorld
makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
reallyUnsafePtrEquality# :: a -> a -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
addrToAny# :: Addr# -> (# a #)
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)
traceEvent# :: Addr# -> State# s -> State# s
traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s
traceMarker# :: Addr# -> State# s -> State# s
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s

module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()


-- | Basic classes.
module GHC.Classes

-- | The syntax <tt>?x :: a</tt> is desugared into <tt>IP "x" a</tt> IP is
--   declared very early, so that libraries can take advantage of the
--   implicit-call-stack feature
class IP (x :: Symbol) a | x -> a
ip :: IP x a => a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class (Eq a) => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >
eqInt :: Int -> Int -> Bool
neInt :: Int -> Int -> Bool
eqWord :: Word -> Word -> Bool
neWord :: Word -> Word -> Bool
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool
eqFloat :: Float -> Float -> Bool
eqDouble :: Double -> Double -> Bool
gtInt :: Int -> Int -> Bool
geInt :: Int -> Int -> Bool
leInt :: Int -> Int -> Bool
ltInt :: Int -> Int -> Bool
compareInt :: Int -> Int -> Ordering
compareInt# :: Int# -> Int# -> Ordering
gtWord :: Word -> Word -> Bool
geWord :: Word -> Word -> Bool
leWord :: Word -> Word -> Bool
ltWord :: Word -> Word -> Bool
compareWord :: Word -> Word -> Ordering
compareWord# :: Word# -> Word# -> Ordering

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool
divInt# :: Int# -> Int# -> Int#
modInt# :: Int# -> Int# -> Int#
instance GHC.Classes.Eq ()
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (a, b, c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (a, b, c, d)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e) => GHC.Classes.Eq (a, b, c, d, e)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (a, b, c, d, e, f)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g) => GHC.Classes.Eq (a, b, c, d, e, f, g)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h) => GHC.Classes.Eq (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Classes.Eq GHC.Types.Module
instance GHC.Classes.Eq GHC.Types.Bool
instance GHC.Classes.Eq GHC.Types.Ordering
instance GHC.Classes.Ord ()
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (a, b, c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (a, b, c, d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e) => GHC.Classes.Ord (a, b, c, d, e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f) => GHC.Classes.Ord (a, b, c, d, e, f)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g) => GHC.Classes.Ord (a, b, c, d, e, f, g)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h) => GHC.Classes.Ord (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n, GHC.Classes.Ord o) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Classes.Ord GHC.Types.Bool
instance GHC.Classes.Ord GHC.Types.Ordering
instance GHC.Classes.Ord GHC.Types.TyCon
instance GHC.Classes.Ord a => GHC.Classes.Ord [a]
instance GHC.Classes.Ord GHC.Types.Char
instance GHC.Classes.Ord GHC.Types.Float
instance GHC.Classes.Ord GHC.Types.Double
instance GHC.Classes.Ord GHC.Types.Int
instance GHC.Classes.Ord GHC.Types.Word
instance GHC.Classes.Eq a => GHC.Classes.Eq [a]
instance GHC.Classes.Eq GHC.Types.TrName
instance GHC.Classes.Eq GHC.Types.Word
instance GHC.Classes.Eq GHC.Types.Char
instance GHC.Classes.Eq GHC.Types.Float
instance GHC.Classes.Eq GHC.Types.Double
instance GHC.Classes.Eq GHC.Types.Int
instance GHC.Classes.Eq GHC.Types.TyCon
