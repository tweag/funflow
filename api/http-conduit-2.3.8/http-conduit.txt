-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP client package with conduit interface and HTTPS support.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/http-conduit</a>.
@package http-conduit
@version 2.3.8


-- | A new, experimental API to replace <a>Network.HTTP.Conduit</a>.
--   
--   For most users, <a>Network.HTTP.Simple</a> is probably a better
--   choice. For more information, see:
--   
--   <a>https://haskell-lang.org/library/http-client</a>
--   
--   For more information on using this module, please be sure to read the
--   documentation in the <a>Network.HTTP.Client</a> module.
module Network.HTTP.Client.Conduit

-- | Conduit powered version of <a>withResponse</a>. Differences are:
--   
--   <ul>
--   <li>Response body is represented as a <tt>Producer</tt>.</li>
--   <li>Generalized to any instance of <tt>MonadUnliftIO</tt>, not just
--   <tt>IO</tt>.</li>
--   <li>The <tt>Manager</tt> is contained by a <tt>MonadReader</tt>
--   context.</li>
--   </ul>
--   
--   Since 2.1.0
withResponse :: (MonadUnliftIO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> (Response (ConduitM i ByteString n ()) -> m a) -> m a

-- | Conduit-powered version of <a>responseOpen</a>.
--   
--   See <a>withResponse</a> for the differences with <a>responseOpen</a>.
--   
--   Since 2.1.0
responseOpen :: (MonadIO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Response (ConduitM i ByteString n ()))

-- | Generalized version of <a>responseClose</a>.
--   
--   Since 2.1.0
responseClose :: MonadIO m => Response body -> m ()

-- | An <tt>Acquire</tt> for getting a <tt>Response</tt>.
--   
--   Since 2.1.0
acquireResponse :: (MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Acquire (Response (ConduitM i ByteString n ())))

-- | Same as <a>httpSource</a>, but uses <a>Manager</a> from Reader
--   environment instead of the global one.
--   
--   Since 2.3.6
httpSource :: (MonadResource m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> (Response (ConduitM () ByteString n ()) -> ConduitM () r m ()) -> ConduitM () r m ()

-- | TLS-powered manager settings.
--   
--   Since 2.1.0
defaultManagerSettings :: ManagerSettings

-- | Get a new manager using <a>defaultManagerSettings</a>.
--   
--   Since 2.1.0
newManager :: MonadIO m => m Manager

-- | Get a new manager using the given settings.
--   
--   Since 2.1.0
newManagerSettings :: MonadIO m => ManagerSettings -> m Manager

-- | Use the default response timeout
--   
--   When used on a <a>Request</a>, means: use the manager's timeout value
--   
--   When used on a <a>ManagerSettings</a>, means: default to 30 seconds
responseTimeoutDefault :: ResponseTimeout

-- | Do not have a response timeout
responseTimeoutNone :: ResponseTimeout

-- | Specify maximum time in microseconds the retrieval of response headers
--   is allowed to take
responseTimeoutMicro :: Int -> ResponseTimeout

-- | Set the proxy override value, for both HTTP (insecure) and HTTPS
--   (insecure) connections.
--   
--   Since 0.4.7
managerSetProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings

-- | Set the proxy override value, only for HTTPS (secure) connections.
--   
--   Since 0.4.7
managerSetSecureProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings

-- | Set the proxy override value, only for HTTP (insecure) connections.
--   
--   Since 0.4.7
managerSetInsecureProxy :: ProxyOverride -> ManagerSettings -> ManagerSettings

-- | A variant of <tt>withResponse</tt> which keeps a history of all
--   redirects performed in the interim, together with the first 1024 bytes
--   of their response bodies.
--   
--   Since 0.4.1
withResponseHistory :: Request -> Manager -> (HistoriedResponse BodyReader -> IO a) -> IO a

-- | A variant of <tt>responseOpen</tt> which keeps a history of all
--   redirects performed in the interim, together with the first 1024 bytes
--   of their response bodies.
--   
--   Since 0.4.1
responseOpenHistory :: Request -> Manager -> IO (HistoriedResponse BodyReader)

-- | A datatype holding information on redirected requests and the final
--   response.
--   
--   Since 0.4.1
data HistoriedResponse body

-- | Perform an action using a <tt>Connection</tt> acquired from the given
--   <tt>Manager</tt>.
--   
--   You should use this only when you have to read and write interactively
--   through the connection (e.g. connection by the WebSocket protocol).
withConnection :: Request -> Manager -> (Connection -> IO a) -> IO a

-- | Turn a SetCookie into a Cookie, if it is valid
generateCookie :: SetCookie -> Request -> UTCTime -> Bool -> Maybe Cookie

-- | Insert a cookie created by generateCookie into the cookie jar (or not
--   if it shouldn't be allowed in)
insertCheckedCookie :: Cookie -> CookieJar -> Bool -> CookieJar

-- | This corresponds to the algorithm described in Section 5.3 "Storage
--   Model" This function consists of calling <a>generateCookie</a>
--   followed by <a>insertCheckedCookie</a>. Use this function if you plan
--   to do both in a row. <a>generateCookie</a> and
--   <a>insertCheckedCookie</a> are only provided for more fine-grained
--   control.
receiveSetCookie :: SetCookie -> Request -> UTCTime -> Bool -> CookieJar -> CookieJar

-- | This applies <a>receiveSetCookie</a> to a given Response
updateCookieJar :: Response a -> Request -> UTCTime -> CookieJar -> (CookieJar, Response a)

-- | This corresponds to the algorithm described in Section 5.4 "The Cookie
--   Header"
computeCookieString :: Request -> CookieJar -> UTCTime -> Bool -> (ByteString, CookieJar)

-- | This applies the <a>computeCookieString</a> to a given Request
insertCookiesIntoRequest :: Request -> CookieJar -> UTCTime -> (Request, CookieJar)

-- | This corresponds to the eviction algorithm described in Section 5.3
--   "Storage Model"
evictExpiredCookies :: CookieJar -> UTCTime -> CookieJar
removeExistingCookieFromCookieJar :: Cookie -> CookieJar -> (Maybe Cookie, CookieJar)
destroyCookieJar :: CookieJar -> [Cookie]
createCookieJar :: [Cookie] -> CookieJar

-- | This corresponds to the subcomponent algorithm entitled "Path-Match"
--   detailed in section 5.1.4
pathMatches :: ByteString -> ByteString -> Bool

-- | This corresponds to the subcomponent algorithm entitled "Paths"
--   detailed in section 5.1.4
defaultPath :: Request -> ByteString

-- | This corresponds to the subcomponent algorithm entitled "Domain
--   Matching" detailed in section 5.1.3
domainMatches :: ByteString -> ByteString -> Bool
isIpAddress :: ByteString -> Bool

-- | The default proxy settings for a manager. In particular: if the
--   <tt>http_proxy</tt> (or <tt>https_proxy</tt>) environment variable is
--   set, use it. Otherwise, use the values in the <tt>Request</tt>.
--   
--   Since 0.4.7
defaultProxy :: ProxyOverride

-- | Same as <a>proxyEnvironment</a>, but instead of default environment
--   variable names, allows you to set your own name.
--   
--   Since 0.4.7
proxyEnvironmentNamed :: Text -> Maybe Proxy -> ProxyOverride

-- | Get the proxy settings from the default environment variable
--   (<tt>http_proxy</tt> for insecure, <tt>https_proxy</tt> for secure).
--   If no variable is set, then fall back to the given value.
--   <tt>Nothing</tt> is equivalent to <a>noProxy</a>, <tt>Just</tt> is
--   equivalent to <a>useProxy</a>.
--   
--   Since 0.4.7
proxyEnvironment :: Maybe Proxy -> ProxyOverride

-- | Use the given proxy settings, regardless of the proxy value in the
--   <tt>Request</tt>.
--   
--   Since 0.4.7
useProxy :: Proxy -> ProxyOverride

-- | Never connect using a proxy, regardless of the proxy value in the
--   <tt>Request</tt>.
--   
--   Since 0.4.7
noProxy :: ProxyOverride

-- | Get the proxy settings from the <tt>Request</tt> itself.
--   
--   Since 0.4.7
proxyFromRequest :: ProxyOverride

-- | Create, use and close a <a>Manager</a>.
--   
--   Since 0.2.1
withManager :: ManagerSettings -> (Manager -> IO a) -> IO a

-- | Same as <tt>rawConnectionModifySocket</tt>, but also takes in a chunk
--   size.
rawConnectionModifySocketSize :: (Socket -> IO ()) -> IO (Int -> Maybe HostAddress -> String -> Int -> IO Connection)

-- | A value for the <tt>managerRawConnection</tt> setting, but also allows
--   you to modify the underlying <tt>Socket</tt> to set additional
--   settings. For a motivating use case, see:
--   <a>https://github.com/snoyberg/http-client/issues/71</a>.
--   
--   Since 0.3.8
rawConnectionModifySocket :: (Socket -> IO ()) -> IO (Maybe HostAddress -> String -> Int -> IO Connection)

-- | Send a file as the request body, while observing streaming progress
--   via a <tt>PopObserver</tt>. Observations are made between reading and
--   sending a chunk.
--   
--   It is expected that the file size does not change between calling
--   <a>observedStreamFile</a> and making any requests using this request
--   body.
--   
--   Since 0.4.9
observedStreamFile :: (StreamFileStatus -> IO ()) -> FilePath -> IO RequestBody

-- | Send a file as the request body.
--   
--   It is expected that the file size does not change between calling
--   <a>streamFile</a> and making any requests using this request body.
--   
--   Since 0.4.9
streamFile :: FilePath -> IO RequestBody

-- | Set the query string to the given key/value pairs.
setQueryStringPartialEscape :: [(ByteString, [EscapeItem])] -> Request -> Request

-- | Set the query string to the given key/value pairs.
--   
--   Since 0.3.6
setQueryString :: [(ByteString, Maybe ByteString)] -> Request -> Request

-- | Modify the request so that non-2XX status codes generate a runtime
--   <a>StatusCodeException</a>, by using <a>throwErrorStatusCodes</a>
setRequestCheckStatus :: Request -> Request

-- | Modify the request so that non-2XX status codes do not generate a
--   runtime <a>StatusCodeException</a>.
setRequestIgnoreStatus :: Request -> Request

-- | Add url-encoded parameters to the <a>Request</a>.
--   
--   This sets a new <a>requestBody</a>, adds a content-type request header
--   and changes the <a>method</a> to POST.
--   
--   Since 0.1.0
urlEncodedBody :: [(ByteString, ByteString)] -> Request -> Request

-- | Add a Proxy-Authorization header (with the specified username and
--   password) to the given <a>Request</a>. Ignore error handling:
--   
--   <pre>
--   applyBasicProxyAuth "user" "pass" &lt;$&gt; parseRequest "http://example.org"
--   </pre>
--   
--   Since 0.3.4
applyBasicProxyAuth :: ByteString -> ByteString -> Request -> Request

-- | Add a Basic Auth header (with the specified user name and password) to
--   the given Request. Ignore error handling:
--   
--   <pre>
--   applyBasicAuth "user" "pass" $ parseRequest_ url
--   </pre>
--   
--   NOTE: The function <tt>applyDigestAuth</tt> is provided by the
--   <tt>http-client-tls</tt> package instead of this package due to extra
--   dependencies. Please use that package if you need to use digest
--   authentication.
--   
--   Since 0.1.0
applyBasicAuth :: ByteString -> ByteString -> Request -> Request

-- | A default request value, a GET request of localhost/:80, with an empty
--   request body.
--   
--   Note that the default <a>checkResponse</a> does nothing.
defaultRequest :: Request

-- | Extract a <a>URI</a> from the request.
--   
--   Since 0.1.0
getUri :: Request -> URI

-- | Same as <a>requestFromURI</a>, but if the conversion would fail,
--   throws an impure exception.
requestFromURI_ :: URI -> Request

-- | Convert a <a>URI</a> into a <a>Request</a>.
--   
--   This can fail if the given <a>URI</a> is not absolute, or if the
--   <a>URI</a> scheme is not <tt>"http"</tt> or <tt>"https"</tt>. In these
--   cases the function will throw an error via <a>MonadThrow</a>.
--   
--   This function defaults some of the values in <a>Request</a>, such as
--   setting <a>method</a> to <tt><a>GET</a></tt> and <a>requestHeaders</a>
--   to <tt>[]</tt>.
--   
--   A <a>Request</a> created by this function won't cause exceptions on
--   non-2XX response status codes.
requestFromURI :: MonadThrow m => URI -> m Request

-- | Same as <a>parseRequest</a>, but parse errors cause an impure
--   exception. Mostly useful for static strings which are known to be
--   correctly formatted.
parseRequest_ :: String -> Request

-- | Convert a URL into a <a>Request</a>.
--   
--   This function defaults some of the values in <a>Request</a>, such as
--   setting <a>method</a> to <tt><a>GET</a></tt> and <a>requestHeaders</a>
--   to <tt>[]</tt>.
--   
--   Since this function uses <a>MonadThrow</a>, the return monad can be
--   anything that is an instance of <a>MonadThrow</a>, such as <a>IO</a>
--   or <a>Maybe</a>.
--   
--   You can place the request method at the beginning of the URL separated
--   by a space, e.g.:
--   
--   @@<tt> parseRequest "POST <a>http://httpbin.org/post"</a> </tt>@@
--   
--   Note that the request method must be provided as all capital letters.
--   
--   A <a>Request</a> created by this function won't cause exceptions on
--   non-2XX response status codes.
--   
--   To create a request which throws on non-2XX status codes, see
--   <a>parseUrlThrow</a>
parseRequest :: MonadThrow m => String -> m Request

-- | Throws a <a>StatusCodeException</a> wrapped in
--   <a>HttpExceptionRequest</a>, if the response's status code indicates
--   an error (if it isn't 2xx). This can be used to implement
--   <a>checkResponse</a>.
throwErrorStatusCodes :: MonadIO m => Request -> Response BodyReader -> m ()

-- | Same as <a>parseRequest</a>, except will throw an <a>HttpException</a>
--   in the event of a non-2XX response. This uses
--   <a>throwErrorStatusCodes</a> to implement <a>checkResponse</a>.
parseUrlThrow :: MonadThrow m => String -> m Request

-- | Deprecated synonym for <a>parseUrlThrow</a>. You probably want
--   <a>parseRequest</a> or <a>parseRequest_</a> instead.
parseUrl :: MonadThrow m => String -> m Request

-- | Continuously call <a>brRead</a>, building up a lazy ByteString until a
--   chunk is constructed that is at least as many bytes as requested.
--   
--   Since 0.4.20
brReadSome :: BodyReader -> Int -> IO ByteString

-- | Create a new <a>Connection</a> from a <a>Socket</a>.
socketConnection :: Socket -> Int -> IO Connection

-- | Create a new <a>Connection</a> from a read, write, and close function.
makeConnection :: IO ByteString -> (ByteString -> IO ()) -> IO () -> IO Connection

-- | An exception which may be generated by this library
data HttpException

-- | Most exceptions are specific to a <a>Request</a>. Inspect the
--   <a>HttpExceptionContent</a> value for details on what occurred.
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException

-- | A URL (first field) is invalid for a given reason (second argument).
InvalidUrlException :: String -> String -> HttpException
data HttpExceptionContent

-- | Generated by the <tt>parseUrlThrow</tt> function when the server
--   returns a non-2XX response status code.
--   
--   May include the beginning of the response body.
StatusCodeException :: Response () -> ByteString -> HttpExceptionContent

-- | The server responded with too many redirects for a request.
--   
--   Contains the list of encountered responses containing redirects in
--   reverse chronological order; including last redirect, which triggered
--   the exception and was not followed.
TooManyRedirects :: [Response ByteString] -> HttpExceptionContent

-- | Either too many headers, or too many total bytes in a single header,
--   were returned by the server, and the memory exhaustion protection in
--   this library has kicked in.
OverlongHeaders :: HttpExceptionContent

-- | The server took too long to return a response. This can be altered via
--   <a>responseTimeout</a> or <a>managerResponseTimeout</a>.
ResponseTimeout :: HttpExceptionContent

-- | Attempting to connect to the server timed out.
ConnectionTimeout :: HttpExceptionContent

-- | An exception occurred when trying to connect to the server.
ConnectionFailure :: SomeException -> HttpExceptionContent

-- | The status line returned by the server could not be parsed.
InvalidStatusLine :: ByteString -> HttpExceptionContent

-- | The given response header line could not be parsed
InvalidHeader :: ByteString -> HttpExceptionContent

-- | The given request header is not compliant (e.g. has newlines)
InvalidRequestHeader :: ByteString -> HttpExceptionContent

-- | An exception was raised by an underlying library when performing the
--   request. Most often, this is caused by a failing socket action or a
--   TLS exception.
InternalException :: SomeException -> HttpExceptionContent

-- | A non-200 status code was returned when trying to connect to the proxy
--   server on the given host and port.
ProxyConnectException :: ByteString -> Int -> Status -> HttpExceptionContent

-- | No response data was received from the server at all. This exception
--   may deserve special handling within the library, since it may indicate
--   that a pipelining has been used, and a connection thought to be open
--   was in fact closed.
NoResponseDataReceived :: HttpExceptionContent

-- | Exception thrown when using a <tt>Manager</tt> which does not have
--   support for secure connections. Typically, you will want to use
--   <tt>tlsManagerSettings</tt> from <tt>http-client-tls</tt> to overcome
--   this.
TlsNotSupported :: HttpExceptionContent

-- | The request body provided did not match the expected size.
--   
--   Provides the expected and actual size.
WrongRequestBodyStreamSize :: Word64 -> Word64 -> HttpExceptionContent

-- | The returned response body is too short. Provides the expected size
--   and actual size.
ResponseBodyTooShort :: Word64 -> Word64 -> HttpExceptionContent

-- | A chunked response body had invalid headers.
InvalidChunkHeaders :: HttpExceptionContent

-- | An incomplete set of response headers were returned.
IncompleteHeaders :: HttpExceptionContent

-- | The host we tried to connect to is invalid (e.g., an empty string).
InvalidDestinationHost :: ByteString -> HttpExceptionContent

-- | An exception was thrown when inflating a response body.
HttpZlibException :: ZlibException -> HttpExceptionContent

-- | Values in the proxy environment variable were invalid. Provides the
--   environment variable name and its value.
InvalidProxyEnvironmentVariable :: Text -> Text -> HttpExceptionContent

-- | Attempted to use a <a>Connection</a> which was already closed
ConnectionClosed :: HttpExceptionContent

-- | Proxy settings are not valid (Windows specific currently) @since 0.5.7
InvalidProxySettings :: Text -> HttpExceptionContent
data Cookie
Cookie :: ByteString -> ByteString -> UTCTime -> ByteString -> ByteString -> UTCTime -> UTCTime -> Bool -> Bool -> Bool -> Bool -> Cookie
[cookie_name] :: Cookie -> ByteString
[cookie_value] :: Cookie -> ByteString
[cookie_expiry_time] :: Cookie -> UTCTime
[cookie_domain] :: Cookie -> ByteString
[cookie_path] :: Cookie -> ByteString
[cookie_creation_time] :: Cookie -> UTCTime
[cookie_last_access_time] :: Cookie -> UTCTime
[cookie_persistent] :: Cookie -> Bool
[cookie_host_only] :: Cookie -> Bool
[cookie_secure_only] :: Cookie -> Bool
[cookie_http_only] :: Cookie -> Bool
data CookieJar

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy
Proxy :: ByteString -> Int -> Proxy

-- | The host name of the HTTP proxy.
[proxyHost] :: Proxy -> ByteString

-- | The port number of the HTTP proxy.
[proxyPort] :: Proxy -> Int

-- | When using one of the <a>RequestBodyStream</a> /
--   <a>RequestBodyStreamChunked</a> constructors, you must ensure that the
--   <a>GivesPopper</a> can be called multiple times. Usually this is not a
--   problem.
--   
--   The <a>RequestBodyStreamChunked</a> will send a chunked request body.
--   Note that not all servers support this. Only use
--   <a>RequestBodyStreamChunked</a> if you know the server you're sending
--   to supports chunked request bodies.
--   
--   Since 0.1.0
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> GivesPopper () -> RequestBody
RequestBodyStreamChunked :: GivesPopper () -> RequestBody

-- | Allows creation of a <tt>RequestBody</tt> inside the <tt>IO</tt>
--   monad, which is useful for making easier APIs (like
--   <tt>setRequestBodyFile</tt>).
RequestBodyIO :: IO RequestBody -> RequestBody

-- | A function which generates successive chunks of a request body,
--   provider a single empty bytestring when no more data is available.
--   
--   Since 0.1.0
type Popper = IO ByteString

-- | A function which must be provided with a <a>Popper</a>.
--   
--   Since 0.1.0
type NeedsPopper a = Popper -> IO a

-- | A function which will provide a <a>Popper</a> to a <a>NeedsPopper</a>.
--   This seemingly convoluted structure allows for creation of request
--   bodies which allocate scarce resources in an exception safe manner.
--   
--   Since 0.1.0
type GivesPopper a = NeedsPopper a -> IO a

-- | All information on how to connect to a host and what should be sent in
--   the HTTP request.
--   
--   If you simply wish to download from a URL, see <tt>parseRequest</tt>.
--   
--   The constructor for this data type is not exposed. Instead, you should
--   use either the <tt>defaultRequest</tt> value, or <tt>parseRequest</tt>
--   to construct from a URL, and then use the records below to make
--   modifications. This approach allows http-client to add configuration
--   options without breaking backwards compatibility.
--   
--   For example, to construct a POST request, you could do something like:
--   
--   <pre>
--   initReq &lt;- parseRequest "http://www.example.com/path"
--   let req = initReq
--               { method = "POST"
--               }
--   </pre>
--   
--   For more information, please see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data Request

-- | How to deal with timing out on retrieval of response headers.
data ResponseTimeout

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body

-- | Settings for a <tt>Manager</tt>. Please use the
--   <tt>defaultManagerSettings</tt> function and then modify individual
--   settings. For more information, see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data ManagerSettings

-- | How the HTTP proxy server settings should be discovered.
--   
--   Since 0.4.7
data ProxyOverride

-- | Keeps track of open connections for keep-alive.
--   
--   If possible, you should share a single <a>Manager</a> between multiple
--   threads and requests.
--   
--   Since 0.1.0
data Manager
class HasHttpManager a
getHttpManager :: HasHttpManager a => a -> Manager

-- | Status of streaming a request body from a file.
--   
--   Since 0.4.9
data StreamFileStatus
StreamFileStatus :: Int64 -> Int64 -> Int -> StreamFileStatus
[fileSize] :: StreamFileStatus -> Int64
[readSoFar] :: StreamFileStatus -> Int64
[thisChunkSize] :: StreamFileStatus -> Int

-- | Same as <a>httpLbs</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   Since 2.1.1
httpLbs :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ByteString)

-- | Same as <a>httpNoBody</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   This can be more convenient that using <a>withManager</a> as it avoids
--   the need to specify the base monad for the response body.
--   
--   Since 2.1.2
httpNoBody :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ())
requestBodySource :: Int64 -> ConduitM () ByteString IO () -> RequestBody
requestBodySourceChunked :: ConduitM () ByteString IO () -> RequestBody
bodyReaderSource :: MonadIO m => BodyReader -> ConduitM i ByteString m ()


-- | <h1>Simpler API</h1>
--   
--   The API below is rather low-level. The <a>Network.HTTP.Simple</a>
--   module provides a higher-level API with built-in support for things
--   like JSON request and response bodies. For most users, this will be an
--   easier place to start. You can read the tutorial at:
--   
--   <a>https://haskell-lang.org/library/http-client</a>
--   
--   <h1>Lower-level API</h1>
--   
--   This module contains everything you need to initiate HTTP connections.
--   If you want a simple interface based on URLs, you can use
--   <a>simpleHttp</a>. If you want raw power, <a>http</a> is the
--   underlying workhorse of this package. Some examples:
--   
--   <pre>
--   -- Just download an HTML document and print it.
--   import Network.HTTP.Conduit
--   import qualified Data.ByteString.Lazy as L
--   
--   main = simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
--   
--   This example uses interleaved IO to write the response body to a file
--   in constant memory space.
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile) -- Exported from the package conduit-extra
--   import Network.HTTP.Conduit
--   import Conduit (runConduit, (.|))
--   import Control.Monad.Trans.Resource (runResourceT)
--   
--   main :: IO ()
--   main = do
--        request &lt;- parseRequest "http://google.com/"
--        manager &lt;- newManager tlsManagerSettings
--        runResourceT $ do
--            response &lt;- http request manager
--            runConduit $ responseBody response .| sinkFile "google.html"
--   </pre>
--   
--   The following headers are automatically set by this module, and should
--   not be added to <a>requestHeaders</a>:
--   
--   <ul>
--   <li>Cookie</li>
--   <li>Content-Length</li>
--   <li>Transfer-Encoding</li>
--   </ul>
--   
--   Note: In previous versions, the Host header would be set by this
--   module in all cases. Starting from 1.6.1, if a Host header is present
--   in <tt>requestHeaders</tt>, it will be used in place of the header
--   this module would have generated. This can be useful for calling a
--   server which utilizes virtual hosting.
--   
--   Use <a>cookieJar</a> If you want to supply cookies with your request:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.HTTP.Conduit
--   import Network
--   import Data.Time.Clock
--   import Data.Time.Calendar
--   import qualified Control.Exception as E
--   import Network.HTTP.Types.Status (statusCode)
--   
--   past :: UTCTime
--   past = UTCTime (ModifiedJulianDay 56200) (secondsToDiffTime 0)
--   
--   future :: UTCTime
--   future = UTCTime (ModifiedJulianDay 562000) (secondsToDiffTime 0)
--   
--   cookie :: Cookie
--   cookie = Cookie { cookie_name = "password_hash"
--                   , cookie_value = "abf472c35f8297fbcabf2911230001234fd2"
--                   , cookie_expiry_time = future
--                   , cookie_domain = "example.com"
--                   , cookie_path = "/"
--                   , cookie_creation_time = past
--                   , cookie_last_access_time = past
--                   , cookie_persistent = False
--                   , cookie_host_only = False
--                   , cookie_secure_only = False
--                   , cookie_http_only = False
--                   }
--   
--   main = do
--        request' &lt;- parseRequest "http://example.com/secret-page"
--        manager &lt;- newManager tlsManagerSettings
--        let request = request' { cookieJar = Just $ createCookieJar [cookie] }
--        fmap Just (httpLbs request manager) `E.catch`
--                (\ex -&gt; case ex of
--                    HttpExceptionRequest _ (StatusCodeException res _) -&gt;
--                        if statusCode (responseStatus res) == 403
--                          then (putStrLn "login failed" &gt;&gt; return Nothing)
--                          else return Nothing
--                    _ -&gt; E.throw ex)
--   </pre>
--   
--   Cookies are implemented according to RFC 6265.
--   
--   Note that by default, the functions in this package will throw
--   exceptions for non-2xx status codes. If you would like to avoid this,
--   you should use <tt>checkStatus</tt>, e.g.:
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile)
--   import Network.HTTP.Conduit
--   import qualified Data.Conduit as C
--   import Network
--   
--   main :: IO ()
--   main = do
--        request' &lt;- parseRequest "http://www.yesodweb.com/does-not-exist"
--        let request = request' { checkStatus = \_ _ _ -&gt; Nothing }
--        manager &lt;- newManager tlsManagerSettings
--        res &lt;- httpLbs request manager
--        print res
--   </pre>
--   
--   By default, when connecting to websites using HTTPS, functions in this
--   package will throw an exception if the TLS certificate doesn't
--   validate. To continue the HTTPS transaction even if the TLS cerficate
--   validation fails, you should use <tt>mkManagerSetttings</tt> as
--   follows:
--   
--   <pre>
--   import Network.Connection (TLSSettings (..))
--   import Network.HTTP.Conduit
--   
--   main :: IO ()
--   main = do
--       request &lt;- parseRequest "https://github.com/"
--       let settings = mkManagerSettings (TLSSettingsSimple True False False) Nothing
--       manager &lt;- newManager settings
--       res &lt;- httpLbs request manager
--       print res
--   </pre>
--   
--   For more information, please be sure to read the documentation in the
--   <a>Network.HTTP.Client</a> module.
module Network.HTTP.Conduit

-- | Download the specified URL, following any redirects, and return the
--   response body.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). It uses <a>parseUrlThrow</a> to parse the
--   input. This function essentially wraps <a>httpLbs</a>.
--   
--   Note: Even though this function returns a lazy bytestring, it does
--   <i>not</i> utilize lazy I/O, and therefore the entire response body
--   will live in memory. If you want constant memory usage, you'll need to
--   use the <tt>conduit</tt> package and <a>http</a> directly.
--   
--   Note: This function creates a new <a>Manager</a>. It should be avoided
--   in production code.
simpleHttp :: MonadIO m => String -> m ByteString

-- | Download the specified <a>Request</a>, returning the results as a
--   <a>Response</a>.
--   
--   This is a simplified version of <a>http</a> for the common case where
--   you simply want the response data as a simple datatype. If you want
--   more power, such as interleaved actions on the response body during
--   download, you'll need to use <a>http</a> directly. This function is
--   defined as:
--   
--   <pre>
--   httpLbs = <a>lbsResponse</a> &lt;=&lt; <a>http</a>
--   </pre>
--   
--   Even though the <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to use <tt>conduit</tt> packages's <a>Source</a> returned
--   by <a>http</a>.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). This behavior can be modified by changing the
--   <tt>checkStatus</tt> field of your request.
--   
--   Note: Unlike previous versions, this function will perform redirects,
--   as specified by the <a>redirectCount</a> setting.
httpLbs :: MonadIO m => Request -> Manager -> m (Response ByteString)
http :: MonadResource m => Request -> Manager -> m (Response (ConduitM i ByteString m ()))

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy
Proxy :: ByteString -> Int -> Proxy

-- | The host name of the HTTP proxy.
[proxyHost] :: Proxy -> ByteString

-- | The port number of the HTTP proxy.
[proxyPort] :: Proxy -> Int

-- | When using one of the <a>RequestBodyStream</a> /
--   <a>RequestBodyStreamChunked</a> constructors, you must ensure that the
--   <a>GivesPopper</a> can be called multiple times. Usually this is not a
--   problem.
--   
--   The <a>RequestBodyStreamChunked</a> will send a chunked request body.
--   Note that not all servers support this. Only use
--   <a>RequestBodyStreamChunked</a> if you know the server you're sending
--   to supports chunked request bodies.
--   
--   Since 0.1.0
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> GivesPopper () -> RequestBody
RequestBodyStreamChunked :: GivesPopper () -> RequestBody

-- | Allows creation of a <tt>RequestBody</tt> inside the <tt>IO</tt>
--   monad, which is useful for making easier APIs (like
--   <tt>setRequestBodyFile</tt>).
RequestBodyIO :: IO RequestBody -> RequestBody

-- | All information on how to connect to a host and what should be sent in
--   the HTTP request.
--   
--   If you simply wish to download from a URL, see <tt>parseRequest</tt>.
--   
--   The constructor for this data type is not exposed. Instead, you should
--   use either the <tt>defaultRequest</tt> value, or <tt>parseRequest</tt>
--   to construct from a URL, and then use the records below to make
--   modifications. This approach allows http-client to add configuration
--   options without breaking backwards compatibility.
--   
--   For example, to construct a POST request, you could do something like:
--   
--   <pre>
--   initReq &lt;- parseRequest "http://www.example.com/path"
--   let req = initReq
--               { method = "POST"
--               }
--   </pre>
--   
--   For more information, please see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data Request

-- | HTTP request method, eg GET, POST.
--   
--   Since 0.1.0
method :: Request -> Method

-- | Whether to use HTTPS (ie, SSL).
--   
--   Since 0.1.0
secure :: Request -> Bool

-- | Requested host name, used for both the IP address to connect to and
--   the <tt>host</tt> request header.
--   
--   Since 0.1.0
host :: Request -> ByteString

-- | The port to connect to. Also used for generating the <tt>host</tt>
--   request header.
--   
--   Since 0.1.0
port :: Request -> Int

-- | Everything from the host to the query string.
--   
--   Since 0.1.0
path :: Request -> ByteString

-- | Query string appended to the path.
--   
--   Since 0.1.0
queryString :: Request -> ByteString

-- | Custom HTTP request headers
--   
--   The Content-Length and Transfer-Encoding headers are set automatically
--   by this module, and shall not be added to <tt>requestHeaders</tt>.
--   
--   If not provided by the user, <tt>Host</tt> will automatically be set
--   based on the <tt>host</tt> and <tt>port</tt> fields.
--   
--   Moreover, the Accept-Encoding header is set implicitly to gzip for
--   convenience by default. This behaviour can be overridden if needed, by
--   setting the header explicitly to a different value. In order to omit
--   the Accept-Header altogether, set it to the empty string "". If you
--   need an empty Accept-Header (i.e. requesting the identity encoding),
--   set it to a non-empty white-space string, e.g. " ". See RFC 2616
--   section 14.3 for details about the semantics of the Accept-Header
--   field. If you request a content-encoding not supported by this module,
--   you will have to decode it yourself (see also the <a>decompress</a>
--   field).
--   
--   Note: Multiple header fields with the same field-name will result in
--   multiple header fields being sent and therefore it's the
--   responsibility of the client code to ensure that the rules from RFC
--   2616 section 4.2 are honoured.
--   
--   Since 0.1.0
requestHeaders :: Request -> RequestHeaders

-- | Request body to be sent to the server.
--   
--   Since 0.1.0
requestBody :: Request -> RequestBody

-- | Optional HTTP proxy.
--   
--   Since 0.1.0
proxy :: Request -> Maybe Proxy

-- | Optional resolved host address. May not be used by all backends.
--   
--   Since 0.1.0
hostAddress :: Request -> Maybe HostAddress

-- | If <tt>True</tt>, a chunked and/or gzipped body will not be decoded.
--   Use with caution.
--   
--   Since 0.1.0
rawBody :: Request -> Bool

-- | Predicate to specify whether gzipped data should be decompressed on
--   the fly (see <tt>alwaysDecompress</tt> and
--   <tt>browserDecompress</tt>). Argument is the mime type. Default:
--   browserDecompress.
--   
--   Since 0.1.0
decompress :: Request -> ByteString -> Bool

-- | How many redirects to follow when getting a resource. 0 means follow
--   no redirects. Default value: 10.
--   
--   Since 0.1.0
redirectCount :: Request -> Int

-- | Decide whether a header must be stripped from the request when
--   following a redirect. Default: keep all headers intact.
shouldStripHeaderOnRedirect :: Request -> HeaderName -> Bool

-- | Check the response immediately after receiving the status and headers.
--   This can be useful for throwing exceptions on non-success status
--   codes.
--   
--   In previous versions of http-client, this went under the name
--   <tt>checkStatus</tt>, but was renamed to avoid confusion about the new
--   default behavior (doing nothing).
checkResponse :: Request -> Request -> Response BodyReader -> IO ()

-- | Number of microseconds to wait for a response (see
--   <a>ResponseTimeout</a> for more information). Default: use
--   <a>managerResponseTimeout</a> (which by default is 30 seconds).
--   
--   Since 0.1.0
responseTimeout :: Request -> ResponseTimeout

-- | A user-defined cookie jar. If <a>Nothing</a>, no cookie handling will
--   take place, "Cookie" headers in <a>requestHeaders</a> will be sent
--   raw, and <a>responseCookieJar</a> will be empty.
--   
--   Since 0.1.0
cookieJar :: Request -> Maybe CookieJar

-- | HTTP version to send to server.
--   
--   Default: HTTP 1.1
--   
--   Since 0.4.3
requestVersion :: Request -> HttpVersion

-- | Set the query string to the given key/value pairs.
--   
--   Since 0.3.6
setQueryString :: [(ByteString, Maybe ByteString)] -> Request -> Request
requestBodySource :: Int64 -> ConduitM () ByteString (ResourceT IO) () -> RequestBody
requestBodySourceChunked :: ConduitM () ByteString (ResourceT IO) () -> RequestBody
requestBodySourceIO :: Int64 -> ConduitM () ByteString IO () -> RequestBody
requestBodySourceChunkedIO :: ConduitM () ByteString IO () -> RequestBody

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body

-- | Status code of the response.
--   
--   Since 0.1.0
responseStatus :: Response body -> Status

-- | HTTP version used by the server.
--   
--   Since 0.1.0
responseVersion :: Response body -> HttpVersion

-- | Response headers sent by the server.
--   
--   Since 0.1.0
responseHeaders :: Response body -> ResponseHeaders

-- | Response body sent by the server.
--   
--   Since 0.1.0
responseBody :: Response body -> body

-- | Cookies set on the client after interacting with the server. If
--   cookies have been disabled by setting <a>cookieJar</a> to
--   <tt>Nothing</tt>, then this will always be empty.
--   
--   Since 0.1.0
responseCookieJar :: Response body -> CookieJar

-- | Keeps track of open connections for keep-alive.
--   
--   If possible, you should share a single <a>Manager</a> between multiple
--   threads and requests.
--   
--   Since 0.1.0
data Manager

-- | Create a <a>Manager</a>. The <tt>Manager</tt> will be shut down
--   automatically via garbage collection.
--   
--   Creating a new <a>Manager</a> is a relatively expensive operation, you
--   are advised to share a single <a>Manager</a> between requests instead.
--   
--   The first argument to this function is often
--   <a>defaultManagerSettings</a>, though add-on libraries may provide a
--   recommended replacement.
--   
--   Since 0.1.0
newManager :: ManagerSettings -> IO Manager

-- | Close all connections in a <a>Manager</a>.
--   
--   Note that this doesn't affect currently in-flight connections, meaning
--   you can safely use it without hurting any queries you may have
--   concurrently running.
--   
--   Since 0.1.0
closeManager :: Manager -> IO ()

-- | Settings for a <tt>Manager</tt>. Please use the
--   <tt>defaultManagerSettings</tt> function and then modify individual
--   settings. For more information, see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data ManagerSettings

-- | Default TLS-enabled manager settings
tlsManagerSettings :: ManagerSettings

-- | Create a TLS-enabled <a>ManagerSettings</a> with the given
--   <a>TLSSettings</a> and <a>SockSettings</a>
mkManagerSettings :: TLSSettings -> Maybe SockSettings -> ManagerSettings

-- | Number of connections to a single host to keep alive. Default: 10.
--   
--   Since 0.1.0
managerConnCount :: ManagerSettings -> Int

-- | Default timeout to be applied to requests which do not provide a
--   timeout value.
--   
--   Default is 30 seconds
managerResponseTimeout :: ManagerSettings -> ResponseTimeout

-- | Create a TLS connection. Default behavior: throw an exception that TLS
--   is not supported.
--   
--   Since 0.1.0
managerTlsConnection :: ManagerSettings -> IO (Maybe HostAddress -> String -> Int -> IO Connection)

-- | How to deal with timing out on retrieval of response headers.
data ResponseTimeout

-- | Specify maximum time in microseconds the retrieval of response headers
--   is allowed to take
responseTimeoutMicro :: Int -> ResponseTimeout

-- | Do not have a response timeout
responseTimeoutNone :: ResponseTimeout

-- | Use the default response timeout
--   
--   When used on a <a>Request</a>, means: use the manager's timeout value
--   
--   When used on a <a>ManagerSettings</a>, means: default to 30 seconds
responseTimeoutDefault :: ResponseTimeout
data Cookie
Cookie :: ByteString -> ByteString -> UTCTime -> ByteString -> ByteString -> UTCTime -> UTCTime -> Bool -> Bool -> Bool -> Bool -> Cookie
[cookie_name] :: Cookie -> ByteString
[cookie_value] :: Cookie -> ByteString
[cookie_expiry_time] :: Cookie -> UTCTime
[cookie_domain] :: Cookie -> ByteString
[cookie_path] :: Cookie -> ByteString
[cookie_creation_time] :: Cookie -> UTCTime
[cookie_last_access_time] :: Cookie -> UTCTime
[cookie_persistent] :: Cookie -> Bool
[cookie_host_only] :: Cookie -> Bool
[cookie_secure_only] :: Cookie -> Bool
[cookie_http_only] :: Cookie -> Bool
data CookieJar
createCookieJar :: [Cookie] -> CookieJar
destroyCookieJar :: CookieJar -> [Cookie]

-- | Deprecated synonym for <a>parseUrlThrow</a>. You probably want
--   <a>parseRequest</a> or <a>parseRequest_</a> instead.
parseUrl :: MonadThrow m => String -> m Request

-- | Same as <a>parseRequest</a>, except will throw an <a>HttpException</a>
--   in the event of a non-2XX response. This uses
--   <a>throwErrorStatusCodes</a> to implement <a>checkResponse</a>.
parseUrlThrow :: MonadThrow m => String -> m Request

-- | Convert a URL into a <a>Request</a>.
--   
--   This function defaults some of the values in <a>Request</a>, such as
--   setting <a>method</a> to <tt><a>GET</a></tt> and <a>requestHeaders</a>
--   to <tt>[]</tt>.
--   
--   Since this function uses <a>MonadThrow</a>, the return monad can be
--   anything that is an instance of <a>MonadThrow</a>, such as <a>IO</a>
--   or <a>Maybe</a>.
--   
--   You can place the request method at the beginning of the URL separated
--   by a space, e.g.:
--   
--   @@<tt> parseRequest "POST <a>http://httpbin.org/post"</a> </tt>@@
--   
--   Note that the request method must be provided as all capital letters.
--   
--   A <a>Request</a> created by this function won't cause exceptions on
--   non-2XX response status codes.
--   
--   To create a request which throws on non-2XX status codes, see
--   <a>parseUrlThrow</a>
parseRequest :: MonadThrow m => String -> m Request

-- | Same as <a>parseRequest</a>, but parse errors cause an impure
--   exception. Mostly useful for static strings which are known to be
--   correctly formatted.
parseRequest_ :: String -> Request

-- | A default request value, a GET request of localhost/:80, with an empty
--   request body.
--   
--   Note that the default <a>checkResponse</a> does nothing.
defaultRequest :: Request

-- | Add a Basic Auth header (with the specified user name and password) to
--   the given Request. Ignore error handling:
--   
--   <pre>
--   applyBasicAuth "user" "pass" $ parseRequest_ url
--   </pre>
--   
--   NOTE: The function <tt>applyDigestAuth</tt> is provided by the
--   <tt>http-client-tls</tt> package instead of this package due to extra
--   dependencies. Please use that package if you need to use digest
--   authentication.
--   
--   Since 0.1.0
applyBasicAuth :: ByteString -> ByteString -> Request -> Request

-- | Add a proxy to the Request so that the Request when executed will use
--   the provided proxy.
--   
--   Since 0.1.0
addProxy :: ByteString -> Int -> Request -> Request
lbsResponse :: Monad m => Response (ConduitM () ByteString m ()) -> m (Response ByteString)

-- | If a request is a redirection (status code 3xx) this function will
--   create a new request from the old request, the server headers returned
--   with the redirection, and the redirection code itself. This function
--   returns <a>Nothing</a> if the code is not a 3xx, there is no
--   <tt>location</tt> header included, or if the redirected response
--   couldn't be parsed with <a>parseRequest</a>.
--   
--   If a user of this library wants to know the url chain that results
--   from a specific request, that user has to re-implement the
--   redirect-following logic themselves. An example of that might look
--   like this:
--   
--   <pre>
--   myHttp req man = do
--      (res, redirectRequests) &lt;- (`runStateT` []) $
--           'httpRedirect'
--               9000
--               (\req' -&gt; do
--                  res &lt;- http req'{redirectCount=0} man
--                  modify (\rqs -&gt; req' : rqs)
--                  return (res, getRedirectedRequest req' (responseHeaders res) (responseCookieJar res) (W.statusCode (responseStatus res))
--                  )
--               'lift'
--               req
--      applyCheckStatus (checkStatus req) res
--      return redirectRequests
--   </pre>
getRedirectedRequest :: Request -> ResponseHeaders -> CookieJar -> Int -> Maybe Request

-- | Always decompress a compressed stream.
alwaysDecompress :: ByteString -> Bool

-- | Decompress a compressed stream unless the content-type is
--   'application/x-tar'.
browserDecompress :: ByteString -> Bool

-- | Add url-encoded parameters to the <a>Request</a>.
--   
--   This sets a new <a>requestBody</a>, adds a content-type request header
--   and changes the <a>method</a> to POST.
--   
--   Since 0.1.0
urlEncodedBody :: [(ByteString, ByteString)] -> Request -> Request

-- | An exception which may be generated by this library
data HttpException

-- | Most exceptions are specific to a <a>Request</a>. Inspect the
--   <a>HttpExceptionContent</a> value for details on what occurred.
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException

-- | A URL (first field) is invalid for a given reason (second argument).
InvalidUrlException :: String -> String -> HttpException
data HttpExceptionContent

-- | Generated by the <tt>parseUrlThrow</tt> function when the server
--   returns a non-2XX response status code.
--   
--   May include the beginning of the response body.
StatusCodeException :: Response () -> ByteString -> HttpExceptionContent

-- | The server responded with too many redirects for a request.
--   
--   Contains the list of encountered responses containing redirects in
--   reverse chronological order; including last redirect, which triggered
--   the exception and was not followed.
TooManyRedirects :: [Response ByteString] -> HttpExceptionContent

-- | Either too many headers, or too many total bytes in a single header,
--   were returned by the server, and the memory exhaustion protection in
--   this library has kicked in.
OverlongHeaders :: HttpExceptionContent

-- | The server took too long to return a response. This can be altered via
--   <a>responseTimeout</a> or <a>managerResponseTimeout</a>.
ResponseTimeout :: HttpExceptionContent

-- | Attempting to connect to the server timed out.
ConnectionTimeout :: HttpExceptionContent

-- | An exception occurred when trying to connect to the server.
ConnectionFailure :: SomeException -> HttpExceptionContent

-- | The status line returned by the server could not be parsed.
InvalidStatusLine :: ByteString -> HttpExceptionContent

-- | The given response header line could not be parsed
InvalidHeader :: ByteString -> HttpExceptionContent

-- | The given request header is not compliant (e.g. has newlines)
InvalidRequestHeader :: ByteString -> HttpExceptionContent

-- | An exception was raised by an underlying library when performing the
--   request. Most often, this is caused by a failing socket action or a
--   TLS exception.
InternalException :: SomeException -> HttpExceptionContent

-- | A non-200 status code was returned when trying to connect to the proxy
--   server on the given host and port.
ProxyConnectException :: ByteString -> Int -> Status -> HttpExceptionContent

-- | No response data was received from the server at all. This exception
--   may deserve special handling within the library, since it may indicate
--   that a pipelining has been used, and a connection thought to be open
--   was in fact closed.
NoResponseDataReceived :: HttpExceptionContent

-- | Exception thrown when using a <tt>Manager</tt> which does not have
--   support for secure connections. Typically, you will want to use
--   <tt>tlsManagerSettings</tt> from <tt>http-client-tls</tt> to overcome
--   this.
TlsNotSupported :: HttpExceptionContent

-- | The request body provided did not match the expected size.
--   
--   Provides the expected and actual size.
WrongRequestBodyStreamSize :: Word64 -> Word64 -> HttpExceptionContent

-- | The returned response body is too short. Provides the expected size
--   and actual size.
ResponseBodyTooShort :: Word64 -> Word64 -> HttpExceptionContent

-- | A chunked response body had invalid headers.
InvalidChunkHeaders :: HttpExceptionContent

-- | An incomplete set of response headers were returned.
IncompleteHeaders :: HttpExceptionContent

-- | The host we tried to connect to is invalid (e.g., an empty string).
InvalidDestinationHost :: ByteString -> HttpExceptionContent

-- | An exception was thrown when inflating a response body.
HttpZlibException :: ZlibException -> HttpExceptionContent

-- | Values in the proxy environment variable were invalid. Provides the
--   environment variable name and its value.
InvalidProxyEnvironmentVariable :: Text -> Text -> HttpExceptionContent

-- | Attempted to use a <a>Connection</a> which was already closed
ConnectionClosed :: HttpExceptionContent

-- | Proxy settings are not valid (Windows specific currently) @since 0.5.7
InvalidProxySettings :: Text -> HttpExceptionContent


-- | Simplified interface for common HTTP client interactions. Tutorial
--   available at <a>https://haskell-lang.org/library/http-client</a>
--   
--   Important note: <a>Request</a> is an instance of <a>IsString</a>, and
--   therefore recommended usage is to turn on <tt>OverloadedStrings</tt>,
--   e.g.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.HTTP.Simple
--   import qualified Data.ByteString.Char8 as B8
--   
--   main :: IO ()
--   main = httpBS "http://example.com" &gt;&gt;= B8.putStrLn . getResponseBody
--   </pre>
--   
--   The <a>IsString</a> instance uses <a>parseRequest</a> behind the
--   scenes and inherits its behavior.
module Network.HTTP.Simple

-- | Perform an HTTP request and return the body as a <tt>ByteString</tt>.
httpBS :: MonadIO m => Request -> m (Response ByteString)

-- | Perform an HTTP request and return the body as a lazy
--   <tt>ByteString</tt>. Note that the entire value will be read into
--   memory at once (no lazy I/O will be performed). The advantage of a
--   lazy <tt>ByteString</tt> here (versus using <a>httpBS</a>) is--if
--   needed--a better in-memory representation.
httpLBS :: MonadIO m => Request -> m (Response ByteString)

-- | Perform an HTTP request and ignore the response body.
httpNoBody :: MonadIO m => Request -> m (Response ())

-- | Perform an HTTP request and parse the body as JSON. In the event of an
--   JSON parse errors, a <a>JSONException</a> runtime exception will be
--   thrown.
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
httpJSON :: (MonadIO m, FromJSON a) => Request -> m (Response a)

-- | Perform an HTTP request and parse the body as JSON. In the event of an
--   JSON parse errors, a <tt>Left</tt> value will be returned.
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
httpJSONEither :: (MonadIO m, FromJSON a) => Request -> m (Response (Either JSONException a))

-- | Perform an HTTP request and consume the body with the given
--   <a>Sink</a>
httpSink :: MonadUnliftIO m => Request -> (Response () -> ConduitM ByteString Void m a) -> m a

-- | Perform an HTTP request, and get the response body as a Source.
--   
--   The second argument to this function tells us how to make the Source
--   from the Response itself. This allows you to perform actions with the
--   status or headers, for example, in addition to the raw bytes
--   themselves. If you just care about the response body, you can use
--   <a>getResponseBody</a> as the second argument here.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import           Control.Monad.IO.Class       (liftIO)
--   import           Control.Monad.Trans.Resource (runResourceT)
--   import           Data.Conduit                 (($$))
--   import qualified Data.Conduit.Binary          as CB
--   import qualified Data.Conduit.List            as CL
--   import           Network.HTTP.Simple
--   import           System.IO                    (stdout)
--   
--   main :: IO ()
--   main =
--       runResourceT
--           $ httpSource "<a>http://httpbin.org/robots.txt"</a> getSrc
--          $$ CB.sinkHandle stdout
--     where
--       getSrc res = do
--           liftIO $ print (getResponseStatus res, getResponseHeaders res)
--           getResponseBody res
--   </pre>
httpSource :: (MonadResource m, MonadIO n) => Request -> (Response (ConduitM i ByteString n ()) -> ConduitM i o m r) -> ConduitM i o m r

-- | Perform an action with the given request. This employes the bracket
--   pattern.
--   
--   This is similar to <a>httpSource</a>, but does not require
--   <a>MonadResource</a> and allows the result to not contain a
--   <a>ConduitM</a> value.
withResponse :: (MonadUnliftIO m, MonadIO n) => Request -> (Response (ConduitM i ByteString n ()) -> m a) -> m a

-- | Header
type Header = (HeaderName, ByteString)

-- | Query.
--   
--   General form: <tt>a=b&amp;c=d</tt>, but if the value is Nothing, it
--   becomes <tt>a&amp;c=d</tt>.
type Query = [QueryItem]

-- | Query item
type QueryItem = (ByteString, Maybe ByteString)

-- | All information on how to connect to a host and what should be sent in
--   the HTTP request.
--   
--   If you simply wish to download from a URL, see <tt>parseRequest</tt>.
--   
--   The constructor for this data type is not exposed. Instead, you should
--   use either the <tt>defaultRequest</tt> value, or <tt>parseRequest</tt>
--   to construct from a URL, and then use the records below to make
--   modifications. This approach allows http-client to add configuration
--   options without breaking backwards compatibility.
--   
--   For example, to construct a POST request, you could do something like:
--   
--   <pre>
--   initReq &lt;- parseRequest "http://www.example.com/path"
--   let req = initReq
--               { method = "POST"
--               }
--   </pre>
--   
--   For more information, please see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data Request

-- | Request Headers
type RequestHeaders = [Header]

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body

-- | Response Headers
type ResponseHeaders = [Header]

-- | An exception that can occur when parsing JSON
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
data JSONException
JSONParseException :: Request -> Response () -> ParseError -> JSONException
JSONConversionException :: Request -> Response Value -> String -> JSONException

-- | An exception which may be generated by this library
data HttpException

-- | Most exceptions are specific to a <a>Request</a>. Inspect the
--   <a>HttpExceptionContent</a> value for details on what occurred.
HttpExceptionRequest :: Request -> HttpExceptionContent -> HttpException

-- | A URL (first field) is invalid for a given reason (second argument).
InvalidUrlException :: String -> String -> HttpException

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy
Proxy :: ByteString -> Int -> Proxy

-- | The host name of the HTTP proxy.
[proxyHost] :: Proxy -> ByteString

-- | The port number of the HTTP proxy.
[proxyPort] :: Proxy -> Int

-- | A default request value, a GET request of localhost/:80, with an empty
--   request body.
--   
--   Note that the default <a>checkResponse</a> does nothing.
defaultRequest :: Request

-- | Convert a URL into a <a>Request</a>.
--   
--   This function defaults some of the values in <a>Request</a>, such as
--   setting <a>method</a> to <tt><a>GET</a></tt> and <a>requestHeaders</a>
--   to <tt>[]</tt>.
--   
--   Since this function uses <a>MonadThrow</a>, the return monad can be
--   anything that is an instance of <a>MonadThrow</a>, such as <a>IO</a>
--   or <a>Maybe</a>.
--   
--   You can place the request method at the beginning of the URL separated
--   by a space, e.g.:
--   
--   @@<tt> parseRequest "POST <a>http://httpbin.org/post"</a> </tt>@@
--   
--   Note that the request method must be provided as all capital letters.
--   
--   A <a>Request</a> created by this function won't cause exceptions on
--   non-2XX response status codes.
--   
--   To create a request which throws on non-2XX status codes, see
--   <a>parseUrlThrow</a>
parseRequest :: MonadThrow m => String -> m Request

-- | Same as <a>parseRequest</a>, but parse errors cause an impure
--   exception. Mostly useful for static strings which are known to be
--   correctly formatted.
parseRequest_ :: String -> Request

-- | Same as <tt>parseRequest</tt>, except will throw an
--   <tt>HttpException</tt> in the event of a non-2XX response. This uses
--   <tt>throwErrorStatusCodes</tt> to implement <tt>checkResponse</tt>.
--   
--   Exactly the same as <tt>parseUrlThrow</tt>, but has a name that is
--   more consistent with the other parseRequest functions.
parseRequestThrow :: MonadThrow m => String -> m Request

-- | Same as <a>parseRequestThrow</a>, but parse errors cause an impure
--   exception. Mostly useful for static strings which are known to be
--   correctly formatted.
parseRequestThrow_ :: String -> Request

-- | Set the request method
setRequestMethod :: ByteString -> Request -> Request

-- | Set whether this is a secure<i>HTTPS (<tt>True</tt>) or
--   insecure</i>HTTP (<tt>False</tt>) request
setRequestSecure :: Bool -> Request -> Request

-- | Set the destination host of the request
setRequestHost :: ByteString -> Request -> Request

-- | Set the destination port of the request
setRequestPort :: Int -> Request -> Request

-- | Lens for the requested path info of the request
setRequestPath :: ByteString -> Request -> Request

-- | Add a request header name/value combination
addRequestHeader :: HeaderName -> ByteString -> Request -> Request

-- | Get all request header values for the given name
getRequestHeader :: HeaderName -> Request -> [ByteString]

-- | Set the given request header to the given list of values. Removes any
--   previously set header values with the same name.
setRequestHeader :: HeaderName -> [ByteString] -> Request -> Request

-- | Set the request headers, wiping out <b>all</b> previously set headers.
--   This means if you use <a>setRequestHeaders</a> to set some headers and
--   also use one of the other setters that modifies the
--   <tt>content-type</tt> header (such as <a>setRequestBodyJSON</a>), be
--   sure that <a>setRequestHeaders</a> is evaluated <b>first</b>.
setRequestHeaders :: RequestHeaders -> Request -> Request

-- | Set the query string parameters
setRequestQueryString :: Query -> Request -> Request

-- | Get the query string parameters
getRequestQueryString :: Request -> Query

-- | Add to the existing query string parameters.
addToRequestQueryString :: Query -> Request -> Request

-- | Set the request body to the given <a>RequestBody</a>. You may want to
--   consider using one of the convenience functions in the modules, e.g.
--   <tt>requestBodyJSON</tt>.
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBody :: RequestBody -> Request -> Request

-- | Set the request body as a JSON value
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
--   
--   This also sets the <tt>Content-Type</tt> to <tt>application/json;
--   charset=utf-8</tt>
--   
--   NOTE: Depends on the <tt>aeson</tt> cabal flag being enabled
setRequestBodyJSON :: ToJSON a => a -> Request -> Request

-- | Set the request body as a lazy <tt>ByteString</tt>
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodyLBS :: ByteString -> Request -> Request

-- | Set the request body as a <a>Source</a>
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodySource :: Int64 -> ConduitM () ByteString IO () -> Request -> Request

-- | Set the request body as a file
--   
--   <i>Note</i>: This will not modify the request method. For that, please
--   use <tt>requestMethod</tt>. You likely don't want the default of
--   <tt>GET</tt>.
setRequestBodyFile :: FilePath -> Request -> Request

-- | Set the request body as URL encoded data
--   
--   <i>Note</i>: This will change the request method to <tt>POST</tt> and
--   set the <tt>content-type</tt> to
--   <tt>application/x-www-form-urlencoded</tt>
setRequestBodyURLEncoded :: [(ByteString, ByteString)] -> Request -> Request

-- | Modify the request so that non-2XX status codes do not generate a
--   runtime <a>StatusCodeException</a>.
setRequestIgnoreStatus :: Request -> Request

-- | Modify the request so that non-2XX status codes generate a runtime
--   <a>StatusCodeException</a>, by using <a>throwErrorStatusCodes</a>
setRequestCheckStatus :: Request -> Request

-- | Set basic auth with the given username and password
setRequestBasicAuth :: ByteString -> ByteString -> Request -> Request

-- | Instead of using the default global <a>Manager</a>, use the supplied
--   <tt>Manager</tt>.
setRequestManager :: Manager -> Request -> Request

-- | Override the default proxy server settings
setRequestProxy :: Maybe Proxy -> Request -> Request

-- | Set the maximum time to wait for a response
setRequestResponseTimeout :: ResponseTimeout -> Request -> Request

-- | Get the status of the response
getResponseStatus :: Response a -> Status

-- | Get the integral status code of the response
getResponseStatusCode :: Response a -> Int

-- | Get all response header values with the given name
getResponseHeader :: HeaderName -> Response a -> [ByteString]

-- | Get all response headers
getResponseHeaders :: Response a -> [(HeaderName, ByteString)]

-- | Get the response body
getResponseBody :: Response a -> a

-- | Alternate spelling of <a>httpLBS</a>
httpLbs :: MonadIO m => Request -> m (Response ByteString)
instance GHC.Show.Show Network.HTTP.Simple.JSONException
instance GHC.Exception.Type.Exception Network.HTTP.Simple.JSONException
