<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_HADDOCK not-home #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE RankNTypes #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE GADTs #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses     #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE NoImplicitPrelude         #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE NoMonomorphismRestriction #-}</span><span>
</span><span id="line-9"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Conduit.Combinators.Unqualified</span><span>
</span><span id="line-10"></span><span>    </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- ** Producers</span></span><span>
</span><span id="line-11"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Pure</span></span><span>
</span><span id="line-12"></span><span>      </span><span class="annot"><a href="Data.Conduit.Combinators.html#yieldMany"><span class="hs-identifier">CC.yieldMany</span></a></span><span>
</span><span id="line-13"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unfoldC"><span class="hs-identifier">unfoldC</span></a></span><span>
</span><span id="line-14"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#enumFromToC"><span class="hs-identifier">enumFromToC</span></a></span><span>
</span><span id="line-15"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterateC"><span class="hs-identifier">iterateC</span></a></span><span>
</span><span id="line-16"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatC"><span class="hs-identifier">repeatC</span></a></span><span>
</span><span id="line-17"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateC"><span class="hs-identifier">replicateC</span></a></span><span>
</span><span id="line-18"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceLazy"><span class="hs-identifier">CC.sourceLazy</span></a></span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Monadic</span></span><span>
</span><span id="line-21"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatMC"><span class="hs-identifier">repeatMC</span></a></span><span>
</span><span id="line-22"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatWhileMC"><span class="hs-identifier">repeatWhileMC</span></a></span><span>
</span><span id="line-23"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateMC"><span class="hs-identifier">replicateMC</span></a></span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** I\/O</span></span><span>
</span><span id="line-26"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceFile"><span class="hs-identifier">CC.sourceFile</span></a></span><span>
</span><span id="line-27"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceFileBS"><span class="hs-identifier">CC.sourceFileBS</span></a></span><span>
</span><span id="line-28"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceHandle"><span class="hs-identifier">CC.sourceHandle</span></a></span><span>
</span><span id="line-29"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceHandleUnsafe"><span class="hs-identifier">CC.sourceHandleUnsafe</span></a></span><span>
</span><span id="line-30"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceIOHandle"><span class="hs-identifier">CC.sourceIOHandle</span></a></span><span>
</span><span id="line-31"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdinC"><span class="hs-identifier">stdinC</span></a></span><span>
</span><span id="line-32"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#withSourceFile"><span class="hs-identifier">CC.withSourceFile</span></a></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Filesystem</span></span><span>
</span><span id="line-35"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceDirectory"><span class="hs-identifier">CC.sourceDirectory</span></a></span><span>
</span><span id="line-36"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sourceDirectoryDeep"><span class="hs-identifier">CC.sourceDirectoryDeep</span></a></span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span>      </span><span class="annot"><span class="hs-comment">-- ** Consumers</span></span><span>
</span><span id="line-39"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Pure</span></span><span>
</span><span id="line-40"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropC"><span class="hs-identifier">dropC</span></a></span><span>
</span><span id="line-41"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropCE"><span class="hs-identifier">dropCE</span></a></span><span>
</span><span id="line-42"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileC"><span class="hs-identifier">dropWhileC</span></a></span><span>
</span><span id="line-43"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileCE"><span class="hs-identifier">dropWhileCE</span></a></span><span>
</span><span id="line-44"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldC"><span class="hs-identifier">foldC</span></a></span><span>
</span><span id="line-45"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldCE"><span class="hs-identifier">foldCE</span></a></span><span>
</span><span id="line-46"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlC"><span class="hs-identifier">foldlC</span></a></span><span>
</span><span id="line-47"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlCE"><span class="hs-identifier">foldlCE</span></a></span><span>
</span><span id="line-48"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapC"><span class="hs-identifier">foldMapC</span></a></span><span>
</span><span id="line-49"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapCE"><span class="hs-identifier">foldMapCE</span></a></span><span>
</span><span id="line-50"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allC"><span class="hs-identifier">allC</span></a></span><span>
</span><span id="line-51"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allCE"><span class="hs-identifier">allCE</span></a></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyC"><span class="hs-identifier">anyC</span></a></span><span>
</span><span id="line-53"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyCE"><span class="hs-identifier">anyCE</span></a></span><span>
</span><span id="line-54"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andC"><span class="hs-identifier">andC</span></a></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andCE"><span class="hs-identifier">andCE</span></a></span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orC"><span class="hs-identifier">orC</span></a></span><span>
</span><span id="line-57"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orCE"><span class="hs-identifier">orCE</span></a></span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#asumC"><span class="hs-identifier">asumC</span></a></span><span>
</span><span id="line-59"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemC"><span class="hs-identifier">elemC</span></a></span><span>
</span><span id="line-60"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemCE"><span class="hs-identifier">elemCE</span></a></span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemC"><span class="hs-identifier">notElemC</span></a></span><span>
</span><span id="line-62"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemCE"><span class="hs-identifier">notElemCE</span></a></span><span>
</span><span id="line-63"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkLazy"><span class="hs-identifier">CC.sinkLazy</span></a></span><span>
</span><span id="line-64"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkList"><span class="hs-identifier">CC.sinkList</span></a></span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkVector"><span class="hs-identifier">CC.sinkVector</span></a></span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkVectorN"><span class="hs-identifier">CC.sinkVectorN</span></a></span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkLazyBuilder"><span class="hs-identifier">CC.sinkLazyBuilder</span></a></span><span>
</span><span id="line-68"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkNull"><span class="hs-identifier">CC.sinkNull</span></a></span><span>
</span><span id="line-69"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#awaitNonNull"><span class="hs-identifier">CC.awaitNonNull</span></a></span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headC"><span class="hs-identifier">headC</span></a></span><span>
</span><span id="line-71"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headDefC"><span class="hs-identifier">headDefC</span></a></span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headCE"><span class="hs-identifier">headCE</span></a></span><span>
</span><span id="line-73"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekC"><span class="hs-identifier">peekC</span></a></span><span>
</span><span id="line-74"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekCE"><span class="hs-identifier">peekCE</span></a></span><span>
</span><span id="line-75"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastC"><span class="hs-identifier">lastC</span></a></span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastDefC"><span class="hs-identifier">lastDefC</span></a></span><span>
</span><span id="line-77"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastCE"><span class="hs-identifier">lastCE</span></a></span><span>
</span><span id="line-78"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthC"><span class="hs-identifier">lengthC</span></a></span><span>
</span><span id="line-79"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthCE"><span class="hs-identifier">lengthCE</span></a></span><span>
</span><span id="line-80"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfC"><span class="hs-identifier">lengthIfC</span></a></span><span>
</span><span id="line-81"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfCE"><span class="hs-identifier">lengthIfCE</span></a></span><span>
</span><span id="line-82"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumC"><span class="hs-identifier">maximumC</span></a></span><span>
</span><span id="line-83"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumCE"><span class="hs-identifier">maximumCE</span></a></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumC"><span class="hs-identifier">minimumC</span></a></span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumCE"><span class="hs-identifier">minimumCE</span></a></span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullC"><span class="hs-identifier">nullC</span></a></span><span>
</span><span id="line-87"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullCE"><span class="hs-identifier">nullCE</span></a></span><span>
</span><span id="line-88"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumC"><span class="hs-identifier">sumC</span></a></span><span>
</span><span id="line-89"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumCE"><span class="hs-identifier">sumCE</span></a></span><span>
</span><span id="line-90"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productC"><span class="hs-identifier">productC</span></a></span><span>
</span><span id="line-91"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productCE"><span class="hs-identifier">productCE</span></a></span><span>
</span><span id="line-92"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#findC"><span class="hs-identifier">findC</span></a></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Monadic</span></span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_C"><span class="hs-identifier">mapM_C</span></a></span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_CE"><span class="hs-identifier">mapM_CE</span></a></span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMC"><span class="hs-identifier">foldMC</span></a></span><span>
</span><span id="line-98"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMCE"><span class="hs-identifier">foldMCE</span></a></span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMC"><span class="hs-identifier">foldMapMC</span></a></span><span>
</span><span id="line-100"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMCE"><span class="hs-identifier">foldMapMCE</span></a></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** I\/O</span></span><span>
</span><span id="line-103"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkFile"><span class="hs-identifier">CC.sinkFile</span></a></span><span>
</span><span id="line-104"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkFileCautious"><span class="hs-identifier">CC.sinkFileCautious</span></a></span><span>
</span><span id="line-105"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkTempFile"><span class="hs-identifier">CC.sinkTempFile</span></a></span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkSystemTempFile"><span class="hs-identifier">CC.sinkSystemTempFile</span></a></span><span>
</span><span id="line-107"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkFileBS"><span class="hs-identifier">CC.sinkFileBS</span></a></span><span>
</span><span id="line-108"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkHandle"><span class="hs-identifier">CC.sinkHandle</span></a></span><span>
</span><span id="line-109"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkIOHandle"><span class="hs-identifier">CC.sinkIOHandle</span></a></span><span>
</span><span id="line-110"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#printC"><span class="hs-identifier">printC</span></a></span><span>
</span><span id="line-111"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdoutC"><span class="hs-identifier">stdoutC</span></a></span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stderrC"><span class="hs-identifier">stderrC</span></a></span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#withSinkFile"><span class="hs-identifier">CC.withSinkFile</span></a></span><span>
</span><span id="line-114"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#withSinkFileBuilder"><span class="hs-identifier">CC.withSinkFileBuilder</span></a></span><span>
</span><span id="line-115"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#withSinkFileCautious"><span class="hs-identifier">CC.withSinkFileCautious</span></a></span><span>
</span><span id="line-116"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkHandleBuilder"><span class="hs-identifier">CC.sinkHandleBuilder</span></a></span><span>
</span><span id="line-117"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#sinkHandleFlush"><span class="hs-identifier">CC.sinkHandleFlush</span></a></span><span>
</span><span id="line-118"></span><span>
</span><span id="line-119"></span><span>      </span><span class="annot"><span class="hs-comment">-- ** Transformers</span></span><span>
</span><span id="line-120"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Pure</span></span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapC"><span class="hs-identifier">mapC</span></a></span><span>
</span><span id="line-122"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapCE"><span class="hs-identifier">mapCE</span></a></span><span>
</span><span id="line-123"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapCE"><span class="hs-identifier">omapCE</span></a></span><span>
</span><span id="line-124"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapC"><span class="hs-identifier">concatMapC</span></a></span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapCE"><span class="hs-identifier">concatMapCE</span></a></span><span>
</span><span id="line-126"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeC"><span class="hs-identifier">takeC</span></a></span><span>
</span><span id="line-127"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeCE"><span class="hs-identifier">takeCE</span></a></span><span>
</span><span id="line-128"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileC"><span class="hs-identifier">takeWhileC</span></a></span><span>
</span><span id="line-129"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileCE"><span class="hs-identifier">takeWhileCE</span></a></span><span>
</span><span id="line-130"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyC"><span class="hs-identifier">takeExactlyC</span></a></span><span>
</span><span id="line-131"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyCE"><span class="hs-identifier">takeExactlyCE</span></a></span><span>
</span><span id="line-132"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatC"><span class="hs-identifier">concatC</span></a></span><span>
</span><span id="line-133"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterC"><span class="hs-identifier">filterC</span></a></span><span>
</span><span id="line-134"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterCE"><span class="hs-identifier">filterCE</span></a></span><span>
</span><span id="line-135"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapWhileC"><span class="hs-identifier">mapWhileC</span></a></span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#conduitVector"><span class="hs-identifier">conduitVector</span></a></span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlC"><span class="hs-identifier">scanlC</span></a></span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileC"><span class="hs-identifier">mapAccumWhileC</span></a></span><span>
</span><span id="line-139"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumC"><span class="hs-identifier">concatMapAccumC</span></a></span><span>
</span><span id="line-140"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#intersperseC"><span class="hs-identifier">intersperseC</span></a></span><span>
</span><span id="line-141"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#slidingWindowC"><span class="hs-identifier">slidingWindowC</span></a></span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfCE"><span class="hs-identifier">chunksOfCE</span></a></span><span>
</span><span id="line-143"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfExactlyCE"><span class="hs-identifier">chunksOfExactlyCE</span></a></span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Monadic</span></span><span>
</span><span id="line-146"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMC"><span class="hs-identifier">mapMC</span></a></span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMCE"><span class="hs-identifier">mapMCE</span></a></span><span>
</span><span id="line-148"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapMCE"><span class="hs-identifier">omapMCE</span></a></span><span>
</span><span id="line-149"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapMC"><span class="hs-identifier">concatMapMC</span></a></span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMC"><span class="hs-identifier">filterMC</span></a></span><span>
</span><span id="line-151"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMCE"><span class="hs-identifier">filterMCE</span></a></span><span>
</span><span id="line-152"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterMC"><span class="hs-identifier">iterMC</span></a></span><span>
</span><span id="line-153"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlMC"><span class="hs-identifier">scanlMC</span></a></span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileMC"><span class="hs-identifier">mapAccumWhileMC</span></a></span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumMC"><span class="hs-identifier">concatMapAccumMC</span></a></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span>      </span><span class="annot"><span class="hs-comment">-- *** Textual</span></span><span>
</span><span id="line-158"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#encodeUtf8C"><span class="hs-identifier">encodeUtf8C</span></a></span><span>
</span><span id="line-159"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8C"><span class="hs-identifier">decodeUtf8C</span></a></span><span>
</span><span id="line-160"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8LenientC"><span class="hs-identifier">decodeUtf8LenientC</span></a></span><span>
</span><span id="line-161"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineC"><span class="hs-identifier">lineC</span></a></span><span>
</span><span id="line-162"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineAsciiC"><span class="hs-identifier">lineAsciiC</span></a></span><span>
</span><span id="line-163"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesC"><span class="hs-identifier">unlinesC</span></a></span><span>
</span><span id="line-164"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesAsciiC"><span class="hs-identifier">unlinesAsciiC</span></a></span><span>
</span><span id="line-165"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedC"><span class="hs-identifier">linesUnboundedC</span></a></span><span>
</span><span id="line-166"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedAsciiC"><span class="hs-identifier">linesUnboundedAsciiC</span></a></span><span>
</span><span id="line-167"></span><span>
</span><span id="line-168"></span><span>      </span><span class="annot"><span class="hs-comment">-- ** Builders</span></span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#builderToByteString"><span class="hs-identifier">CC.builderToByteString</span></a></span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#unsafeBuilderToByteString"><span class="hs-identifier">CC.unsafeBuilderToByteString</span></a></span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#builderToByteStringWith"><span class="hs-identifier">CC.builderToByteStringWith</span></a></span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#builderToByteStringFlush"><span class="hs-identifier">CC.builderToByteStringFlush</span></a></span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#builderToByteStringWithFlush"><span class="hs-identifier">CC.builderToByteStringWithFlush</span></a></span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#BufferAllocStrategy"><span class="hs-identifier">CC.BufferAllocStrategy</span></a></span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#allNewBuffersStrategy"><span class="hs-identifier">CC.allNewBuffersStrategy</span></a></span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#reuseBufferStrategy"><span class="hs-identifier">CC.reuseBufferStrategy</span></a></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span>      </span><span class="annot"><span class="hs-comment">-- ** Special</span></span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#vectorBuilderC"><span class="hs-identifier">vectorBuilderC</span></a></span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#mapAccumS"><span class="hs-identifier">CC.mapAccumS</span></a></span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#peekForever"><span class="hs-identifier">CC.peekForever</span></a></span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html#peekForeverE"><span class="hs-identifier">CC.peekForeverE</span></a></span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span class="hs-comment">-- BEGIN IMPORTS</span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.html"><span class="hs-identifier">Data.Conduit.Combinators</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">CC</span></span><span>
</span><span id="line-188"></span><span class="hs-comment">-- BEGIN IMPORTS</span><span>
</span><span id="line-189"></span><span>
</span><span id="line-190"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Traversable</span></span><span>
</span><span id="line-191"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Alternative</span></span><span class="hs-special">)</span><span>
</span><span id="line-192"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.IO.Class</span></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadIO</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Primitive</span></span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">PrimMonad</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">PrimState</span></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Resource</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadThrow</span></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Data.Conduit.html"><span class="hs-identifier">Data.Conduit</span></a></span><span>
</span><span id="line-196"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Monoid</span></span><span>                 </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Monoid</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.MonoTraversable</span></span><span>
</span><span id="line-198"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Sequences</span></span><span>              </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Seq</span></span><span>
</span><span id="line-199"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Vector.Generic</span></span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">V</span></span><span>
</span><span id="line-200"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Bool</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Eq</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Int</span></span><span class="hs-special">,</span><span>
</span><span id="line-201"></span><span>                                              </span><span class="annot"><span class="hs-identifier">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Monad</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Num</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-202"></span><span>                                              </span><span class="annot"><span class="hs-identifier">Ord</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Functor</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Either</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-203"></span><span>                                              </span><span class="annot"><span class="hs-identifier">Enum</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Show</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Char</span></span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Word</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Word8</span></span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ByteString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ByteString</span></span><span class="hs-special">)</span><span>
</span><span id="line-206"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Text</span></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span>
</span><span id="line-208"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Sequences</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">DTE</span></span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-comment">-- END IMPORTS</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="hs-comment">-- | Generate a producer from a seed value.</span><span>
</span><span id="line-214"></span><span class="hs-comment">--</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-216"></span><span id="local-6989586621679138737"><span id="local-6989586621679138738"><span id="local-6989586621679138739"><span id="local-6989586621679138740"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unfoldC"><span class="hs-identifier hs-type">unfoldC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138740"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-217"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138739"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138738"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679138739"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-218"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138739"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-219"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138737"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138738"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138740"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-220"></span><span id="unfoldC"><span class="annot"><span class="annottext">unfoldC :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#unfoldC"><span class="hs-identifier hs-var hs-var">unfoldC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b -&gt; Maybe (a, b)) -&gt; b -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) b a i.
Monad m =&gt;
(b -&gt; Maybe (a, b)) -&gt; b -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#unfold"><span class="hs-identifier hs-var">CC.unfold</span></a></span><span>
</span><span id="line-221"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unfoldC"><span class="hs-pragma hs-type">unfoldC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-222"></span><span>
</span><span id="line-223"></span><span class="hs-comment">-- | Enumerate from a value to a final value, inclusive, via 'succ'.</span><span>
</span><span id="line-224"></span><span class="hs-comment">--</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- This is generally more efficient than using @Prelude@\'s @enumFromTo@ and</span><span>
</span><span id="line-226"></span><span class="hs-comment">-- combining with @sourceList@ since this avoids any intermediate data</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- structures.</span><span>
</span><span id="line-228"></span><span class="hs-comment">--</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-230"></span><span id="local-6989586621679138733"><span id="local-6989586621679138734"><span id="local-6989586621679138735"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#enumFromToC"><span class="hs-identifier hs-type">enumFromToC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138735"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Enum</span></span><span> </span><span class="annot"><a href="#local-6989586621679138734"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679138734"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138734"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138734"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138733"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138734"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138735"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-231"></span><span id="enumFromToC"><span class="annot"><span class="annottext">enumFromToC :: a -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#enumFromToC"><span class="hs-identifier hs-var hs-var">enumFromToC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i.
(Monad m, Enum a, Ord a) =&gt;
a -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#enumFromTo"><span class="hs-identifier hs-var">CC.enumFromTo</span></a></span><span>
</span><span id="line-232"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#enumFromToC"><span class="hs-pragma hs-type">enumFromToC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-comment">-- | Produces an infinite stream of repeated applications of f to x.</span><span>
</span><span id="line-235"></span><span class="hs-comment">--</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-237"></span><span id="local-6989586621679138729"><span id="local-6989586621679138730"><span id="local-6989586621679138731"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterateC"><span class="hs-identifier hs-type">iterateC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138731"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138730"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138730"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138730"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138729"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138730"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138731"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-238"></span><span id="iterateC"><span class="annot"><span class="annottext">iterateC :: (a -&gt; a) -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#iterateC"><span class="hs-identifier hs-var hs-var">iterateC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i.
Monad m =&gt;
(a -&gt; a) -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#iterate"><span class="hs-identifier hs-var">CC.iterate</span></a></span><span>
</span><span id="line-239"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterateC"><span class="hs-pragma hs-type">iterateC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="hs-comment">-- | Produce an infinite stream consisting entirely of the given value.</span><span>
</span><span id="line-242"></span><span class="hs-comment">--</span><span>
</span><span id="line-243"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-244"></span><span id="local-6989586621679138725"><span id="local-6989586621679138726"><span id="local-6989586621679138727"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatC"><span class="hs-identifier hs-type">repeatC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138727"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138726"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138725"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138726"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138727"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-245"></span><span id="repeatC"><span class="annot"><span class="annottext">repeatC :: a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#repeatC"><span class="hs-identifier hs-var hs-var">repeatC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i. Monad m =&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#repeat"><span class="hs-identifier hs-var">CC.repeat</span></a></span><span>
</span><span id="line-246"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatC"><span class="hs-pragma hs-type">repeatC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span class="hs-comment">-- | Produce a finite stream consisting of n copies of the given value.</span><span>
</span><span id="line-249"></span><span class="hs-comment">--</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-251"></span><span id="local-6989586621679138721"><span id="local-6989586621679138722"><span id="local-6989586621679138723"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateC"><span class="hs-identifier hs-type">replicateC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138723"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-252"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-253"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138722"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-254"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138721"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138722"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138723"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-255"></span><span id="replicateC"><span class="annot"><span class="annottext">replicateC :: Int -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#replicateC"><span class="hs-identifier hs-var hs-var">replicateC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i. Monad m =&gt; Int -&gt; a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#replicate"><span class="hs-identifier hs-var">CC.replicate</span></a></span><span>
</span><span id="line-256"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateC"><span class="hs-pragma hs-type">replicateC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-257"></span><span>
</span><span id="line-258"></span><span class="hs-comment">-- | Repeatedly run the given action and yield all values it produces.</span><span>
</span><span id="line-259"></span><span class="hs-comment">--</span><span>
</span><span id="line-260"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-261"></span><span id="local-6989586621679138717"><span id="local-6989586621679138718"><span id="local-6989586621679138719"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatMC"><span class="hs-identifier hs-type">repeatMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138719"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-262"></span><span>        </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138719"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138718"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-263"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138717"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138718"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138719"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-264"></span><span id="repeatMC"><span class="annot"><span class="annottext">repeatMC :: m a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#repeatMC"><span class="hs-identifier hs-var hs-var">repeatMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i. Monad m =&gt; m a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#repeatM"><span class="hs-identifier hs-var">CC.repeatM</span></a></span><span>
</span><span id="line-265"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatMC"><span class="hs-pragma hs-type">repeatMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-comment">-- | Repeatedly run the given action and yield all values it produces, until</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- the provided predicate returns @False@.</span><span>
</span><span id="line-269"></span><span class="hs-comment">--</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-271"></span><span id="local-6989586621679138713"><span id="local-6989586621679138714"><span id="local-6989586621679138715"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatWhileMC"><span class="hs-identifier hs-type">repeatWhileMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138715"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-272"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138715"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138714"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-273"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138714"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-274"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138713"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138714"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138715"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-275"></span><span id="repeatWhileMC"><span class="annot"><span class="annottext">repeatWhileMC :: m a -&gt; (a -&gt; Bool) -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#repeatWhileMC"><span class="hs-identifier hs-var hs-var">repeatWhileMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; Bool) -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i.
Monad m =&gt;
m a -&gt; (a -&gt; Bool) -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#repeatWhileM"><span class="hs-identifier hs-var">CC.repeatWhileM</span></a></span><span>
</span><span id="line-276"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#repeatWhileMC"><span class="hs-pragma hs-type">repeatWhileMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="hs-comment">-- | Perform the given action n times, yielding each result.</span><span>
</span><span id="line-279"></span><span class="hs-comment">--</span><span>
</span><span id="line-280"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-281"></span><span id="local-6989586621679138709"><span id="local-6989586621679138710"><span id="local-6989586621679138711"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateMC"><span class="hs-identifier hs-type">replicateMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138711"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-282"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-283"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138711"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138710"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-284"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138709"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138710"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138711"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-285"></span><span id="replicateMC"><span class="annot"><span class="annottext">replicateMC :: Int -&gt; m a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#replicateMC"><span class="hs-identifier hs-var hs-var">replicateMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; m a -&gt; ConduitT i a m ()
forall (m :: * -&gt; *) a i.
Monad m =&gt;
Int -&gt; m a -&gt; ConduitT i a m ()
</span><a href="Data.Conduit.Combinators.html#replicateM"><span class="hs-identifier hs-var">CC.replicateM</span></a></span><span>
</span><span id="line-286"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#replicateMC"><span class="hs-pragma hs-type">replicateMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-287"></span><span>
</span><span id="line-288"></span><span class="hs-comment">-- | @sourceHandle@ applied to @stdin@.</span><span>
</span><span id="line-289"></span><span class="hs-comment">--</span><span>
</span><span id="line-290"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-291"></span><span id="local-6989586621679138706"><span id="local-6989586621679138707"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdinC"><span class="hs-identifier hs-type">stdinC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679138707"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138706"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span> </span><span class="annot"><a href="#local-6989586621679138707"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-292"></span><span id="stdinC"><span class="annot"><span class="annottext">stdinC :: ConduitT i ByteString m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#stdinC"><span class="hs-identifier hs-var hs-var">stdinC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT i ByteString m ()
forall (m :: * -&gt; *) i. MonadIO m =&gt; ConduitT i ByteString m ()
</span><a href="Data.Conduit.Combinators.html#stdin"><span class="hs-identifier hs-var">CC.stdin</span></a></span><span>
</span><span id="line-293"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdinC"><span class="hs-pragma hs-type">stdinC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span class="hs-comment">-- | Ignore a certain number of values in the stream.</span><span>
</span><span id="line-296"></span><span class="hs-comment">--</span><span>
</span><span id="line-297"></span><span class="hs-comment">-- Note: since this function doesn't produce anything, you probably want to</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- use it with ('&gt;&gt;') instead of directly plugging it into a pipeline:</span><span>
</span><span id="line-299"></span><span class="hs-comment">--</span><span>
</span><span id="line-300"></span><span class="hs-comment">-- &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| dropC 2 .| sinkList</span><span>
</span><span id="line-301"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-302"></span><span class="hs-comment">-- &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| (dropC 2 &gt;&gt; sinkList)</span><span>
</span><span id="line-303"></span><span class="hs-comment">-- [3,4,5]</span><span>
</span><span id="line-304"></span><span class="hs-comment">--</span><span>
</span><span id="line-305"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-306"></span><span id="local-6989586621679138702"><span id="local-6989586621679138703"><span id="local-6989586621679138704"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropC"><span class="hs-identifier hs-type">dropC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138704"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-307"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-308"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138703"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138702"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138704"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-309"></span><span id="dropC"><span class="annot"><span class="annottext">dropC :: Int -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#dropC"><span class="hs-identifier hs-var hs-var">dropC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConduitT a o m ()
forall (m :: * -&gt; *) a o. Monad m =&gt; Int -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.html#drop"><span class="hs-identifier hs-var">CC.drop</span></a></span><span>
</span><span id="line-310"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropC"><span class="hs-pragma hs-type">dropC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="hs-comment">-- | Drop a certain number of elements from a chunked stream.</span><span>
</span><span id="line-313"></span><span class="hs-comment">--</span><span>
</span><span id="line-314"></span><span class="hs-comment">-- Note: you likely want to use it with monadic composition. See the docs</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- for 'dropC'.</span><span>
</span><span id="line-316"></span><span class="hs-comment">--</span><span>
</span><span id="line-317"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-318"></span><span id="local-6989586621679138698"><span id="local-6989586621679138699"><span id="local-6989586621679138700"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropCE"><span class="hs-identifier hs-type">dropCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138700"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138699"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.Index</span></span><span> </span><span class="annot"><a href="#local-6989586621679138699"><span class="hs-identifier hs-type">seq</span></a></span><span>
</span><span id="line-320"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138699"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138698"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138700"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-321"></span><span id="dropCE"><span class="annot"><span class="annottext">dropCE :: Index seq -&gt; ConduitT seq o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#dropCE"><span class="hs-identifier hs-var hs-var">dropCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Index seq -&gt; ConduitT seq o m ()
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq) =&gt;
Index seq -&gt; ConduitT seq o m ()
</span><a href="Data.Conduit.Combinators.html#dropE"><span class="hs-identifier hs-var">CC.dropE</span></a></span><span>
</span><span id="line-322"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropCE"><span class="hs-pragma hs-type">dropCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-323"></span><span>
</span><span id="line-324"></span><span class="hs-comment">-- | Drop all values which match the given predicate.</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- Note: you likely want to use it with monadic composition. See the docs</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- for 'dropC'.</span><span>
</span><span id="line-328"></span><span class="hs-comment">--</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-330"></span><span id="local-6989586621679138694"><span id="local-6989586621679138695"><span id="local-6989586621679138696"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileC"><span class="hs-identifier hs-type">dropWhileC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138696"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-331"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138695"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-332"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138695"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138694"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138696"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-333"></span><span id="dropWhileC"><span class="annot"><span class="annottext">dropWhileC :: (a -&gt; Bool) -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileC"><span class="hs-identifier hs-var hs-var">dropWhileC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a o m ()
forall (m :: * -&gt; *) a o.
Monad m =&gt;
(a -&gt; Bool) -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.html#dropWhile"><span class="hs-identifier hs-var">CC.dropWhile</span></a></span><span>
</span><span id="line-334"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileC"><span class="hs-pragma hs-type">dropWhileC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-335"></span><span>
</span><span id="line-336"></span><span class="hs-comment">-- | Drop all elements in the chunked stream which match the given predicate.</span><span>
</span><span id="line-337"></span><span class="hs-comment">--</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- Note: you likely want to use it with monadic composition. See the docs</span><span>
</span><span id="line-339"></span><span class="hs-comment">-- for 'dropC'.</span><span>
</span><span id="line-340"></span><span class="hs-comment">--</span><span>
</span><span id="line-341"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-342"></span><span id="local-6989586621679138690"><span id="local-6989586621679138691"><span id="local-6989586621679138692"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileCE"><span class="hs-identifier hs-type">dropWhileCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138692"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138691"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-343"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138691"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-344"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138691"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138690"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138692"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-345"></span><span id="dropWhileCE"><span class="annot"><span class="annottext">dropWhileCE :: (Element seq -&gt; Bool) -&gt; ConduitT seq o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileCE"><span class="hs-identifier hs-var hs-var">dropWhileCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element seq -&gt; Bool) -&gt; ConduitT seq o m ()
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq) =&gt;
(Element seq -&gt; Bool) -&gt; ConduitT seq o m ()
</span><a href="Data.Conduit.Combinators.html#dropWhileE"><span class="hs-identifier hs-var">CC.dropWhileE</span></a></span><span>
</span><span id="line-346"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#dropWhileCE"><span class="hs-pragma hs-type">dropWhileCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-347"></span><span>
</span><span id="line-348"></span><span class="hs-comment">-- | Monoidally combine all values in the stream.</span><span>
</span><span id="line-349"></span><span class="hs-comment">--</span><span>
</span><span id="line-350"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-351"></span><span id="local-6989586621679138686"><span id="local-6989586621679138687"><span id="local-6989586621679138688"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldC"><span class="hs-identifier hs-type">foldC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138688"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138687"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138687"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138686"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138688"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138687"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-353"></span><span id="foldC"><span class="annot"><span class="annottext">foldC :: ConduitT a o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldC"><span class="hs-identifier hs-var hs-var">foldC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m a
forall (m :: * -&gt; *) a o. (Monad m, Monoid a) =&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.html#fold"><span class="hs-identifier hs-var">CC.fold</span></a></span><span>
</span><span id="line-354"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldC"><span class="hs-pragma hs-type">foldC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-355"></span><span>
</span><span id="line-356"></span><span class="hs-comment">-- | Monoidally combine all elements in the chunked stream.</span><span>
</span><span id="line-357"></span><span class="hs-comment">--</span><span>
</span><span id="line-358"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-359"></span><span id="local-6989586621679138682"><span id="local-6989586621679138683"><span id="local-6989586621679138684"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldCE"><span class="hs-identifier hs-type">foldCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138684"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138683"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138683"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138683"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138682"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138684"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138683"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-361"></span><span id="foldCE"><span class="annot"><span class="annottext">foldCE :: ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldCE"><span class="hs-identifier hs-var hs-var">foldCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m (Element mono)
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono, Monoid (Element mono)) =&gt;
ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.html#foldE"><span class="hs-identifier hs-var">CC.foldE</span></a></span><span>
</span><span id="line-362"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldCE"><span class="hs-pragma hs-type">foldCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span class="hs-comment">-- | A strict left fold.</span><span>
</span><span id="line-365"></span><span class="hs-comment">--</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-367"></span><span id="local-6989586621679138677"><span id="local-6989586621679138678"><span id="local-6989586621679138679"><span id="local-6989586621679138680"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlC"><span class="hs-identifier hs-type">foldlC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138680"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138679"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138678"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138679"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138679"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138678"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138677"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138680"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138679"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-368"></span><span id="foldlC"><span class="annot"><span class="annottext">foldlC :: (a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldlC"><span class="hs-identifier hs-var hs-var">foldlC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b o m a
forall (m :: * -&gt; *) a b o.
Monad m =&gt;
(a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b o m a
</span><a href="Data.Conduit.Combinators.html#foldl"><span class="hs-identifier hs-var">CC.foldl</span></a></span><span>
</span><span id="line-369"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlC"><span class="hs-pragma hs-type">foldlC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span class="hs-comment">-- | A strict left fold on a chunked stream.</span><span>
</span><span id="line-372"></span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-374"></span><span id="local-6989586621679138672"><span id="local-6989586621679138673"><span id="local-6989586621679138674"><span id="local-6989586621679138675"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlCE"><span class="hs-identifier hs-type">foldlCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138675"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138674"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-375"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138673"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138674"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138673"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-376"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138673"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-377"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138674"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138672"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138675"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138673"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-378"></span><span id="foldlCE"><span class="annot"><span class="annottext">foldlCE :: (a -&gt; Element mono -&gt; a) -&gt; a -&gt; ConduitT mono o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldlCE"><span class="hs-identifier hs-var hs-var">foldlCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Element mono -&gt; a) -&gt; a -&gt; ConduitT mono o m a
forall (m :: * -&gt; *) mono a o.
(Monad m, MonoFoldable mono) =&gt;
(a -&gt; Element mono -&gt; a) -&gt; a -&gt; ConduitT mono o m a
</span><a href="Data.Conduit.Combinators.html#foldlE"><span class="hs-identifier hs-var">CC.foldlE</span></a></span><span>
</span><span id="line-379"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldlCE"><span class="hs-pragma hs-type">foldlCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-380"></span><span>
</span><span id="line-381"></span><span class="hs-comment">-- | Apply the provided mapping function and monoidal combine all values.</span><span>
</span><span id="line-382"></span><span class="hs-comment">--</span><span>
</span><span id="line-383"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-384"></span><span id="local-6989586621679138667"><span id="local-6989586621679138668"><span id="local-6989586621679138669"><span id="local-6989586621679138670"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapC"><span class="hs-identifier hs-type">foldMapC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138670"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138669"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-385"></span><span>        </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138668"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138669"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-386"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138668"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138667"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138670"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138669"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-387"></span><span id="foldMapC"><span class="annot"><span class="annottext">foldMapC :: (a -&gt; b) -&gt; ConduitT a o m b
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMapC"><span class="hs-identifier hs-var hs-var">foldMapC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; ConduitT a o m b
forall (m :: * -&gt; *) b a o.
(Monad m, Monoid b) =&gt;
(a -&gt; b) -&gt; ConduitT a o m b
</span><a href="Data.Conduit.Combinators.html#foldMap"><span class="hs-identifier hs-var">CC.foldMap</span></a></span><span>
</span><span id="line-388"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapC"><span class="hs-pragma hs-type">foldMapC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span class="hs-comment">-- | Apply the provided mapping function and monoidal combine all elements of the chunked stream.</span><span>
</span><span id="line-391"></span><span class="hs-comment">--</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-393"></span><span id="local-6989586621679138662"><span id="local-6989586621679138663"><span id="local-6989586621679138664"><span id="local-6989586621679138665"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapCE"><span class="hs-identifier hs-type">foldMapCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138665"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138664"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138663"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-394"></span><span>         </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138664"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138663"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-395"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138664"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138662"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138665"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138663"><span class="hs-identifier hs-type">w</span></a></span></span></span></span></span><span>
</span><span id="line-396"></span><span id="foldMapCE"><span class="annot"><span class="annottext">foldMapCE :: (Element mono -&gt; w) -&gt; ConduitT mono o m w
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMapCE"><span class="hs-identifier hs-var hs-var">foldMapCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; w) -&gt; ConduitT mono o m w
forall (m :: * -&gt; *) mono w o.
(Monad m, MonoFoldable mono, Monoid w) =&gt;
(Element mono -&gt; w) -&gt; ConduitT mono o m w
</span><a href="Data.Conduit.Combinators.html#foldMapE"><span class="hs-identifier hs-var">CC.foldMapE</span></a></span><span>
</span><span id="line-397"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapCE"><span class="hs-pragma hs-type">foldMapCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-398"></span><span>
</span><span id="line-399"></span><span class="hs-comment">-- | Check that all values in the stream return True.</span><span>
</span><span id="line-400"></span><span class="hs-comment">--</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- Subject to shortcut logic: at the first False, consumption of the stream</span><span>
</span><span id="line-402"></span><span class="hs-comment">-- will stop.</span><span>
</span><span id="line-403"></span><span class="hs-comment">--</span><span>
</span><span id="line-404"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-405"></span><span id="local-6989586621679138658"><span id="local-6989586621679138659"><span id="local-6989586621679138660"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allC"><span class="hs-identifier hs-type">allC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138660"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-406"></span><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138659"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-407"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138659"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138658"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138660"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-408"></span><span id="allC"><span class="annot"><span class="annottext">allC :: (a -&gt; Bool) -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#allC"><span class="hs-identifier hs-var hs-var">allC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a o m Bool
forall (m :: * -&gt; *) a o.
Monad m =&gt;
(a -&gt; Bool) -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.html#all"><span class="hs-identifier hs-var">CC.all</span></a></span><span>
</span><span id="line-409"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allC"><span class="hs-pragma hs-type">allC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="hs-comment">-- | Check that all elements in the chunked stream return True.</span><span>
</span><span id="line-412"></span><span class="hs-comment">--</span><span>
</span><span id="line-413"></span><span class="hs-comment">-- Subject to shortcut logic: at the first False, consumption of the stream</span><span>
</span><span id="line-414"></span><span class="hs-comment">-- will stop.</span><span>
</span><span id="line-415"></span><span class="hs-comment">--</span><span>
</span><span id="line-416"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-417"></span><span id="local-6989586621679138654"><span id="local-6989586621679138655"><span id="local-6989586621679138656"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allCE"><span class="hs-identifier hs-type">allCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138656"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138655"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-418"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138655"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-419"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138655"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138654"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138656"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-420"></span><span id="allCE"><span class="annot"><span class="annottext">allCE :: (Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#allCE"><span class="hs-identifier hs-var hs-var">allCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono) =&gt;
(Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.html#allE"><span class="hs-identifier hs-var">CC.allE</span></a></span><span>
</span><span id="line-421"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#allCE"><span class="hs-pragma hs-type">allCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-422"></span><span>
</span><span id="line-423"></span><span class="hs-comment">-- | Check that at least one value in the stream returns True.</span><span>
</span><span id="line-424"></span><span class="hs-comment">--</span><span>
</span><span id="line-425"></span><span class="hs-comment">-- Subject to shortcut logic: at the first True, consumption of the stream</span><span>
</span><span id="line-426"></span><span class="hs-comment">-- will stop.</span><span>
</span><span id="line-427"></span><span class="hs-comment">--</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-429"></span><span id="local-6989586621679138650"><span id="local-6989586621679138651"><span id="local-6989586621679138652"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyC"><span class="hs-identifier hs-type">anyC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138652"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-430"></span><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138651"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-431"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138651"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138650"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138652"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-432"></span><span id="anyC"><span class="annot"><span class="annottext">anyC :: (a -&gt; Bool) -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#anyC"><span class="hs-identifier hs-var hs-var">anyC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a o m Bool
forall (m :: * -&gt; *) a o.
Monad m =&gt;
(a -&gt; Bool) -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.html#any"><span class="hs-identifier hs-var">CC.any</span></a></span><span>
</span><span id="line-433"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyC"><span class="hs-pragma hs-type">anyC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-434"></span><span>
</span><span id="line-435"></span><span class="hs-comment">-- | Check that at least one element in the chunked stream returns True.</span><span>
</span><span id="line-436"></span><span class="hs-comment">--</span><span>
</span><span id="line-437"></span><span class="hs-comment">-- Subject to shortcut logic: at the first True, consumption of the stream</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- will stop.</span><span>
</span><span id="line-439"></span><span class="hs-comment">--</span><span>
</span><span id="line-440"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-441"></span><span id="local-6989586621679138646"><span id="local-6989586621679138647"><span id="local-6989586621679138648"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyCE"><span class="hs-identifier hs-type">anyCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138648"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138647"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-442"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138647"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-443"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138647"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138646"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138648"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-444"></span><span id="anyCE"><span class="annot"><span class="annottext">anyCE :: (Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#anyCE"><span class="hs-identifier hs-var hs-var">anyCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono) =&gt;
(Element mono -&gt; Bool) -&gt; ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.html#anyE"><span class="hs-identifier hs-var">CC.anyE</span></a></span><span>
</span><span id="line-445"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#anyCE"><span class="hs-pragma hs-type">anyCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-446"></span><span>
</span><span id="line-447"></span><span class="hs-comment">-- | Are all values in the stream True?</span><span>
</span><span id="line-448"></span><span class="hs-comment">--</span><span>
</span><span id="line-449"></span><span class="hs-comment">-- Consumption stops once the first False is encountered.</span><span>
</span><span id="line-450"></span><span class="hs-comment">--</span><span>
</span><span id="line-451"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-452"></span><span id="local-6989586621679138643"><span id="local-6989586621679138644"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andC"><span class="hs-identifier hs-type">andC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138644"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><a href="#local-6989586621679138643"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138644"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-453"></span><span id="andC"><span class="annot"><span class="annottext">andC :: ConduitT Bool o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#andC"><span class="hs-identifier hs-var hs-var">andC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT Bool o m Bool
forall (m :: * -&gt; *) o. Monad m =&gt; ConduitT Bool o m Bool
</span><a href="Data.Conduit.Combinators.html#and"><span class="hs-identifier hs-var">CC.and</span></a></span><span>
</span><span id="line-454"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andC"><span class="hs-pragma hs-type">andC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-455"></span><span>
</span><span id="line-456"></span><span class="hs-comment">-- | Are all elements in the chunked stream True?</span><span>
</span><span id="line-457"></span><span class="hs-comment">--</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- Consumption stops once the first False is encountered.</span><span>
</span><span id="line-459"></span><span class="hs-comment">--</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-461"></span><span id="local-6989586621679138639"><span id="local-6989586621679138640"><span id="local-6989586621679138641"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andCE"><span class="hs-identifier hs-type">andCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138641"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138640"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138640"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-462"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138640"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138639"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138641"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-463"></span><span id="andCE"><span class="annot"><span class="annottext">andCE :: ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#andCE"><span class="hs-identifier hs-var hs-var">andCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m Bool
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono, Element mono ~ Bool) =&gt;
ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.html#andE"><span class="hs-identifier hs-var">CC.andE</span></a></span><span>
</span><span id="line-464"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#andCE"><span class="hs-pragma hs-type">andCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-465"></span><span>
</span><span id="line-466"></span><span class="hs-comment">-- | Are any values in the stream True?</span><span>
</span><span id="line-467"></span><span class="hs-comment">--</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- Consumption stops once the first True is encountered.</span><span>
</span><span id="line-469"></span><span class="hs-comment">--</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-471"></span><span id="local-6989586621679138636"><span id="local-6989586621679138637"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orC"><span class="hs-identifier hs-type">orC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138637"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><a href="#local-6989586621679138636"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138637"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-472"></span><span id="orC"><span class="annot"><span class="annottext">orC :: ConduitT Bool o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#orC"><span class="hs-identifier hs-var hs-var">orC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT Bool o m Bool
forall (m :: * -&gt; *) o. Monad m =&gt; ConduitT Bool o m Bool
</span><a href="Data.Conduit.Combinators.html#or"><span class="hs-identifier hs-var">CC.or</span></a></span><span>
</span><span id="line-473"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orC"><span class="hs-pragma hs-type">orC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-474"></span><span>
</span><span id="line-475"></span><span class="hs-comment">-- | Are any elements in the chunked stream True?</span><span>
</span><span id="line-476"></span><span class="hs-comment">--</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- Consumption stops once the first True is encountered.</span><span>
</span><span id="line-478"></span><span class="hs-comment">--</span><span>
</span><span id="line-479"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-480"></span><span id="local-6989586621679138632"><span id="local-6989586621679138633"><span id="local-6989586621679138634"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orCE"><span class="hs-identifier hs-type">orCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138634"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138633"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138633"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-481"></span><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138633"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138632"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138634"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-482"></span><span id="orCE"><span class="annot"><span class="annottext">orCE :: ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#orCE"><span class="hs-identifier hs-var hs-var">orCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m Bool
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono, Element mono ~ Bool) =&gt;
ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.html#orE"><span class="hs-identifier hs-var">CC.orE</span></a></span><span>
</span><span id="line-483"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#orCE"><span class="hs-pragma hs-type">orCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-484"></span><span>
</span><span id="line-485"></span><span class="hs-comment">-- | 'Alternative'ly combine all values in the stream.</span><span>
</span><span id="line-486"></span><span class="hs-comment">--</span><span>
</span><span id="line-487"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-488"></span><span id="local-6989586621679138627"><span id="local-6989586621679138628"><span id="local-6989586621679138629"><span id="local-6989586621679138630"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#asumC"><span class="hs-identifier hs-type">asumC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138630"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679138629"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138629"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138628"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138627"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138630"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138629"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138628"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-489"></span><span id="asumC"><span class="annot"><span class="annottext">asumC :: ConduitT (f a) o m (f a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#asumC"><span class="hs-identifier hs-var hs-var">asumC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT (f a) o m (f a)
forall (m :: * -&gt; *) (f :: * -&gt; *) a o.
(Monad m, Alternative f) =&gt;
ConduitT (f a) o m (f a)
</span><a href="Data.Conduit.Combinators.html#asum"><span class="hs-identifier hs-var">CC.asum</span></a></span><span>
</span><span id="line-490"></span><span>
</span><span id="line-491"></span><span class="hs-comment">-- | Are any values in the stream equal to the given value?</span><span>
</span><span id="line-492"></span><span class="hs-comment">--</span><span>
</span><span id="line-493"></span><span class="hs-comment">-- Stops consuming as soon as a match is found.</span><span>
</span><span id="line-494"></span><span class="hs-comment">--</span><span>
</span><span id="line-495"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-496"></span><span id="local-6989586621679138623"><span id="local-6989586621679138624"><span id="local-6989586621679138625"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemC"><span class="hs-identifier hs-type">elemC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138625"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679138624"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138624"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138624"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138623"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138625"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-497"></span><span id="elemC"><span class="annot"><span class="annottext">elemC :: a -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#elemC"><span class="hs-identifier hs-var hs-var">elemC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT a o m Bool
forall (m :: * -&gt; *) a o.
(Monad m, Eq a) =&gt;
a -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.html#elem"><span class="hs-identifier hs-var">CC.elem</span></a></span><span>
</span><span id="line-498"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemC"><span class="hs-pragma hs-type">elemC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-499"></span><span>
</span><span id="line-500"></span><span class="hs-comment">-- | Are any elements in the chunked stream equal to the given element?</span><span>
</span><span id="line-501"></span><span class="hs-comment">--</span><span>
</span><span id="line-502"></span><span class="hs-comment">-- Stops consuming as soon as a match is found.</span><span>
</span><span id="line-503"></span><span class="hs-comment">--</span><span>
</span><span id="line-504"></span><span class="hs-comment">-- @since 1.3.0</span><span class="hs-cpp">
#if MIN_VERSION_mono_traversable(1,0,0)
</span><span id="local-6989586621679138619"><span id="local-6989586621679138620"><span id="local-6989586621679138621"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemCE"><span class="hs-identifier hs-type">elemCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138621"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138620"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138620"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">elemCE</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Seq.EqSequence</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138620"><span class="hs-identifier hs-type">seq</span></a></span><span>
</span><span id="line-511"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138620"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138619"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138621"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-512"></span><span id="elemCE"><span class="annot"><span class="annottext">elemCE :: Element seq -&gt; ConduitT seq o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#elemCE"><span class="hs-identifier hs-var hs-var">elemCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Element seq -&gt; ConduitT seq o m Bool
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq, Eq (Element seq)) =&gt;
Element seq -&gt; ConduitT seq o m Bool
</span><a href="Data.Conduit.Combinators.html#elemE"><span class="hs-identifier hs-var">CC.elemE</span></a></span><span>
</span><span id="line-513"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#elemCE"><span class="hs-pragma hs-type">elemCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-514"></span><span>
</span><span id="line-515"></span><span class="hs-comment">-- | Are no values in the stream equal to the given value?</span><span>
</span><span id="line-516"></span><span class="hs-comment">--</span><span>
</span><span id="line-517"></span><span class="hs-comment">-- Stops consuming as soon as a match is found.</span><span>
</span><span id="line-518"></span><span class="hs-comment">--</span><span>
</span><span id="line-519"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-520"></span><span id="local-6989586621679138615"><span id="local-6989586621679138616"><span id="local-6989586621679138617"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemC"><span class="hs-identifier hs-type">notElemC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138617"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679138616"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138616"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138616"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138615"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138617"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-521"></span><span id="notElemC"><span class="annot"><span class="annottext">notElemC :: a -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#notElemC"><span class="hs-identifier hs-var hs-var">notElemC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT a o m Bool
forall (m :: * -&gt; *) a o.
(Monad m, Eq a) =&gt;
a -&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.html#notElem"><span class="hs-identifier hs-var">CC.notElem</span></a></span><span>
</span><span id="line-522"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemC"><span class="hs-pragma hs-type">notElemC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span class="hs-comment">-- | Are no elements in the chunked stream equal to the given element?</span><span>
</span><span id="line-525"></span><span class="hs-comment">--</span><span>
</span><span id="line-526"></span><span class="hs-comment">-- Stops consuming as soon as a match is found.</span><span>
</span><span id="line-527"></span><span class="hs-comment">--</span><span>
</span><span id="line-528"></span><span class="hs-comment">-- @since 1.3.0</span><span class="hs-cpp">
#if MIN_VERSION_mono_traversable(1,0,0)
</span><span id="local-6989586621679138611"><span id="local-6989586621679138612"><span id="local-6989586621679138613"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemCE"><span class="hs-identifier hs-type">notElemCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138613"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138612"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138612"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">notElemCE</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Seq.EqSequence</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>         </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138612"><span class="hs-identifier hs-type">seq</span></a></span><span>
</span><span id="line-535"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138612"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138611"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138613"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-536"></span><span id="notElemCE"><span class="annot"><span class="annottext">notElemCE :: Element seq -&gt; ConduitT seq o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#notElemCE"><span class="hs-identifier hs-var hs-var">notElemCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Element seq -&gt; ConduitT seq o m Bool
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq, Eq (Element seq)) =&gt;
Element seq -&gt; ConduitT seq o m Bool
</span><a href="Data.Conduit.Combinators.html#notElemE"><span class="hs-identifier hs-var">CC.notElemE</span></a></span><span>
</span><span id="line-537"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#notElemCE"><span class="hs-pragma hs-type">notElemCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-538"></span><span>
</span><span id="line-539"></span><span class="hs-comment">-- | Take a single value from the stream, if available.</span><span>
</span><span id="line-540"></span><span class="hs-comment">--</span><span>
</span><span id="line-541"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-542"></span><span id="local-6989586621679138607"><span id="local-6989586621679138608"><span id="local-6989586621679138609"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headC"><span class="hs-identifier hs-type">headC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138609"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138608"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138607"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138609"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138608"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-543"></span><span id="headC"><span class="annot"><span class="annottext">headC :: ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#headC"><span class="hs-identifier hs-var hs-var">headC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o. Monad m =&gt; ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#head"><span class="hs-identifier hs-var">CC.head</span></a></span><span>
</span><span id="line-544"></span><span>
</span><span id="line-545"></span><span class="hs-comment">-- | Same as 'headC', but returns a default value if none are available from the stream.</span><span>
</span><span id="line-546"></span><span class="hs-comment">--</span><span>
</span><span id="line-547"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-548"></span><span id="local-6989586621679138603"><span id="local-6989586621679138604"><span id="local-6989586621679138605"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headDefC"><span class="hs-identifier hs-type">headDefC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138605"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138604"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138604"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138603"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138605"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138604"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-549"></span><span id="headDefC"><span class="annot"><span class="annottext">headDefC :: a -&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#headDefC"><span class="hs-identifier hs-var hs-var">headDefC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT a o m a
forall (m :: * -&gt; *) a o. Monad m =&gt; a -&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.html#headDef"><span class="hs-identifier hs-var">CC.headDef</span></a></span><span>
</span><span id="line-550"></span><span>
</span><span id="line-551"></span><span class="hs-comment">-- | Get the next element in the chunked stream.</span><span>
</span><span id="line-552"></span><span class="hs-comment">--</span><span>
</span><span id="line-553"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-554"></span><span id="local-6989586621679138599"><span id="local-6989586621679138600"><span id="local-6989586621679138601"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headCE"><span class="hs-identifier hs-type">headCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138601"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138600"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138600"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138599"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138601"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138600"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-555"></span><span id="headCE"><span class="annot"><span class="annottext">headCE :: ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.Unqualified.html#headCE"><span class="hs-identifier hs-var hs-var">headCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m (Maybe (Element seq))
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq) =&gt;
ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.html#headE"><span class="hs-identifier hs-var">CC.headE</span></a></span><span>
</span><span id="line-556"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#headCE"><span class="hs-pragma hs-type">headCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-557"></span><span>
</span><span id="line-558"></span><span class="hs-comment">-- | View the next value in the stream without consuming it.</span><span>
</span><span id="line-559"></span><span class="hs-comment">--</span><span>
</span><span id="line-560"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-561"></span><span id="local-6989586621679138595"><span id="local-6989586621679138596"><span id="local-6989586621679138597"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekC"><span class="hs-identifier hs-type">peekC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138597"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138596"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138595"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138597"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138596"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-562"></span><span id="peekC"><span class="annot"><span class="annottext">peekC :: ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#peekC"><span class="hs-identifier hs-var hs-var">peekC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o. Monad m =&gt; ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#peek"><span class="hs-identifier hs-var">CC.peek</span></a></span><span>
</span><span id="line-563"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekC"><span class="hs-pragma hs-type">peekC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span class="hs-comment">-- | View the next element in the chunked stream without consuming it.</span><span>
</span><span id="line-566"></span><span class="hs-comment">--</span><span>
</span><span id="line-567"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-568"></span><span id="local-6989586621679138591"><span id="local-6989586621679138592"><span id="local-6989586621679138593"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekCE"><span class="hs-identifier hs-type">peekCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138593"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138592"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138592"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138591"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138593"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138592"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-569"></span><span id="peekCE"><span class="annot"><span class="annottext">peekCE :: ConduitT mono o m (Maybe (Element mono))
</span><a href="Data.Conduit.Combinators.Unqualified.html#peekCE"><span class="hs-identifier hs-var hs-var">peekCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m (Maybe (Element mono))
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono) =&gt;
ConduitT mono o m (Maybe (Element mono))
</span><a href="Data.Conduit.Combinators.html#peekE"><span class="hs-identifier hs-var">CC.peekE</span></a></span><span>
</span><span id="line-570"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#peekCE"><span class="hs-pragma hs-type">peekCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span class="hs-comment">-- | Retrieve the last value in the stream, if present.</span><span>
</span><span id="line-573"></span><span class="hs-comment">--</span><span>
</span><span id="line-574"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-575"></span><span id="local-6989586621679138587"><span id="local-6989586621679138588"><span id="local-6989586621679138589"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastC"><span class="hs-identifier hs-type">lastC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138589"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138588"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138587"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138589"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138588"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-576"></span><span id="lastC"><span class="annot"><span class="annottext">lastC :: ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#lastC"><span class="hs-identifier hs-var hs-var">lastC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o. Monad m =&gt; ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#last"><span class="hs-identifier hs-var">CC.last</span></a></span><span>
</span><span id="line-577"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastC"><span class="hs-pragma hs-type">lastC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-578"></span><span>
</span><span id="line-579"></span><span class="hs-comment">-- | Same as 'lastC', but returns a default value if none are available from the stream.</span><span>
</span><span id="line-580"></span><span class="hs-comment">--</span><span>
</span><span id="line-581"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-582"></span><span id="local-6989586621679138583"><span id="local-6989586621679138584"><span id="local-6989586621679138585"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastDefC"><span class="hs-identifier hs-type">lastDefC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138585"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138584"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138584"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138583"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138585"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138584"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-583"></span><span id="lastDefC"><span class="annot"><span class="annottext">lastDefC :: a -&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#lastDefC"><span class="hs-identifier hs-var hs-var">lastDefC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT a o m a
forall (m :: * -&gt; *) a o. Monad m =&gt; a -&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.html#lastDef"><span class="hs-identifier hs-var">CC.lastDef</span></a></span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span class="hs-comment">-- | Retrieve the last element in the chunked stream, if present.</span><span>
</span><span id="line-586"></span><span class="hs-comment">--</span><span>
</span><span id="line-587"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-588"></span><span id="local-6989586621679138579"><span id="local-6989586621679138580"><span id="local-6989586621679138581"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastCE"><span class="hs-identifier hs-type">lastCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138581"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138580"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138580"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138579"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138581"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138580"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-589"></span><span id="lastCE"><span class="annot"><span class="annottext">lastCE :: ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.Unqualified.html#lastCE"><span class="hs-identifier hs-var hs-var">lastCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m (Maybe (Element seq))
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq) =&gt;
ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.html#lastE"><span class="hs-identifier hs-var">CC.lastE</span></a></span><span>
</span><span id="line-590"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lastCE"><span class="hs-pragma hs-type">lastCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-591"></span><span>
</span><span id="line-592"></span><span class="hs-comment">-- | Count how many values are in the stream.</span><span>
</span><span id="line-593"></span><span class="hs-comment">--</span><span>
</span><span id="line-594"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-595"></span><span id="local-6989586621679138574"><span id="local-6989586621679138575"><span id="local-6989586621679138576"><span id="local-6989586621679138577"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthC"><span class="hs-identifier hs-type">lengthC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138577"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138576"><span class="hs-identifier hs-type">len</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138575"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138574"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138577"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138576"><span class="hs-identifier hs-type">len</span></a></span></span></span></span></span><span>
</span><span id="line-596"></span><span id="lengthC"><span class="annot"><span class="annottext">lengthC :: ConduitT a o m len
</span><a href="Data.Conduit.Combinators.Unqualified.html#lengthC"><span class="hs-identifier hs-var hs-var">lengthC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m len
forall (m :: * -&gt; *) len a o.
(Monad m, Num len) =&gt;
ConduitT a o m len
</span><a href="Data.Conduit.Combinators.html#length"><span class="hs-identifier hs-var">CC.length</span></a></span><span>
</span><span id="line-597"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthC"><span class="hs-pragma hs-type">lengthC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-598"></span><span>
</span><span id="line-599"></span><span class="hs-comment">-- | Count how many elements are in the chunked stream.</span><span>
</span><span id="line-600"></span><span class="hs-comment">--</span><span>
</span><span id="line-601"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-602"></span><span id="local-6989586621679138569"><span id="local-6989586621679138570"><span id="local-6989586621679138571"><span id="local-6989586621679138572"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthCE"><span class="hs-identifier hs-type">lengthCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138572"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138571"><span class="hs-identifier hs-type">len</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138570"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138570"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138569"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138572"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138571"><span class="hs-identifier hs-type">len</span></a></span></span></span></span></span><span>
</span><span id="line-603"></span><span id="lengthCE"><span class="annot"><span class="annottext">lengthCE :: ConduitT mono o m len
</span><a href="Data.Conduit.Combinators.Unqualified.html#lengthCE"><span class="hs-identifier hs-var hs-var">lengthCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m len
forall (m :: * -&gt; *) len mono o.
(Monad m, Num len, MonoFoldable mono) =&gt;
ConduitT mono o m len
</span><a href="Data.Conduit.Combinators.html#lengthE"><span class="hs-identifier hs-var">CC.lengthE</span></a></span><span>
</span><span id="line-604"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthCE"><span class="hs-pragma hs-type">lengthCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-605"></span><span>
</span><span id="line-606"></span><span class="hs-comment">-- | Count how many values in the stream pass the given predicate.</span><span>
</span><span id="line-607"></span><span class="hs-comment">--</span><span>
</span><span id="line-608"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-609"></span><span id="local-6989586621679138564"><span id="local-6989586621679138565"><span id="local-6989586621679138566"><span id="local-6989586621679138567"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfC"><span class="hs-identifier hs-type">lengthIfC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138567"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138566"><span class="hs-identifier hs-type">len</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138565"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138565"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138564"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138567"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138566"><span class="hs-identifier hs-type">len</span></a></span></span></span></span></span><span>
</span><span id="line-610"></span><span id="lengthIfC"><span class="annot"><span class="annottext">lengthIfC :: (a -&gt; Bool) -&gt; ConduitT a o m len
</span><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfC"><span class="hs-identifier hs-var hs-var">lengthIfC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a o m len
forall (m :: * -&gt; *) len a o.
(Monad m, Num len) =&gt;
(a -&gt; Bool) -&gt; ConduitT a o m len
</span><a href="Data.Conduit.Combinators.html#lengthIf"><span class="hs-identifier hs-var">CC.lengthIf</span></a></span><span>
</span><span id="line-611"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfC"><span class="hs-pragma hs-type">lengthIfC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-612"></span><span>
</span><span id="line-613"></span><span class="hs-comment">-- | Count how many elements in the chunked stream pass the given predicate.</span><span>
</span><span id="line-614"></span><span class="hs-comment">--</span><span>
</span><span id="line-615"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-616"></span><span id="local-6989586621679138559"><span id="local-6989586621679138560"><span id="local-6989586621679138561"><span id="local-6989586621679138562"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfCE"><span class="hs-identifier hs-type">lengthIfCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138562"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138561"><span class="hs-identifier hs-type">len</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138560"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-617"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138560"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138560"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138559"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138562"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138561"><span class="hs-identifier hs-type">len</span></a></span></span></span></span></span><span>
</span><span id="line-618"></span><span id="lengthIfCE"><span class="annot"><span class="annottext">lengthIfCE :: (Element mono -&gt; Bool) -&gt; ConduitT mono o m len
</span><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfCE"><span class="hs-identifier hs-var hs-var">lengthIfCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; Bool) -&gt; ConduitT mono o m len
forall (m :: * -&gt; *) len mono o.
(Monad m, Num len, MonoFoldable mono) =&gt;
(Element mono -&gt; Bool) -&gt; ConduitT mono o m len
</span><a href="Data.Conduit.Combinators.html#lengthIfE"><span class="hs-identifier hs-var">CC.lengthIfE</span></a></span><span>
</span><span id="line-619"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lengthIfCE"><span class="hs-pragma hs-type">lengthIfCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-620"></span><span>
</span><span id="line-621"></span><span class="hs-comment">-- | Get the largest value in the stream, if present.</span><span>
</span><span id="line-622"></span><span class="hs-comment">--</span><span>
</span><span id="line-623"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-624"></span><span id="local-6989586621679138555"><span id="local-6989586621679138556"><span id="local-6989586621679138557"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumC"><span class="hs-identifier hs-type">maximumC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138557"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679138556"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138556"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138555"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138557"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138556"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-625"></span><span id="maximumC"><span class="annot"><span class="annottext">maximumC :: ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#maximumC"><span class="hs-identifier hs-var hs-var">maximumC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o.
(Monad m, Ord a) =&gt;
ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#maximum"><span class="hs-identifier hs-var">CC.maximum</span></a></span><span>
</span><span id="line-626"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumC"><span class="hs-pragma hs-type">maximumC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-627"></span><span>
</span><span id="line-628"></span><span class="hs-comment">-- | Get the largest element in the chunked stream, if present.</span><span>
</span><span id="line-629"></span><span class="hs-comment">--</span><span>
</span><span id="line-630"></span><span class="hs-comment">-- @since 1.3.0</span><span class="hs-cpp">
#if MIN_VERSION_mono_traversable(1,0,0)
</span><span id="local-6989586621679138551"><span id="local-6989586621679138552"><span id="local-6989586621679138553"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumCE"><span class="hs-identifier hs-type">maximumCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138553"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138552"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138552"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138552"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138551"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138553"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138552"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">maximumCE</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Seq.OrdSequence</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">ConduitT</span><span> </span><span class="hs-identifier">seq</span><span> </span><span class="hs-identifier">o</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Element</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span id="maximumCE"><span class="annot"><span class="annottext">maximumCE :: ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.Unqualified.html#maximumCE"><span class="hs-identifier hs-var hs-var">maximumCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m (Maybe (Element seq))
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq, Ord (Element seq)) =&gt;
ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.html#maximumE"><span class="hs-identifier hs-var">CC.maximumE</span></a></span><span>
</span><span id="line-637"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#maximumCE"><span class="hs-pragma hs-type">maximumCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-638"></span><span>
</span><span id="line-639"></span><span class="hs-comment">-- | Get the smallest value in the stream, if present.</span><span>
</span><span id="line-640"></span><span class="hs-comment">--</span><span>
</span><span id="line-641"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-642"></span><span id="local-6989586621679138547"><span id="local-6989586621679138548"><span id="local-6989586621679138549"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumC"><span class="hs-identifier hs-type">minimumC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138549"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679138548"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138548"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138547"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138549"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138548"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-643"></span><span id="minimumC"><span class="annot"><span class="annottext">minimumC :: ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#minimumC"><span class="hs-identifier hs-var hs-var">minimumC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o.
(Monad m, Ord a) =&gt;
ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#minimum"><span class="hs-identifier hs-var">CC.minimum</span></a></span><span>
</span><span id="line-644"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumC"><span class="hs-pragma hs-type">minimumC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-645"></span><span>
</span><span id="line-646"></span><span class="hs-comment">-- | Get the smallest element in the chunked stream, if present.</span><span>
</span><span id="line-647"></span><span class="hs-comment">--</span><span>
</span><span id="line-648"></span><span class="hs-comment">-- @since 1.3.0</span><span class="hs-cpp">
#if MIN_VERSION_mono_traversable(1,0,0)
</span><span id="local-6989586621679138543"><span id="local-6989586621679138544"><span id="local-6989586621679138545"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumCE"><span class="hs-identifier hs-type">minimumCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138545"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138544"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138544"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138544"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138543"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138545"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138544"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">minimumCE</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Seq.OrdSequence</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">ConduitT</span><span> </span><span class="hs-identifier">seq</span><span> </span><span class="hs-identifier">o</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Element</span><span> </span><span class="hs-identifier">seq</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span id="minimumCE"><span class="annot"><span class="annottext">minimumCE :: ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.Unqualified.html#minimumCE"><span class="hs-identifier hs-var hs-var">minimumCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m (Maybe (Element seq))
forall (m :: * -&gt; *) seq o.
(Monad m, IsSequence seq, Ord (Element seq)) =&gt;
ConduitT seq o m (Maybe (Element seq))
</span><a href="Data.Conduit.Combinators.html#minimumE"><span class="hs-identifier hs-var">CC.minimumE</span></a></span><span>
</span><span id="line-655"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#minimumCE"><span class="hs-pragma hs-type">minimumCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-656"></span><span>
</span><span id="line-657"></span><span class="hs-comment">-- | True if there are no values in the stream.</span><span>
</span><span id="line-658"></span><span class="hs-comment">--</span><span>
</span><span id="line-659"></span><span class="hs-comment">-- This function does not modify the stream.</span><span>
</span><span id="line-660"></span><span class="hs-comment">--</span><span>
</span><span id="line-661"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-662"></span><span id="local-6989586621679138539"><span id="local-6989586621679138540"><span id="local-6989586621679138541"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullC"><span class="hs-identifier hs-type">nullC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138541"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138540"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138539"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138541"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-663"></span><span id="nullC"><span class="annot"><span class="annottext">nullC :: ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#nullC"><span class="hs-identifier hs-var hs-var">nullC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m Bool
forall (m :: * -&gt; *) a o. Monad m =&gt; ConduitT a o m Bool
</span><a href="Data.Conduit.Combinators.html#null"><span class="hs-identifier hs-var">CC.null</span></a></span><span>
</span><span id="line-664"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullC"><span class="hs-pragma hs-type">nullC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-665"></span><span>
</span><span id="line-666"></span><span class="hs-comment">-- | True if there are no elements in the chunked stream.</span><span>
</span><span id="line-667"></span><span class="hs-comment">--</span><span>
</span><span id="line-668"></span><span class="hs-comment">-- This function may remove empty leading chunks from the stream, but otherwise</span><span>
</span><span id="line-669"></span><span class="hs-comment">-- will not modify it.</span><span>
</span><span id="line-670"></span><span class="hs-comment">--</span><span>
</span><span id="line-671"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-672"></span><span id="local-6989586621679138535"><span id="local-6989586621679138536"><span id="local-6989586621679138537"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullCE"><span class="hs-identifier hs-type">nullCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138537"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138536"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-673"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138536"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138535"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138537"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-674"></span><span id="nullCE"><span class="annot"><span class="annottext">nullCE :: ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.Unqualified.html#nullCE"><span class="hs-identifier hs-var hs-var">nullCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m Bool
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono) =&gt;
ConduitT mono o m Bool
</span><a href="Data.Conduit.Combinators.html#nullE"><span class="hs-identifier hs-var">CC.nullE</span></a></span><span>
</span><span id="line-675"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#nullCE"><span class="hs-pragma hs-type">nullCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-676"></span><span>
</span><span id="line-677"></span><span class="hs-comment">-- | Get the sum of all values in the stream.</span><span>
</span><span id="line-678"></span><span class="hs-comment">--</span><span>
</span><span id="line-679"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-680"></span><span id="local-6989586621679138531"><span id="local-6989586621679138532"><span id="local-6989586621679138533"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumC"><span class="hs-identifier hs-type">sumC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138533"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138532"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138532"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138531"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138533"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138532"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-681"></span><span id="sumC"><span class="annot"><span class="annottext">sumC :: ConduitT a o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#sumC"><span class="hs-identifier hs-var hs-var">sumC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m a
forall (m :: * -&gt; *) a o. (Monad m, Num a) =&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.html#sum"><span class="hs-identifier hs-var">CC.sum</span></a></span><span>
</span><span id="line-682"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumC"><span class="hs-pragma hs-type">sumC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span class="hs-comment">-- | Get the sum of all elements in the chunked stream.</span><span>
</span><span id="line-685"></span><span class="hs-comment">--</span><span>
</span><span id="line-686"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-687"></span><span id="local-6989586621679138527"><span id="local-6989586621679138528"><span id="local-6989586621679138529"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumCE"><span class="hs-identifier hs-type">sumCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138529"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138528"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138528"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138528"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138527"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138529"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138528"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-688"></span><span id="sumCE"><span class="annot"><span class="annottext">sumCE :: ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.Unqualified.html#sumCE"><span class="hs-identifier hs-var hs-var">sumCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m (Element mono)
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono, Num (Element mono)) =&gt;
ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.html#sumE"><span class="hs-identifier hs-var">CC.sumE</span></a></span><span>
</span><span id="line-689"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#sumCE"><span class="hs-pragma hs-type">sumCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-690"></span><span>
</span><span id="line-691"></span><span class="hs-comment">-- | Get the product of all values in the stream.</span><span>
</span><span id="line-692"></span><span class="hs-comment">--</span><span>
</span><span id="line-693"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-694"></span><span id="local-6989586621679138523"><span id="local-6989586621679138524"><span id="local-6989586621679138525"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productC"><span class="hs-identifier hs-type">productC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138525"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="annot"><a href="#local-6989586621679138524"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138524"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138523"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138525"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138524"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-695"></span><span id="productC"><span class="annot"><span class="annottext">productC :: ConduitT a o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#productC"><span class="hs-identifier hs-var hs-var">productC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m a
forall (m :: * -&gt; *) a o. (Monad m, Num a) =&gt; ConduitT a o m a
</span><a href="Data.Conduit.Combinators.html#product"><span class="hs-identifier hs-var">CC.product</span></a></span><span>
</span><span id="line-696"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productC"><span class="hs-pragma hs-type">productC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-697"></span><span>
</span><span id="line-698"></span><span class="hs-comment">-- | Get the product of all elements in the chunked stream.</span><span>
</span><span id="line-699"></span><span class="hs-comment">--</span><span>
</span><span id="line-700"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-701"></span><span id="local-6989586621679138519"><span id="local-6989586621679138520"><span id="local-6989586621679138521"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productCE"><span class="hs-identifier hs-type">productCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138521"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138520"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Num</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138520"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138520"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138519"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138521"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138520"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-702"></span><span id="productCE"><span class="annot"><span class="annottext">productCE :: ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.Unqualified.html#productCE"><span class="hs-identifier hs-var hs-var">productCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono o m (Element mono)
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono, Num (Element mono)) =&gt;
ConduitT mono o m (Element mono)
</span><a href="Data.Conduit.Combinators.html#productE"><span class="hs-identifier hs-var">CC.productE</span></a></span><span>
</span><span id="line-703"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#productCE"><span class="hs-pragma hs-type">productCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-704"></span><span>
</span><span id="line-705"></span><span class="hs-comment">-- | Find the first matching value.</span><span>
</span><span id="line-706"></span><span class="hs-comment">--</span><span>
</span><span id="line-707"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-708"></span><span id="local-6989586621679138515"><span id="local-6989586621679138516"><span id="local-6989586621679138517"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#findC"><span class="hs-identifier hs-type">findC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138517"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138516"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138516"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138515"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138517"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138516"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-709"></span><span id="findC"><span class="annot"><span class="annottext">findC :: (a -&gt; Bool) -&gt; ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.Unqualified.html#findC"><span class="hs-identifier hs-var hs-var">findC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a o m (Maybe a)
forall (m :: * -&gt; *) a o.
Monad m =&gt;
(a -&gt; Bool) -&gt; ConduitT a o m (Maybe a)
</span><a href="Data.Conduit.Combinators.html#find"><span class="hs-identifier hs-var">CC.find</span></a></span><span>
</span><span id="line-710"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#findC"><span class="hs-pragma hs-type">findC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span class="hs-comment">-- | Apply the action to all values in the stream.</span><span>
</span><span id="line-713"></span><span class="hs-comment">--</span><span>
</span><span id="line-714"></span><span class="hs-comment">-- Note: if you want to /pass/ the values instead of /consuming/ them, use</span><span>
</span><span id="line-715"></span><span class="hs-comment">-- 'iterM' instead.</span><span>
</span><span id="line-716"></span><span class="hs-comment">--</span><span>
</span><span id="line-717"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-718"></span><span id="local-6989586621679138511"><span id="local-6989586621679138512"><span id="local-6989586621679138513"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_C"><span class="hs-identifier hs-type">mapM_C</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138513"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138512"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138513"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138512"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138511"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138513"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-719"></span><span id="mapM_C"><span class="annot"><span class="annottext">mapM_C :: (a -&gt; m ()) -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapM_C"><span class="hs-identifier hs-var hs-var">mapM_C</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m ()) -&gt; ConduitT a o m ()
forall (m :: * -&gt; *) a o.
Monad m =&gt;
(a -&gt; m ()) -&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.html#mapM_"><span class="hs-identifier hs-var">CC.mapM_</span></a></span><span>
</span><span id="line-720"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_C"><span class="hs-pragma hs-type">mapM_C</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-721"></span><span>
</span><span id="line-722"></span><span class="hs-comment">-- | Apply the action to all elements in the chunked stream.</span><span>
</span><span id="line-723"></span><span class="hs-comment">--</span><span>
</span><span id="line-724"></span><span class="hs-comment">-- Note: the same caveat as with 'mapM_C' applies. If you don't want to</span><span>
</span><span id="line-725"></span><span class="hs-comment">-- consume the values, you can use 'iterM':</span><span>
</span><span id="line-726"></span><span class="hs-comment">--</span><span>
</span><span id="line-727"></span><span class="hs-comment">-- &gt; iterM (omapM_ f)</span><span>
</span><span id="line-728"></span><span class="hs-comment">--</span><span>
</span><span id="line-729"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-730"></span><span id="local-6989586621679138507"><span id="local-6989586621679138508"><span id="local-6989586621679138509"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_CE"><span class="hs-identifier hs-type">mapM_CE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138509"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138508"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138508"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138509"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138508"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138507"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138509"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-731"></span><span id="mapM_CE"><span class="annot"><span class="annottext">mapM_CE :: (Element mono -&gt; m ()) -&gt; ConduitT mono o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapM_CE"><span class="hs-identifier hs-var hs-var">mapM_CE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; m ()) -&gt; ConduitT mono o m ()
forall (m :: * -&gt; *) mono o.
(Monad m, MonoFoldable mono) =&gt;
(Element mono -&gt; m ()) -&gt; ConduitT mono o m ()
</span><a href="Data.Conduit.Combinators.html#mapM_E"><span class="hs-identifier hs-var">CC.mapM_E</span></a></span><span>
</span><span id="line-732"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapM_CE"><span class="hs-pragma hs-type">mapM_CE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-733"></span><span>
</span><span id="line-734"></span><span class="hs-comment">-- | A monadic strict left fold.</span><span>
</span><span id="line-735"></span><span class="hs-comment">--</span><span>
</span><span id="line-736"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-737"></span><span id="local-6989586621679138502"><span id="local-6989586621679138503"><span id="local-6989586621679138504"><span id="local-6989586621679138505"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMC"><span class="hs-identifier hs-type">foldMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138505"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138504"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138503"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138505"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138504"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138504"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138503"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138502"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138505"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138504"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-738"></span><span id="foldMC"><span class="annot"><span class="annottext">foldMC :: (a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMC"><span class="hs-identifier hs-var hs-var">foldMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b o m a
forall (m :: * -&gt; *) a b o.
Monad m =&gt;
(a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b o m a
</span><a href="Data.Conduit.Combinators.html#foldM"><span class="hs-identifier hs-var">CC.foldM</span></a></span><span>
</span><span id="line-739"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMC"><span class="hs-pragma hs-type">foldMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-740"></span><span>
</span><span id="line-741"></span><span class="hs-comment">-- | A monadic strict left fold on a chunked stream.</span><span>
</span><span id="line-742"></span><span class="hs-comment">--</span><span>
</span><span id="line-743"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-744"></span><span id="local-6989586621679138497"><span id="local-6989586621679138498"><span id="local-6989586621679138499"><span id="local-6989586621679138500"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMCE"><span class="hs-identifier hs-type">foldMCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138500"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138499"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-745"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138498"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138499"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138500"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138498"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-746"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138498"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-747"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138499"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138497"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138500"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138498"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-748"></span><span id="foldMCE"><span class="annot"><span class="annottext">foldMCE :: (a -&gt; Element mono -&gt; m a) -&gt; a -&gt; ConduitT mono o m a
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMCE"><span class="hs-identifier hs-var hs-var">foldMCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Element mono -&gt; m a) -&gt; a -&gt; ConduitT mono o m a
forall (m :: * -&gt; *) mono a o.
(Monad m, MonoFoldable mono) =&gt;
(a -&gt; Element mono -&gt; m a) -&gt; a -&gt; ConduitT mono o m a
</span><a href="Data.Conduit.Combinators.html#foldME"><span class="hs-identifier hs-var">CC.foldME</span></a></span><span>
</span><span id="line-749"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMCE"><span class="hs-pragma hs-type">foldMCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-750"></span><span>
</span><span id="line-751"></span><span class="hs-comment">-- | Apply the provided monadic mapping function and monoidal combine all values.</span><span>
</span><span id="line-752"></span><span class="hs-comment">--</span><span>
</span><span id="line-753"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-754"></span><span id="local-6989586621679138492"><span id="local-6989586621679138493"><span id="local-6989586621679138494"><span id="local-6989586621679138495"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMC"><span class="hs-identifier hs-type">foldMapMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138495"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138494"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138493"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138495"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138494"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138493"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138492"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138495"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138494"><span class="hs-identifier hs-type">w</span></a></span></span></span></span></span><span>
</span><span id="line-755"></span><span id="foldMapMC"><span class="annot"><span class="annottext">foldMapMC :: (a -&gt; m w) -&gt; ConduitT a o m w
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMC"><span class="hs-identifier hs-var hs-var">foldMapMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m w) -&gt; ConduitT a o m w
forall (m :: * -&gt; *) w a o.
(Monad m, Monoid w) =&gt;
(a -&gt; m w) -&gt; ConduitT a o m w
</span><a href="Data.Conduit.Combinators.html#foldMapM"><span class="hs-identifier hs-var">CC.foldMapM</span></a></span><span>
</span><span id="line-756"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMC"><span class="hs-pragma hs-type">foldMapMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-757"></span><span>
</span><span id="line-758"></span><span class="hs-comment">-- | Apply the provided monadic mapping function and monoidal combine all</span><span>
</span><span id="line-759"></span><span class="hs-comment">-- elements in the chunked stream.</span><span>
</span><span id="line-760"></span><span class="hs-comment">--</span><span>
</span><span id="line-761"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-762"></span><span id="local-6989586621679138487"><span id="local-6989586621679138488"><span id="local-6989586621679138489"><span id="local-6989586621679138490"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMCE"><span class="hs-identifier hs-type">foldMapMCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138490"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138489"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138488"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-763"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138489"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138490"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138488"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-764"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138489"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138487"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138490"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138488"><span class="hs-identifier hs-type">w</span></a></span></span></span></span></span><span>
</span><span id="line-765"></span><span id="foldMapMCE"><span class="annot"><span class="annottext">foldMapMCE :: (Element mono -&gt; m w) -&gt; ConduitT mono o m w
</span><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMCE"><span class="hs-identifier hs-var hs-var">foldMapMCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; m w) -&gt; ConduitT mono o m w
forall (m :: * -&gt; *) mono w o.
(Monad m, MonoFoldable mono, Monoid w) =&gt;
(Element mono -&gt; m w) -&gt; ConduitT mono o m w
</span><a href="Data.Conduit.Combinators.html#foldMapME"><span class="hs-identifier hs-var">CC.foldMapME</span></a></span><span>
</span><span id="line-766"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#foldMapMCE"><span class="hs-pragma hs-type">foldMapMCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span class="hs-comment">-- | Print all incoming values to stdout.</span><span>
</span><span id="line-769"></span><span class="hs-comment">--</span><span>
</span><span id="line-770"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-771"></span><span id="local-6989586621679138483"><span id="local-6989586621679138484"><span id="local-6989586621679138485"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#printC"><span class="hs-identifier hs-type">printC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="#local-6989586621679138485"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679138484"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138485"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138483"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138484"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-772"></span><span id="printC"><span class="annot"><span class="annottext">printC :: ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#printC"><span class="hs-identifier hs-var hs-var">printC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT a o m ()
forall a (m :: * -&gt; *) o. (Show a, MonadIO m) =&gt; ConduitT a o m ()
</span><a href="Data.Conduit.Combinators.html#print"><span class="hs-identifier hs-var">CC.print</span></a></span><span>
</span><span id="line-773"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#printC"><span class="hs-pragma hs-type">printC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-774"></span><span>
</span><span id="line-775"></span><span class="hs-comment">-- | @sinkHandle@ applied to @stdout@.</span><span>
</span><span id="line-776"></span><span class="hs-comment">--</span><span>
</span><span id="line-777"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-778"></span><span id="local-6989586621679138480"><span id="local-6989586621679138481"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdoutC"><span class="hs-identifier hs-type">stdoutC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679138481"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span> </span><span class="annot"><a href="#local-6989586621679138480"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138481"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-779"></span><span id="stdoutC"><span class="annot"><span class="annottext">stdoutC :: ConduitT ByteString o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#stdoutC"><span class="hs-identifier hs-var hs-var">stdoutC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT ByteString o m ()
forall (m :: * -&gt; *) o. MonadIO m =&gt; ConduitT ByteString o m ()
</span><a href="Data.Conduit.Combinators.html#stdout"><span class="hs-identifier hs-var">CC.stdout</span></a></span><span>
</span><span id="line-780"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stdoutC"><span class="hs-pragma hs-type">stdoutC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-781"></span><span>
</span><span id="line-782"></span><span class="hs-comment">-- | @sinkHandle@ applied to @stderr@.</span><span>
</span><span id="line-783"></span><span class="hs-comment">--</span><span>
</span><span id="line-784"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-785"></span><span id="local-6989586621679138477"><span id="local-6989586621679138478"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stderrC"><span class="hs-identifier hs-type">stderrC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621679138478"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span> </span><span class="annot"><a href="#local-6989586621679138477"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138478"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-786"></span><span id="stderrC"><span class="annot"><span class="annottext">stderrC :: ConduitT ByteString o m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#stderrC"><span class="hs-identifier hs-var hs-var">stderrC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT ByteString o m ()
forall (m :: * -&gt; *) o. MonadIO m =&gt; ConduitT ByteString o m ()
</span><a href="Data.Conduit.Combinators.html#stderr"><span class="hs-identifier hs-var">CC.stderr</span></a></span><span>
</span><span id="line-787"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#stderrC"><span class="hs-pragma hs-type">stderrC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-788"></span><span>
</span><span id="line-789"></span><span class="hs-comment">-- | Apply a transformation to all values in a stream.</span><span>
</span><span id="line-790"></span><span class="hs-comment">--</span><span>
</span><span id="line-791"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-792"></span><span id="local-6989586621679138473"><span id="local-6989586621679138474"><span id="local-6989586621679138475"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapC"><span class="hs-identifier hs-type">mapC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138475"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138474"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138473"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138474"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138473"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138475"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-793"></span><span id="mapC"><span class="annot"><span class="annottext">mapC :: (a -&gt; b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapC"><span class="hs-identifier hs-var hs-var">mapC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; ConduitT a b m ()
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.html#map"><span class="hs-identifier hs-var">CC.map</span></a></span><span>
</span><span id="line-794"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapC"><span class="hs-pragma hs-type">mapC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-795"></span><span>
</span><span id="line-796"></span><span class="hs-comment">-- | Apply a transformation to all elements in a chunked stream.</span><span>
</span><span id="line-797"></span><span class="hs-comment">--</span><span>
</span><span id="line-798"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-799"></span><span id="local-6989586621679138468"><span id="local-6989586621679138469"><span id="local-6989586621679138470"><span id="local-6989586621679138471"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapCE"><span class="hs-identifier hs-type">mapCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138471"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679138470"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138469"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138468"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138470"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138469"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138470"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138468"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138471"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-800"></span><span id="mapCE"><span class="annot"><span class="annottext">mapCE :: (a -&gt; b) -&gt; ConduitT (f a) (f b) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapCE"><span class="hs-identifier hs-var hs-var">mapCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; ConduitT (f a) (f b) m ()
forall (m :: * -&gt; *) (f :: * -&gt; *) a b.
(Monad m, Functor f) =&gt;
(a -&gt; b) -&gt; ConduitT (f a) (f b) m ()
</span><a href="Data.Conduit.Combinators.html#mapE"><span class="hs-identifier hs-var">CC.mapE</span></a></span><span>
</span><span id="line-801"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapCE"><span class="hs-pragma hs-type">mapCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-802"></span><span>
</span><span id="line-803"></span><span class="hs-comment">-- | Apply a monomorphic transformation to all elements in a chunked stream.</span><span>
</span><span id="line-804"></span><span class="hs-comment">--</span><span>
</span><span id="line-805"></span><span class="hs-comment">-- Unlike @mapE@, this will work on types like @ByteString@ and @Text@ which</span><span>
</span><span id="line-806"></span><span class="hs-comment">-- are @MonoFunctor@ but not @Functor@.</span><span>
</span><span id="line-807"></span><span class="hs-comment">--</span><span>
</span><span id="line-808"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-809"></span><span id="local-6989586621679138465"><span id="local-6989586621679138466"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapCE"><span class="hs-identifier hs-type">omapCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138466"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFunctor</span></span><span> </span><span class="annot"><a href="#local-6989586621679138465"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138465"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138465"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138465"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138465"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138466"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-810"></span><span id="omapCE"><span class="annot"><span class="annottext">omapCE :: (Element mono -&gt; Element mono) -&gt; ConduitT mono mono m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#omapCE"><span class="hs-identifier hs-var hs-var">omapCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; Element mono) -&gt; ConduitT mono mono m ()
forall (m :: * -&gt; *) mono.
(Monad m, MonoFunctor mono) =&gt;
(Element mono -&gt; Element mono) -&gt; ConduitT mono mono m ()
</span><a href="Data.Conduit.Combinators.html#omapE"><span class="hs-identifier hs-var">CC.omapE</span></a></span><span>
</span><span id="line-811"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapCE"><span class="hs-pragma hs-type">omapCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-812"></span><span>
</span><span id="line-813"></span><span class="hs-comment">-- | Apply the function to each value in the stream, resulting in a foldable</span><span>
</span><span id="line-814"></span><span class="hs-comment">-- value (e.g., a list). Then yield each of the individual values in that</span><span>
</span><span id="line-815"></span><span class="hs-comment">-- foldable value separately.</span><span>
</span><span id="line-816"></span><span class="hs-comment">--</span><span>
</span><span id="line-817"></span><span class="hs-comment">-- Generalizes concatMap, mapMaybe, and mapFoldable.</span><span>
</span><span id="line-818"></span><span class="hs-comment">--</span><span>
</span><span id="line-819"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-820"></span><span id="local-6989586621679138461"><span id="local-6989586621679138462"><span id="local-6989586621679138463"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapC"><span class="hs-identifier hs-type">concatMapC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138463"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138462"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-821"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138461"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138462"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-822"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138461"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138462"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138463"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-823"></span><span id="concatMapC"><span class="annot"><span class="annottext">concatMapC :: (a -&gt; mono) -&gt; ConduitT a (Element mono) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatMapC"><span class="hs-identifier hs-var hs-var">concatMapC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; mono) -&gt; ConduitT a (Element mono) m ()
forall (m :: * -&gt; *) mono a.
(Monad m, MonoFoldable mono) =&gt;
(a -&gt; mono) -&gt; ConduitT a (Element mono) m ()
</span><a href="Data.Conduit.Combinators.html#concatMap"><span class="hs-identifier hs-var">CC.concatMap</span></a></span><span>
</span><span id="line-824"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapC"><span class="hs-pragma hs-type">concatMapC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-825"></span><span>
</span><span id="line-826"></span><span class="hs-comment">-- | Apply the function to each element in the chunked stream, resulting in a</span><span>
</span><span id="line-827"></span><span class="hs-comment">-- foldable value (e.g., a list). Then yield each of the individual values in</span><span>
</span><span id="line-828"></span><span class="hs-comment">-- that foldable value separately.</span><span>
</span><span id="line-829"></span><span class="hs-comment">--</span><span>
</span><span id="line-830"></span><span class="hs-comment">-- Generalizes concatMap, mapMaybe, and mapFoldable.</span><span>
</span><span id="line-831"></span><span class="hs-comment">--</span><span>
</span><span id="line-832"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-833"></span><span id="local-6989586621679138457"><span id="local-6989586621679138458"><span id="local-6989586621679138459"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapCE"><span class="hs-identifier hs-type">concatMapCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138459"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138458"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679138457"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-834"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138458"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138457"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-835"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138458"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138457"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138459"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-836"></span><span id="concatMapCE"><span class="annot"><span class="annottext">concatMapCE :: (Element mono -&gt; w) -&gt; ConduitT mono w m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatMapCE"><span class="hs-identifier hs-var hs-var">concatMapCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; w) -&gt; ConduitT mono w m ()
forall (m :: * -&gt; *) mono w.
(Monad m, MonoFoldable mono, Monoid w) =&gt;
(Element mono -&gt; w) -&gt; ConduitT mono w m ()
</span><a href="Data.Conduit.Combinators.html#concatMapE"><span class="hs-identifier hs-var">CC.concatMapE</span></a></span><span>
</span><span id="line-837"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapCE"><span class="hs-pragma hs-type">concatMapCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-838"></span><span>
</span><span id="line-839"></span><span class="hs-comment">-- | Stream up to n number of values downstream.</span><span>
</span><span id="line-840"></span><span class="hs-comment">--</span><span>
</span><span id="line-841"></span><span class="hs-comment">-- Note that, if downstream terminates early, not all values will be consumed.</span><span>
</span><span id="line-842"></span><span class="hs-comment">-- If you want to force /exactly/ the given number of values to be consumed,</span><span>
</span><span id="line-843"></span><span class="hs-comment">-- see 'takeExactly'.</span><span>
</span><span id="line-844"></span><span class="hs-comment">--</span><span>
</span><span id="line-845"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-846"></span><span id="local-6989586621679138454"><span id="local-6989586621679138455"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeC"><span class="hs-identifier hs-type">takeC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138455"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138454"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138454"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138455"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-847"></span><span id="takeC"><span class="annot"><span class="annottext">takeC :: Int -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeC"><span class="hs-identifier hs-var hs-var">takeC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a. Monad m =&gt; Int -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#take"><span class="hs-identifier hs-var">CC.take</span></a></span><span>
</span><span id="line-848"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeC"><span class="hs-pragma hs-type">takeC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-849"></span><span>
</span><span id="line-850"></span><span class="hs-comment">-- | Stream up to n number of elements downstream in a chunked stream.</span><span>
</span><span id="line-851"></span><span class="hs-comment">--</span><span>
</span><span id="line-852"></span><span class="hs-comment">-- Note that, if downstream terminates early, not all values will be consumed.</span><span>
</span><span id="line-853"></span><span class="hs-comment">-- If you want to force /exactly/ the given number of values to be consumed,</span><span>
</span><span id="line-854"></span><span class="hs-comment">-- see 'takeExactlyE'.</span><span>
</span><span id="line-855"></span><span class="hs-comment">--</span><span>
</span><span id="line-856"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-857"></span><span id="local-6989586621679138451"><span id="local-6989586621679138452"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeCE"><span class="hs-identifier hs-type">takeCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138452"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138451"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-858"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.Index</span></span><span> </span><span class="annot"><a href="#local-6989586621679138451"><span class="hs-identifier hs-type">seq</span></a></span><span>
</span><span id="line-859"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138451"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138451"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138452"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-860"></span><span id="takeCE"><span class="annot"><span class="annottext">takeCE :: Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeCE"><span class="hs-identifier hs-var hs-var">takeCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Index seq -&gt; ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq) =&gt;
Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#takeE"><span class="hs-identifier hs-var">CC.takeE</span></a></span><span>
</span><span id="line-861"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeCE"><span class="hs-pragma hs-type">takeCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-862"></span><span>
</span><span id="line-863"></span><span class="hs-comment">-- | Stream all values downstream that match the given predicate.</span><span>
</span><span id="line-864"></span><span class="hs-comment">--</span><span>
</span><span id="line-865"></span><span class="hs-comment">-- Same caveats regarding downstream termination apply as with 'take'.</span><span>
</span><span id="line-866"></span><span class="hs-comment">--</span><span>
</span><span id="line-867"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-868"></span><span id="local-6989586621679138448"><span id="local-6989586621679138449"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileC"><span class="hs-identifier hs-type">takeWhileC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138449"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-869"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138448"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-870"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138448"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138448"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138449"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-871"></span><span id="takeWhileC"><span class="annot"><span class="annottext">takeWhileC :: (a -&gt; Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileC"><span class="hs-identifier hs-var hs-var">takeWhileC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#takeWhile"><span class="hs-identifier hs-var">CC.takeWhile</span></a></span><span>
</span><span id="line-872"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileC"><span class="hs-pragma hs-type">takeWhileC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-873"></span><span>
</span><span id="line-874"></span><span class="hs-comment">-- | Stream all elements downstream that match the given predicate in a chunked stream.</span><span>
</span><span id="line-875"></span><span class="hs-comment">--</span><span>
</span><span id="line-876"></span><span class="hs-comment">-- Same caveats regarding downstream termination apply as with 'takeE'.</span><span>
</span><span id="line-877"></span><span class="hs-comment">--</span><span>
</span><span id="line-878"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-879"></span><span id="local-6989586621679138445"><span id="local-6989586621679138446"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileCE"><span class="hs-identifier hs-type">takeWhileCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138446"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138445"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-880"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138445"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-881"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138445"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138445"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138446"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-882"></span><span id="takeWhileCE"><span class="annot"><span class="annottext">takeWhileCE :: (Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileCE"><span class="hs-identifier hs-var hs-var">takeWhileCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq) =&gt;
(Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#takeWhileE"><span class="hs-identifier hs-var">CC.takeWhileE</span></a></span><span>
</span><span id="line-883"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeWhileCE"><span class="hs-pragma hs-type">takeWhileCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-884"></span><span>
</span><span id="line-885"></span><span class="hs-comment">-- | Consume precisely the given number of values and feed them downstream.</span><span>
</span><span id="line-886"></span><span class="hs-comment">--</span><span>
</span><span id="line-887"></span><span class="hs-comment">-- This function is in contrast to 'take', which will only consume up to the</span><span>
</span><span id="line-888"></span><span class="hs-comment">-- given number of values, and will terminate early if downstream terminates</span><span>
</span><span id="line-889"></span><span class="hs-comment">-- early. This function will discard any additional values in the stream if</span><span>
</span><span id="line-890"></span><span class="hs-comment">-- they are unconsumed.</span><span>
</span><span id="line-891"></span><span class="hs-comment">--</span><span>
</span><span id="line-892"></span><span class="hs-comment">-- Note that this function takes a downstream @ConduitT@ as a parameter, as</span><span>
</span><span id="line-893"></span><span class="hs-comment">-- opposed to working with normal fusion. For more information, see</span><span>
</span><span id="line-894"></span><span class="hs-comment">-- &lt;http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit&gt;, the section</span><span>
</span><span id="line-895"></span><span class="hs-comment">-- titled \&quot;pipes and conduit: isolate\&quot;.</span><span>
</span><span id="line-896"></span><span class="hs-comment">--</span><span>
</span><span id="line-897"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-898"></span><span id="local-6989586621679138440"><span id="local-6989586621679138441"><span id="local-6989586621679138442"><span id="local-6989586621679138443"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyC"><span class="hs-identifier hs-type">takeExactlyC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138443"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-899"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-900"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138442"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138441"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138443"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138440"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-901"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138442"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138441"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138443"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138440"><span class="hs-identifier hs-type">r</span></a></span></span></span></span></span><span>
</span><span id="line-902"></span><span id="takeExactlyC"><span class="annot"><span class="annottext">takeExactlyC :: Int -&gt; ConduitT a b m r -&gt; ConduitT a b m r
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyC"><span class="hs-identifier hs-var hs-var">takeExactlyC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConduitT a b m r -&gt; ConduitT a b m r
forall (m :: * -&gt; *) a b r.
Monad m =&gt;
Int -&gt; ConduitT a b m r -&gt; ConduitT a b m r
</span><a href="Data.Conduit.Combinators.html#takeExactly"><span class="hs-identifier hs-var">CC.takeExactly</span></a></span><span>
</span><span id="line-903"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyC"><span class="hs-pragma hs-type">takeExactlyC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-904"></span><span>
</span><span id="line-905"></span><span class="hs-comment">-- | Same as 'takeExactly', but for chunked streams.</span><span>
</span><span id="line-906"></span><span class="hs-comment">--</span><span>
</span><span id="line-907"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-908"></span><span id="local-6989586621679138435"><span id="local-6989586621679138436"><span id="local-6989586621679138437"><span id="local-6989586621679138438"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyCE"><span class="hs-identifier hs-type">takeExactlyCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138438"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138437"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-909"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.Index</span></span><span> </span><span class="annot"><a href="#local-6989586621679138437"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-910"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138437"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138436"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138438"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138435"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-911"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138437"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138436"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138438"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138435"><span class="hs-identifier hs-type">r</span></a></span></span></span></span></span><span>
</span><span id="line-912"></span><span id="takeExactlyCE"><span class="annot"><span class="annottext">takeExactlyCE :: Index a -&gt; ConduitT a b m r -&gt; ConduitT a b m r
</span><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyCE"><span class="hs-identifier hs-var hs-var">takeExactlyCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Index a -&gt; ConduitT a b m r -&gt; ConduitT a b m r
forall (m :: * -&gt; *) a b r.
(Monad m, IsSequence a) =&gt;
Index a -&gt; ConduitT a b m r -&gt; ConduitT a b m r
</span><a href="Data.Conduit.Combinators.html#takeExactlyE"><span class="hs-identifier hs-var">CC.takeExactlyE</span></a></span><span>
</span><span id="line-913"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#takeExactlyCE"><span class="hs-pragma hs-type">takeExactlyCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-914"></span><span>
</span><span id="line-915"></span><span class="hs-comment">-- | Flatten out a stream by yielding the values contained in an incoming</span><span>
</span><span id="line-916"></span><span class="hs-comment">-- @MonoFoldable@ as individually yielded values.</span><span>
</span><span id="line-917"></span><span class="hs-comment">--</span><span>
</span><span id="line-918"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-919"></span><span id="local-6989586621679138432"><span id="local-6989586621679138433"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatC"><span class="hs-identifier hs-type">concatC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138433"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138432"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-920"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138432"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138432"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138433"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-921"></span><span id="concatC"><span class="annot"><span class="annottext">concatC :: ConduitT mono (Element mono) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatC"><span class="hs-identifier hs-var hs-var">concatC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT mono (Element mono) m ()
forall (m :: * -&gt; *) mono.
(Monad m, MonoFoldable mono) =&gt;
ConduitT mono (Element mono) m ()
</span><a href="Data.Conduit.Combinators.html#concat"><span class="hs-identifier hs-var">CC.concat</span></a></span><span>
</span><span id="line-922"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatC"><span class="hs-pragma hs-type">concatC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-923"></span><span>
</span><span id="line-924"></span><span class="hs-comment">-- | Keep only values in the stream passing a given predicate.</span><span>
</span><span id="line-925"></span><span class="hs-comment">--</span><span>
</span><span id="line-926"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-927"></span><span id="local-6989586621679138429"><span id="local-6989586621679138430"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterC"><span class="hs-identifier hs-type">filterC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138429"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138429"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138429"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-928"></span><span id="filterC"><span class="annot"><span class="annottext">filterC :: (a -&gt; Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#filterC"><span class="hs-identifier hs-var hs-var">filterC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Bool) -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#filter"><span class="hs-identifier hs-var">CC.filter</span></a></span><span>
</span><span id="line-929"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterC"><span class="hs-pragma hs-type">filterC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-930"></span><span>
</span><span id="line-931"></span><span class="hs-comment">-- | Keep only elements in the chunked stream passing a given predicate.</span><span>
</span><span id="line-932"></span><span class="hs-comment">--</span><span>
</span><span id="line-933"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-934"></span><span id="local-6989586621679138426"><span id="local-6989586621679138427"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterCE"><span class="hs-identifier hs-type">filterCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138427"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138426"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138427"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138427"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138427"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138426"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-935"></span><span id="filterCE"><span class="annot"><span class="annottext">filterCE :: (Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#filterCE"><span class="hs-identifier hs-var hs-var">filterCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
forall seq (m :: * -&gt; *).
(IsSequence seq, Monad m) =&gt;
(Element seq -&gt; Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#filterE"><span class="hs-identifier hs-var">CC.filterE</span></a></span><span>
</span><span id="line-936"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterCE"><span class="hs-pragma hs-type">filterCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-937"></span><span>
</span><span id="line-938"></span><span class="hs-comment">-- | Map values as long as the result is @Just@.</span><span>
</span><span id="line-939"></span><span class="hs-comment">--</span><span>
</span><span id="line-940"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-941"></span><span id="local-6989586621679138422"><span id="local-6989586621679138423"><span id="local-6989586621679138424"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapWhileC"><span class="hs-identifier hs-type">mapWhileC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138424"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138423"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679138422"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138423"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138422"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138424"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-942"></span><span id="mapWhileC"><span class="annot"><span class="annottext">mapWhileC :: (a -&gt; Maybe b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapWhileC"><span class="hs-identifier hs-var hs-var">mapWhileC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe b) -&gt; ConduitT a b m ()
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; Maybe b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.html#mapWhile"><span class="hs-identifier hs-var">CC.mapWhile</span></a></span><span>
</span><span id="line-943"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapWhileC"><span class="hs-pragma hs-type">mapWhileC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-944"></span><span>
</span><span id="line-945"></span><span class="hs-comment">-- | Break up a stream of values into vectors of size n. The final vector may</span><span>
</span><span id="line-946"></span><span class="hs-comment">-- be smaller than n if the total number of values is not a strict multiple of</span><span>
</span><span id="line-947"></span><span class="hs-comment">-- n. No empty vectors will be yielded.</span><span>
</span><span id="line-948"></span><span class="hs-comment">--</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-950"></span><span id="local-6989586621679138418"><span id="local-6989586621679138419"><span id="local-6989586621679138420"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#conduitVector"><span class="hs-identifier hs-type">conduitVector</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">V.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679138420"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138419"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">PrimMonad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138418"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-951"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-comment">-- ^ maximum allowed size</span><span>
</span><span id="line-952"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138419"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138420"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138419"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-953"></span><span id="conduitVector"><span class="annot"><span class="annottext">conduitVector :: Int -&gt; ConduitT a (v a) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#conduitVector"><span class="hs-identifier hs-var hs-var">conduitVector</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConduitT a (v a) m ()
forall (v :: * -&gt; *) a (m :: * -&gt; *).
(Vector v a, PrimMonad m) =&gt;
Int -&gt; ConduitT a (v a) m ()
</span><a href="Data.Conduit.Combinators.html#conduitVector"><span class="hs-identifier hs-var">CC.conduitVector</span></a></span><span>
</span><span id="line-954"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#conduitVector"><span class="hs-pragma hs-type">conduitVector</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-955"></span><span>
</span><span id="line-956"></span><span class="hs-comment">-- | Analog of 'Prelude.scanl' for lists.</span><span>
</span><span id="line-957"></span><span class="hs-comment">--</span><span>
</span><span id="line-958"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-959"></span><span id="local-6989586621679138414"><span id="local-6989586621679138415"><span id="local-6989586621679138416"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlC"><span class="hs-identifier hs-type">scanlC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138416"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138415"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138414"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138415"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138415"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138414"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138415"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138416"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-960"></span><span id="scanlC"><span class="annot"><span class="annottext">scanlC :: (a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#scanlC"><span class="hs-identifier hs-var hs-var">scanlC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b a m ()
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; b -&gt; a) -&gt; a -&gt; ConduitT b a m ()
</span><a href="Data.Conduit.Combinators.html#scanl"><span class="hs-identifier hs-var">CC.scanl</span></a></span><span>
</span><span id="line-961"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlC"><span class="hs-pragma hs-type">scanlC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-962"></span><span>
</span><span id="line-963"></span><span class="hs-comment">-- | 'mapWhileC' with a break condition dependent on a strict accumulator.</span><span>
</span><span id="line-964"></span><span class="hs-comment">-- Equivalently, 'CL.mapAccum' as long as the result is @Right@. Instead of</span><span>
</span><span id="line-965"></span><span class="hs-comment">-- producing a leftover, the breaking input determines the resulting</span><span>
</span><span id="line-966"></span><span class="hs-comment">-- accumulator via @Left@.</span><span>
</span><span id="line-967"></span><span id="local-6989586621679138409"><span id="local-6989586621679138410"><span id="local-6989586621679138411"><span id="local-6989586621679138412"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileC"><span class="hs-identifier hs-type">mapAccumWhileC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138412"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-968"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138411"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138410"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679138410"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138410"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679138409"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138410"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138411"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138409"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138412"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138410"><span class="hs-identifier hs-type">s</span></a></span></span></span></span></span><span>
</span><span id="line-969"></span><span id="mapAccumWhileC"><span class="annot"><span class="annottext">mapAccumWhileC :: (a -&gt; s -&gt; Either s (s, b)) -&gt; s -&gt; ConduitT a b m s
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileC"><span class="hs-identifier hs-var hs-var">mapAccumWhileC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; s -&gt; Either s (s, b)) -&gt; s -&gt; ConduitT a b m s
forall (m :: * -&gt; *) a s b.
Monad m =&gt;
(a -&gt; s -&gt; Either s (s, b)) -&gt; s -&gt; ConduitT a b m s
</span><a href="Data.Conduit.Combinators.html#mapAccumWhile"><span class="hs-identifier hs-var">CC.mapAccumWhile</span></a></span><span>
</span><span id="line-970"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileC"><span class="hs-pragma hs-type">mapAccumWhileC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-971"></span><span>
</span><span id="line-972"></span><span class="hs-comment">-- | 'concatMap' with an accumulator.</span><span>
</span><span id="line-973"></span><span class="hs-comment">--</span><span>
</span><span id="line-974"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-975"></span><span id="local-6989586621679138404"><span id="local-6989586621679138405"><span id="local-6989586621679138406"><span id="local-6989586621679138407"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumC"><span class="hs-identifier hs-type">concatMapAccumC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138407"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138406"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138405"><span class="hs-identifier hs-type">accum</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138405"><span class="hs-identifier hs-type">accum</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679138404"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138405"><span class="hs-identifier hs-type">accum</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138406"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138404"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138407"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-976"></span><span id="concatMapAccumC"><span class="annot"><span class="annottext">concatMapAccumC :: (a -&gt; accum -&gt; (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumC"><span class="hs-identifier hs-var hs-var">concatMapAccumC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; accum -&gt; (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
forall (m :: * -&gt; *) a accum b.
Monad m =&gt;
(a -&gt; accum -&gt; (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.html#concatMapAccum"><span class="hs-identifier hs-var">CC.concatMapAccum</span></a></span><span>
</span><span id="line-977"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumC"><span class="hs-pragma hs-type">concatMapAccumC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-978"></span><span>
</span><span id="line-979"></span><span class="hs-comment">-- | Insert the given value between each two values in the stream.</span><span>
</span><span id="line-980"></span><span class="hs-comment">--</span><span>
</span><span id="line-981"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-982"></span><span id="local-6989586621679138401"><span id="local-6989586621679138402"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#intersperseC"><span class="hs-identifier hs-type">intersperseC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138402"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138401"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138401"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138401"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138402"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-983"></span><span id="intersperseC"><span class="annot"><span class="annottext">intersperseC :: a -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#intersperseC"><span class="hs-identifier hs-var hs-var">intersperseC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#intersperse"><span class="hs-identifier hs-var">CC.intersperse</span></a></span><span>
</span><span id="line-984"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#intersperseC"><span class="hs-pragma hs-type">intersperseC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-985"></span><span>
</span><span id="line-986"></span><span class="hs-comment">-- | Sliding window of values</span><span>
</span><span id="line-987"></span><span class="hs-comment">-- 1,2,3,4,5 with window size 2 gives</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- [1,2],[2,3],[3,4],[4,5]</span><span>
</span><span id="line-989"></span><span class="hs-comment">--</span><span>
</span><span id="line-990"></span><span class="hs-comment">-- Best used with structures that support O(1) snoc.</span><span>
</span><span id="line-991"></span><span class="hs-comment">--</span><span>
</span><span id="line-992"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-993"></span><span id="local-6989586621679138397"><span id="local-6989586621679138398"><span id="local-6989586621679138399"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#slidingWindowC"><span class="hs-identifier hs-type">slidingWindowC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138399"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138398"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138398"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><a href="#local-6989586621679138397"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138397"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138398"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138399"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-994"></span><span id="slidingWindowC"><span class="annot"><span class="annottext">slidingWindowC :: Int -&gt; ConduitT a seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#slidingWindowC"><span class="hs-identifier hs-var hs-var">slidingWindowC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConduitT a seq m ()
forall (m :: * -&gt; *) seq a.
(Monad m, IsSequence seq, Element seq ~ a) =&gt;
Int -&gt; ConduitT a seq m ()
</span><a href="Data.Conduit.Combinators.html#slidingWindow"><span class="hs-identifier hs-var">CC.slidingWindow</span></a></span><span>
</span><span id="line-995"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#slidingWindowC"><span class="hs-pragma hs-type">slidingWindowC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-996"></span><span>
</span><span id="line-997"></span><span>
</span><span id="line-998"></span><span class="hs-comment">-- | Split input into chunk of size 'chunkSize'</span><span>
</span><span id="line-999"></span><span class="hs-comment">--</span><span>
</span><span id="line-1000"></span><span class="hs-comment">-- The last element may be smaller than the 'chunkSize' (see also</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- 'chunksOfExactlyE' which will not yield this last element)</span><span>
</span><span id="line-1002"></span><span class="hs-comment">--</span><span>
</span><span id="line-1003"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1004"></span><span id="local-6989586621679138394"><span id="local-6989586621679138395"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfCE"><span class="hs-identifier hs-type">chunksOfCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138395"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138394"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.Index</span></span><span> </span><span class="annot"><a href="#local-6989586621679138394"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138394"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138394"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138395"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1005"></span><span id="chunksOfCE"><span class="annot"><span class="annottext">chunksOfCE :: Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfCE"><span class="hs-identifier hs-var hs-var">chunksOfCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Index seq -&gt; ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq) =&gt;
Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#chunksOfE"><span class="hs-identifier hs-var">CC.chunksOfE</span></a></span><span>
</span><span id="line-1006"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfCE"><span class="hs-pragma hs-type">chunksOfCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1007"></span><span>
</span><span id="line-1008"></span><span class="hs-comment">-- | Split input into chunk of size 'chunkSize'</span><span>
</span><span id="line-1009"></span><span class="hs-comment">--</span><span>
</span><span id="line-1010"></span><span class="hs-comment">-- If the input does not split into chunks exactly, the remainder will be</span><span>
</span><span id="line-1011"></span><span class="hs-comment">-- leftover (see also 'chunksOfE')</span><span>
</span><span id="line-1012"></span><span class="hs-comment">--</span><span>
</span><span id="line-1013"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1014"></span><span id="local-6989586621679138391"><span id="local-6989586621679138392"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfExactlyCE"><span class="hs-identifier hs-type">chunksOfExactlyCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138392"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138391"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.Index</span></span><span> </span><span class="annot"><a href="#local-6989586621679138391"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138391"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138391"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138392"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1015"></span><span id="chunksOfExactlyCE"><span class="annot"><span class="annottext">chunksOfExactlyCE :: Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfExactlyCE"><span class="hs-identifier hs-var hs-var">chunksOfExactlyCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Index seq -&gt; ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq) =&gt;
Index seq -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#chunksOfExactlyE"><span class="hs-identifier hs-var">CC.chunksOfExactlyE</span></a></span><span>
</span><span id="line-1016"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#chunksOfExactlyCE"><span class="hs-pragma hs-type">chunksOfExactlyCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1017"></span><span>
</span><span id="line-1018"></span><span class="hs-comment">-- | Apply a monadic transformation to all values in a stream.</span><span>
</span><span id="line-1019"></span><span class="hs-comment">--</span><span>
</span><span id="line-1020"></span><span class="hs-comment">-- If you do not need the transformed values, and instead just want the monadic</span><span>
</span><span id="line-1021"></span><span class="hs-comment">-- side-effects of running the action, see 'mapM_'.</span><span>
</span><span id="line-1022"></span><span class="hs-comment">--</span><span>
</span><span id="line-1023"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1024"></span><span id="local-6989586621679138387"><span id="local-6989586621679138388"><span id="local-6989586621679138389"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMC"><span class="hs-identifier hs-type">mapMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138388"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138387"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138388"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138387"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1025"></span><span id="mapMC"><span class="annot"><span class="annottext">mapMC :: (a -&gt; m b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapMC"><span class="hs-identifier hs-var hs-var">mapMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; ConduitT a b m ()
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.html#mapM"><span class="hs-identifier hs-var">CC.mapM</span></a></span><span>
</span><span id="line-1026"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMC"><span class="hs-pragma hs-type">mapMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1027"></span><span>
</span><span id="line-1028"></span><span class="hs-comment">-- | Apply a monadic transformation to all elements in a chunked stream.</span><span>
</span><span id="line-1029"></span><span class="hs-comment">--</span><span>
</span><span id="line-1030"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1031"></span><span id="local-6989586621679138382"><span id="local-6989586621679138383"><span id="local-6989586621679138384"><span id="local-6989586621679138385"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMCE"><span class="hs-identifier hs-type">mapMCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138385"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Data.Traversable.Traversable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138384"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138383"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138385"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138382"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138384"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138383"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138384"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138382"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138385"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1032"></span><span id="mapMCE"><span class="annot"><span class="annottext">mapMCE :: (a -&gt; m b) -&gt; ConduitT (f a) (f b) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapMCE"><span class="hs-identifier hs-var hs-var">mapMCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; ConduitT (f a) (f b) m ()
forall (m :: * -&gt; *) (f :: * -&gt; *) a b.
(Monad m, Traversable f) =&gt;
(a -&gt; m b) -&gt; ConduitT (f a) (f b) m ()
</span><a href="Data.Conduit.Combinators.html#mapME"><span class="hs-identifier hs-var">CC.mapME</span></a></span><span>
</span><span id="line-1033"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapMCE"><span class="hs-pragma hs-type">mapMCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1034"></span><span>
</span><span id="line-1035"></span><span class="hs-comment">-- | Apply a monadic monomorphic transformation to all elements in a chunked stream.</span><span>
</span><span id="line-1036"></span><span class="hs-comment">--</span><span>
</span><span id="line-1037"></span><span class="hs-comment">-- Unlike @mapME@, this will work on types like @ByteString@ and @Text@ which</span><span>
</span><span id="line-1038"></span><span class="hs-comment">-- are @MonoFunctor@ but not @Functor@.</span><span>
</span><span id="line-1039"></span><span class="hs-comment">--</span><span>
</span><span id="line-1040"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1041"></span><span id="local-6989586621679138379"><span id="local-6989586621679138380"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapMCE"><span class="hs-identifier hs-type">omapMCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138380"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoTraversable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138379"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1042"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138379"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138380"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138379"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1043"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138379"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138379"><span class="hs-identifier hs-type">mono</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138380"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1044"></span><span id="omapMCE"><span class="annot"><span class="annottext">omapMCE :: (Element mono -&gt; m (Element mono)) -&gt; ConduitT mono mono m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#omapMCE"><span class="hs-identifier hs-var hs-var">omapMCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element mono -&gt; m (Element mono)) -&gt; ConduitT mono mono m ()
forall (m :: * -&gt; *) mono.
(Monad m, MonoTraversable mono) =&gt;
(Element mono -&gt; m (Element mono)) -&gt; ConduitT mono mono m ()
</span><a href="Data.Conduit.Combinators.html#omapME"><span class="hs-identifier hs-var">CC.omapME</span></a></span><span>
</span><span id="line-1045"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#omapMCE"><span class="hs-pragma hs-type">omapMCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1046"></span><span>
</span><span id="line-1047"></span><span class="hs-comment">-- | Apply the monadic function to each value in the stream, resulting in a</span><span>
</span><span id="line-1048"></span><span class="hs-comment">-- foldable value (e.g., a list). Then yield each of the individual values in</span><span>
</span><span id="line-1049"></span><span class="hs-comment">-- that foldable value separately.</span><span>
</span><span id="line-1050"></span><span class="hs-comment">--</span><span>
</span><span id="line-1051"></span><span class="hs-comment">-- Generalizes concatMapM, mapMaybeM, and mapFoldableM.</span><span>
</span><span id="line-1052"></span><span class="hs-comment">--</span><span>
</span><span id="line-1053"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1054"></span><span id="local-6989586621679138375"><span id="local-6989586621679138376"><span id="local-6989586621679138377"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapMC"><span class="hs-identifier hs-type">concatMapMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138377"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonoFoldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679138376"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1055"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138375"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138377"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138376"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1056"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138375"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138376"><span class="hs-identifier hs-type">mono</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138377"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1057"></span><span id="concatMapMC"><span class="annot"><span class="annottext">concatMapMC :: (a -&gt; m mono) -&gt; ConduitT a (Element mono) m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatMapMC"><span class="hs-identifier hs-var hs-var">concatMapMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m mono) -&gt; ConduitT a (Element mono) m ()
forall (m :: * -&gt; *) mono a.
(Monad m, MonoFoldable mono) =&gt;
(a -&gt; m mono) -&gt; ConduitT a (Element mono) m ()
</span><a href="Data.Conduit.Combinators.html#concatMapM"><span class="hs-identifier hs-var">CC.concatMapM</span></a></span><span>
</span><span id="line-1058"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapMC"><span class="hs-pragma hs-type">concatMapMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1059"></span><span>
</span><span id="line-1060"></span><span class="hs-comment">-- | Keep only values in the stream passing a given monadic predicate.</span><span>
</span><span id="line-1061"></span><span class="hs-comment">--</span><span>
</span><span id="line-1062"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1063"></span><span id="local-6989586621679138372"><span id="local-6989586621679138373"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMC"><span class="hs-identifier hs-type">filterMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138373"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-1064"></span><span>        </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138372"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138373"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>
</span><span id="line-1065"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138372"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138372"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138373"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1066"></span><span id="filterMC"><span class="annot"><span class="annottext">filterMC :: (a -&gt; m Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#filterMC"><span class="hs-identifier hs-var hs-var">filterMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool) -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a.
Monad m =&gt;
(a -&gt; m Bool) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#filterM"><span class="hs-identifier hs-var">CC.filterM</span></a></span><span>
</span><span id="line-1067"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMC"><span class="hs-pragma hs-type">filterMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1068"></span><span>
</span><span id="line-1069"></span><span class="hs-comment">-- | Keep only elements in the chunked stream passing a given monadic predicate.</span><span>
</span><span id="line-1070"></span><span class="hs-comment">--</span><span>
</span><span id="line-1071"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1072"></span><span id="local-6989586621679138369"><span id="local-6989586621679138370"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMCE"><span class="hs-identifier hs-type">filterMCE</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138370"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138369"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138369"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138370"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138369"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138369"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138370"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1073"></span><span id="filterMCE"><span class="annot"><span class="annottext">filterMCE :: (Element seq -&gt; m Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#filterMCE"><span class="hs-identifier hs-var hs-var">filterMCE</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Element seq -&gt; m Bool) -&gt; ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq) =&gt;
(Element seq -&gt; m Bool) -&gt; ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#filterME"><span class="hs-identifier hs-var">CC.filterME</span></a></span><span>
</span><span id="line-1074"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#filterMCE"><span class="hs-pragma hs-type">filterMCE</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1075"></span><span>
</span><span id="line-1076"></span><span class="hs-comment">-- | Apply a monadic action on all values in a stream.</span><span>
</span><span id="line-1077"></span><span class="hs-comment">--</span><span>
</span><span id="line-1078"></span><span class="hs-comment">-- This @Conduit@ can be used to perform a monadic side-effect for every</span><span>
</span><span id="line-1079"></span><span class="hs-comment">-- value, whilst passing the value through the @Conduit@ as-is.</span><span>
</span><span id="line-1080"></span><span class="hs-comment">--</span><span>
</span><span id="line-1081"></span><span class="hs-comment">-- &gt; iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)</span><span>
</span><span id="line-1082"></span><span class="hs-comment">--</span><span>
</span><span id="line-1083"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1084"></span><span id="local-6989586621679138366"><span id="local-6989586621679138367"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterMC"><span class="hs-identifier hs-type">iterMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138367"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138366"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138367"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138366"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138366"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138367"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1085"></span><span id="iterMC"><span class="annot"><span class="annottext">iterMC :: (a -&gt; m ()) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#iterMC"><span class="hs-identifier hs-var hs-var">iterMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m ()) -&gt; ConduitT a a m ()
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m ()) -&gt; ConduitT a a m ()
</span><a href="Data.Conduit.Combinators.html#iterM"><span class="hs-identifier hs-var">CC.iterM</span></a></span><span>
</span><span id="line-1086"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#iterMC"><span class="hs-pragma hs-type">iterMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1087"></span><span>
</span><span id="line-1088"></span><span class="hs-comment">-- | Analog of 'Prelude.scanl' for lists, monadic.</span><span>
</span><span id="line-1089"></span><span class="hs-comment">--</span><span>
</span><span id="line-1090"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1091"></span><span id="local-6989586621679138362"><span id="local-6989586621679138363"><span id="local-6989586621679138364"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlMC"><span class="hs-identifier hs-type">scanlMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138364"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138363"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138362"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138364"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138363"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138363"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138362"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138363"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138364"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1092"></span><span id="scanlMC"><span class="annot"><span class="annottext">scanlMC :: (a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b a m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#scanlMC"><span class="hs-identifier hs-var hs-var">scanlMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b a m ()
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; b -&gt; m a) -&gt; a -&gt; ConduitT b a m ()
</span><a href="Data.Conduit.Combinators.html#scanlM"><span class="hs-identifier hs-var">CC.scanlM</span></a></span><span>
</span><span id="line-1093"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#scanlMC"><span class="hs-pragma hs-type">scanlMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1094"></span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- | Monadic `mapAccumWhileC`.</span><span>
</span><span id="line-1096"></span><span id="local-6989586621679138357"><span id="local-6989586621679138358"><span id="local-6989586621679138359"><span id="local-6989586621679138360"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileMC"><span class="hs-identifier hs-type">mapAccumWhileMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138360"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138359"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138358"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138360"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679138358"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138358"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679138357"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138358"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138359"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138357"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138360"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138358"><span class="hs-identifier hs-type">s</span></a></span></span></span></span></span><span>
</span><span id="line-1097"></span><span id="mapAccumWhileMC"><span class="annot"><span class="annottext">mapAccumWhileMC :: (a -&gt; s -&gt; m (Either s (s, b))) -&gt; s -&gt; ConduitT a b m s
</span><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileMC"><span class="hs-identifier hs-var hs-var">mapAccumWhileMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; s -&gt; m (Either s (s, b))) -&gt; s -&gt; ConduitT a b m s
forall (m :: * -&gt; *) a s b.
Monad m =&gt;
(a -&gt; s -&gt; m (Either s (s, b))) -&gt; s -&gt; ConduitT a b m s
</span><a href="Data.Conduit.Combinators.html#mapAccumWhileM"><span class="hs-identifier hs-var">CC.mapAccumWhileM</span></a></span><span>
</span><span id="line-1098"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#mapAccumWhileMC"><span class="hs-pragma hs-type">mapAccumWhileMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1099"></span><span>
</span><span id="line-1100"></span><span class="hs-comment">-- | 'concatMapM' with an accumulator.</span><span>
</span><span id="line-1101"></span><span class="hs-comment">--</span><span>
</span><span id="line-1102"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1103"></span><span id="local-6989586621679138352"><span id="local-6989586621679138353"><span id="local-6989586621679138354"><span id="local-6989586621679138355"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumMC"><span class="hs-identifier hs-type">concatMapAccumMC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138355"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138354"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138353"><span class="hs-identifier hs-type">accum</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138355"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138353"><span class="hs-identifier hs-type">accum</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679138352"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138353"><span class="hs-identifier hs-type">accum</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138354"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138352"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138355"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-1104"></span><span id="concatMapAccumMC"><span class="annot"><span class="annottext">concatMapAccumMC :: (a -&gt; accum -&gt; m (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumMC"><span class="hs-identifier hs-var hs-var">concatMapAccumMC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; accum -&gt; m (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
forall (m :: * -&gt; *) a accum b.
Monad m =&gt;
(a -&gt; accum -&gt; m (accum, [b])) -&gt; accum -&gt; ConduitT a b m ()
</span><a href="Data.Conduit.Combinators.html#concatMapAccumM"><span class="hs-identifier hs-var">CC.concatMapAccumM</span></a></span><span>
</span><span id="line-1105"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#concatMapAccumMC"><span class="hs-pragma hs-type">concatMapAccumMC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1106"></span><span>
</span><span id="line-1107"></span><span class="hs-comment">-- | Encode a stream of text as UTF8.</span><span>
</span><span id="line-1108"></span><span class="hs-comment">--</span><span>
</span><span id="line-1109"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1110"></span><span id="local-6989586621679138348"><span id="local-6989586621679138349"><span id="local-6989586621679138350"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#encodeUtf8C"><span class="hs-identifier hs-type">encodeUtf8C</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138350"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DTE.Utf8</span></span><span> </span><span class="annot"><a href="#local-6989586621679138349"><span class="hs-identifier hs-type">text</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138348"><span class="hs-identifier hs-type">binary</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138349"><span class="hs-identifier hs-type">text</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138348"><span class="hs-identifier hs-type">binary</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138350"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-1111"></span><span id="encodeUtf8C"><span class="annot"><span class="annottext">encodeUtf8C :: ConduitT text binary m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#encodeUtf8C"><span class="hs-identifier hs-var hs-var">encodeUtf8C</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT text binary m ()
forall (m :: * -&gt; *) text binary.
(Monad m, Utf8 text binary) =&gt;
ConduitT text binary m ()
</span><a href="Data.Conduit.Combinators.html#encodeUtf8"><span class="hs-identifier hs-var">CC.encodeUtf8</span></a></span><span>
</span><span id="line-1112"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#encodeUtf8C"><span class="hs-pragma hs-type">encodeUtf8C</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1113"></span><span>
</span><span id="line-1114"></span><span class="hs-comment">-- | Decode a stream of binary data as UTF8.</span><span>
</span><span id="line-1115"></span><span class="hs-comment">--</span><span>
</span><span id="line-1116"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1117"></span><span id="local-6989586621679138346"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8C"><span class="hs-identifier hs-type">decodeUtf8C</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadThrow</span></span><span> </span><span class="annot"><a href="#local-6989586621679138346"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><a href="#local-6989586621679138346"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-1118"></span><span id="decodeUtf8C"><span class="annot"><span class="annottext">decodeUtf8C :: ConduitT ByteString Text m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8C"><span class="hs-identifier hs-var hs-var">decodeUtf8C</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT ByteString Text m ()
forall (m :: * -&gt; *). MonadThrow m =&gt; ConduitT ByteString Text m ()
</span><a href="Data.Conduit.Combinators.html#decodeUtf8"><span class="hs-identifier hs-var">CC.decodeUtf8</span></a></span><span>
</span><span id="line-1119"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8C"><span class="hs-pragma hs-type">decodeUtf8C</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1120"></span><span>
</span><span id="line-1121"></span><span class="hs-comment">-- | Decode a stream of binary data as UTF8, replacing any invalid bytes with</span><span>
</span><span id="line-1122"></span><span class="hs-comment">-- the Unicode replacement character.</span><span>
</span><span id="line-1123"></span><span class="hs-comment">--</span><span>
</span><span id="line-1124"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1125"></span><span id="local-6989586621679138344"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8LenientC"><span class="hs-identifier hs-type">decodeUtf8LenientC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138344"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><a href="#local-6989586621679138344"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-1126"></span><span id="decodeUtf8LenientC"><span class="annot"><span class="annottext">decodeUtf8LenientC :: ConduitT ByteString Text m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8LenientC"><span class="hs-identifier hs-var hs-var">decodeUtf8LenientC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT ByteString Text m ()
forall (m :: * -&gt; *). Monad m =&gt; ConduitT ByteString Text m ()
</span><a href="Data.Conduit.Combinators.html#decodeUtf8Lenient"><span class="hs-identifier hs-var">CC.decodeUtf8Lenient</span></a></span><span>
</span><span id="line-1127"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#decodeUtf8LenientC"><span class="hs-pragma hs-type">decodeUtf8LenientC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1128"></span><span>
</span><span id="line-1129"></span><span class="hs-comment">-- | Stream in the entirety of a single line.</span><span>
</span><span id="line-1130"></span><span class="hs-comment">--</span><span>
</span><span id="line-1131"></span><span class="hs-comment">-- Like @takeExactly@, this will consume the entirety of the line regardless of</span><span>
</span><span id="line-1132"></span><span class="hs-comment">-- the behavior of the inner Conduit.</span><span>
</span><span id="line-1133"></span><span class="hs-comment">--</span><span>
</span><span id="line-1134"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1135"></span><span id="local-6989586621679138339"><span id="local-6989586621679138340"><span id="local-6989586621679138341"><span id="local-6989586621679138342"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineC"><span class="hs-identifier hs-type">lineC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138342"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138341"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138341"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">)</span><span>
</span><span id="line-1136"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138341"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138340"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138339"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-1137"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138341"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138340"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138339"><span class="hs-identifier hs-type">r</span></a></span></span></span></span></span><span>
</span><span id="line-1138"></span><span id="lineC"><span class="annot"><span class="annottext">lineC :: ConduitT seq o m r -&gt; ConduitT seq o m r
</span><a href="Data.Conduit.Combinators.Unqualified.html#lineC"><span class="hs-identifier hs-var hs-var">lineC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m r -&gt; ConduitT seq o m r
forall (m :: * -&gt; *) seq o r.
(Monad m, IsSequence seq, Element seq ~ Char) =&gt;
ConduitT seq o m r -&gt; ConduitT seq o m r
</span><a href="Data.Conduit.Combinators.html#line"><span class="hs-identifier hs-var">CC.line</span></a></span><span>
</span><span id="line-1139"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineC"><span class="hs-pragma hs-type">lineC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1140"></span><span>
</span><span id="line-1141"></span><span class="hs-comment">-- | Same as 'line', but operates on ASCII/binary data.</span><span>
</span><span id="line-1142"></span><span class="hs-comment">--</span><span>
</span><span id="line-1143"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1144"></span><span id="local-6989586621679138334"><span id="local-6989586621679138335"><span id="local-6989586621679138336"><span id="local-6989586621679138337"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineAsciiC"><span class="hs-identifier hs-type">lineAsciiC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138337"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138336"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138336"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span>
</span><span id="line-1145"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138336"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138335"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138337"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138334"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-1146"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138336"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138335"><span class="hs-identifier hs-type">o</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138337"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138334"><span class="hs-identifier hs-type">r</span></a></span></span></span></span></span><span>
</span><span id="line-1147"></span><span id="lineAsciiC"><span class="annot"><span class="annottext">lineAsciiC :: ConduitT seq o m r -&gt; ConduitT seq o m r
</span><a href="Data.Conduit.Combinators.Unqualified.html#lineAsciiC"><span class="hs-identifier hs-var hs-var">lineAsciiC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq o m r -&gt; ConduitT seq o m r
forall (m :: * -&gt; *) seq o r.
(Monad m, IsSequence seq, Element seq ~ Word8) =&gt;
ConduitT seq o m r -&gt; ConduitT seq o m r
</span><a href="Data.Conduit.Combinators.html#lineAscii"><span class="hs-identifier hs-var">CC.lineAscii</span></a></span><span>
</span><span id="line-1148"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#lineAsciiC"><span class="hs-pragma hs-type">lineAsciiC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1149"></span><span>
</span><span id="line-1150"></span><span class="hs-comment">-- | Insert a newline character after each incoming chunk of data.</span><span>
</span><span id="line-1151"></span><span class="hs-comment">--</span><span>
</span><span id="line-1152"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1153"></span><span id="local-6989586621679138331"><span id="local-6989586621679138332"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesC"><span class="hs-identifier hs-type">unlinesC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138332"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138331"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138331"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138331"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138331"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138332"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1154"></span><span id="unlinesC"><span class="annot"><span class="annottext">unlinesC :: ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#unlinesC"><span class="hs-identifier hs-var hs-var">unlinesC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq, Element seq ~ Char) =&gt;
ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#unlines"><span class="hs-identifier hs-var">CC.unlines</span></a></span><span>
</span><span id="line-1155"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesC"><span class="hs-pragma hs-type">unlinesC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1156"></span><span>
</span><span id="line-1157"></span><span class="hs-comment">-- | Same as 'unlines', but operates on ASCII/binary data.</span><span>
</span><span id="line-1158"></span><span class="hs-comment">--</span><span>
</span><span id="line-1159"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1160"></span><span id="local-6989586621679138328"><span id="local-6989586621679138329"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesAsciiC"><span class="hs-identifier hs-type">unlinesAsciiC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138329"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138328"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138328"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138328"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138328"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138329"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1161"></span><span id="unlinesAsciiC"><span class="annot"><span class="annottext">unlinesAsciiC :: ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#unlinesAsciiC"><span class="hs-identifier hs-var hs-var">unlinesAsciiC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq, Element seq ~ Word8) =&gt;
ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#unlinesAscii"><span class="hs-identifier hs-var">CC.unlinesAscii</span></a></span><span>
</span><span id="line-1162"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#unlinesAsciiC"><span class="hs-pragma hs-type">unlinesAsciiC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1163"></span><span>
</span><span id="line-1164"></span><span class="hs-comment">-- | Convert a stream of arbitrarily-chunked textual data into a stream of data</span><span>
</span><span id="line-1165"></span><span class="hs-comment">-- where each chunk represents a single line. Note that, if you have</span><span>
</span><span id="line-1166"></span><span class="hs-comment">-- unknown/untrusted input, this function is /unsafe/, since it would allow an</span><span>
</span><span id="line-1167"></span><span class="hs-comment">-- attacker to form lines of massive length and exhaust memory.</span><span>
</span><span id="line-1168"></span><span class="hs-comment">--</span><span>
</span><span id="line-1169"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1170"></span><span id="local-6989586621679138325"><span id="local-6989586621679138326"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedC"><span class="hs-identifier hs-type">linesUnboundedC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138326"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138325"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138325"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">)</span><span>
</span><span id="line-1171"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138325"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138325"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138326"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1172"></span><span id="linesUnboundedC"><span class="annot"><span class="annottext">linesUnboundedC :: ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedC"><span class="hs-identifier hs-var hs-var">linesUnboundedC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq, Element seq ~ Char) =&gt;
ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#linesUnbounded"><span class="hs-identifier hs-var">CC.linesUnbounded</span></a></span><span>
</span><span id="line-1173"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedC"><span class="hs-pragma hs-type">linesUnboundedC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1174"></span><span>
</span><span id="line-1175"></span><span class="hs-comment">-- | Same as 'linesUnbounded', but for ASCII/binary data.</span><span>
</span><span id="line-1176"></span><span class="hs-comment">--</span><span>
</span><span id="line-1177"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1178"></span><span id="local-6989586621679138322"><span id="local-6989586621679138323"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedAsciiC"><span class="hs-identifier hs-type">linesUnboundedAsciiC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138323"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Seq.IsSequence</span></span><span> </span><span class="annot"><a href="#local-6989586621679138322"><span class="hs-identifier hs-type">seq</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Element</span></span><span> </span><span class="annot"><a href="#local-6989586621679138322"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word8</span></span><span class="hs-special">)</span><span>
</span><span id="line-1179"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138322"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138322"><span class="hs-identifier hs-type">seq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138323"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-1180"></span><span id="linesUnboundedAsciiC"><span class="annot"><span class="annottext">linesUnboundedAsciiC :: ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedAsciiC"><span class="hs-identifier hs-var hs-var">linesUnboundedAsciiC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ConduitT seq seq m ()
forall (m :: * -&gt; *) seq.
(Monad m, IsSequence seq, Element seq ~ Word8) =&gt;
ConduitT seq seq m ()
</span><a href="Data.Conduit.Combinators.html#linesUnboundedAscii"><span class="hs-identifier hs-var">CC.linesUnboundedAscii</span></a></span><span>
</span><span id="line-1181"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#linesUnboundedAsciiC"><span class="hs-pragma hs-type">linesUnboundedAsciiC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1182"></span><span>
</span><span id="line-1183"></span><span class="hs-comment">-- | Generally speaking, yielding values from inside a Conduit requires</span><span>
</span><span id="line-1184"></span><span class="hs-comment">-- some allocation for constructors. This can introduce an overhead,</span><span>
</span><span id="line-1185"></span><span class="hs-comment">-- similar to the overhead needed to represent a list of values instead of</span><span>
</span><span id="line-1186"></span><span class="hs-comment">-- a vector. This overhead is even more severe when talking about unboxed</span><span>
</span><span id="line-1187"></span><span class="hs-comment">-- values.</span><span>
</span><span id="line-1188"></span><span class="hs-comment">--</span><span>
</span><span id="line-1189"></span><span class="hs-comment">-- This combinator allows you to overcome this overhead, and efficiently</span><span>
</span><span id="line-1190"></span><span class="hs-comment">-- fill up vectors. It takes two parameters. The first is the size of each</span><span>
</span><span id="line-1191"></span><span class="hs-comment">-- mutable vector to be allocated. The second is a function. The function</span><span>
</span><span id="line-1192"></span><span class="hs-comment">-- takes an argument which will yield the next value into a mutable</span><span>
</span><span id="line-1193"></span><span class="hs-comment">-- vector.</span><span>
</span><span id="line-1194"></span><span class="hs-comment">--</span><span>
</span><span id="line-1195"></span><span class="hs-comment">-- Under the surface, this function uses a number of tricks to get high</span><span>
</span><span id="line-1196"></span><span class="hs-comment">-- performance. For more information on both usage and implementation,</span><span>
</span><span id="line-1197"></span><span class="hs-comment">-- please see:</span><span>
</span><span id="line-1198"></span><span class="hs-comment">-- &lt;https://www.fpcomplete.com/user/snoyberg/library-documentation/vectorbuilder&gt;</span><span>
</span><span id="line-1199"></span><span class="hs-comment">--</span><span>
</span><span id="line-1200"></span><span class="hs-comment">-- @since 1.3.0</span><span>
</span><span id="line-1201"></span><span id="local-6989586621679138315"><span id="local-6989586621679138316"><span id="local-6989586621679138317"><span id="local-6989586621679138318"><span id="local-6989586621679138319"><span id="local-6989586621679138320"><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#vectorBuilderC"><span class="hs-identifier hs-type">vectorBuilderC</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PrimMonad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138320"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">V.Vector</span></span><span> </span><span class="annot"><a href="#local-6989586621679138319"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138318"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">PrimMonad</span></span><span> </span><span class="annot"><a href="#local-6989586621679138317"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">PrimState</span></span><span> </span><span class="annot"><a href="#local-6989586621679138320"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">PrimState</span></span><span> </span><span class="annot"><a href="#local-6989586621679138317"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1202"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-comment">-- ^ size</span><span>
</span><span id="line-1203"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138318"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679138317"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138316"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="annot"><a href="#local-6989586621679138320"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138315"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1204"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.Conduit.Internal.Conduit.html#ConduitT"><span class="hs-identifier hs-type">ConduitT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138316"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679138319"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138318"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679138320"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679138315"><span class="hs-identifier hs-type">r</span></a></span></span></span></span></span></span></span><span>
</span><span id="line-1205"></span><span id="vectorBuilderC"><span class="annot"><span class="annottext">vectorBuilderC :: Int -&gt; ((e -&gt; n ()) -&gt; ConduitT i Void m r) -&gt; ConduitT i (v e) m r
</span><a href="Data.Conduit.Combinators.Unqualified.html#vectorBuilderC"><span class="hs-identifier hs-var hs-var">vectorBuilderC</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ((e -&gt; n ()) -&gt; ConduitT i Void m r) -&gt; ConduitT i (v e) m r
forall (m :: * -&gt; *) (n :: * -&gt; *) (v :: * -&gt; *) e i r.
(PrimMonad m, PrimMonad n, Vector v e,
 PrimState m ~ PrimState n) =&gt;
Int -&gt; ((e -&gt; n ()) -&gt; ConduitT i Void m r) -&gt; ConduitT i (v e) m r
</span><a href="Data.Conduit.Combinators.html#vectorBuilder"><span class="hs-identifier hs-var">CC.vectorBuilder</span></a></span><span>
</span><span id="line-1206"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Conduit.Combinators.Unqualified.html#vectorBuilderC"><span class="hs-pragma hs-type">vectorBuilderC</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-1207"></span></pre></body></html>