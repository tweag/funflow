-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A content-addressed storage
--   
--   A content-addressed storage supporting a remote caching. The API
--   mainly consists of the cacheKleisliIO function which takes a (a -&gt;
--   m b) function and runs it only if the store doesn't already contain a
--   result for it. Part of the funflow ecosystem.
@package cas-store
@version 1.1.0


-- | Thread and process write lock.
--   
--   Allows synchronisation between threads and processes. Uses an
--   <a>MVar</a> for synchronisation between threads and fcntl write locks
--   for synchronisation between processes.
--   
--   Only ever have one <a>Lock</a> object per lock file per process!
module Data.CAS.Lock

-- | Thread and process write lock.
--   
--   Only ever have one <a>Lock</a> object per lock file per process!
data Lock

-- | Open the lock file and create a lock object.
--   
--   This does not acquire the lock.
--   
--   Only ever have one <a>Lock</a> object per lock file per process!
openLock :: Path Abs Dir -> IO Lock

-- | Close the lock file.
--   
--   Does not release the lock.
--   
--   Blocks if the lock is taken.
closeLock :: Lock -> IO ()

-- | Acquire the lock for the duration of the given action and release
--   after.
withLock :: MonadUnliftIO m => Lock -> m a -> m a


-- | This module defines the remote caching mechanism of funflow which is
--   used to keep several funflow stores (possibly on different machines)
--   in sync.
module Data.CAS.RemoteCache

-- | A simple mechanism for remote-caching.
--   
--   Provides a way to push a path to the cache and pull it back.
--   
--   No assumption is made on the availability of a store path. In
--   particular, pushing a path to the cache doesn't mean that we can pull
--   it back.
class Monad m => Cacher m a
push :: Cacher m a => a -> ContentHash -> Maybe ContentHash -> Path Abs Dir -> m PushResult
pull :: Cacher m a => a -> ContentHash -> Path Abs Dir -> m (PullResult ())

-- | The result of a tentative pull from the remote cache
data PullResult a
PullOK :: a -> PullResult a
NotInCache :: PullResult a
PullError :: String -> PullResult a

-- | The result of a tentative push to the remote cache
data PushResult
PushOK :: PushResult
PushError :: String -> PushResult
data AliasResult
AliasOK :: AliasResult
TargetNotInCache :: AliasResult
AliasError :: String -> AliasResult

-- | A dummy remote cache implementation which does nothing
data NoCache
NoCache :: NoCache
memoryCache :: MonadIO m => m MemoryCache
pullAsArchive :: MonadIO m => (ContentHash -> m (PullResult ByteString)) -> ContentHash -> Path Abs Dir -> m (PullResult ())

-- | Push the path as an archive to the remote cache
pushAsArchive :: MonadIO m => (ContentHash -> ContentHash -> m (Either String ())) -> (ContentHash -> ByteString -> m PushResult) -> ContentHash -> Maybe ContentHash -> Path Abs Dir -> m PushResult
instance GHC.Show.Show a => GHC.Show.Show (Data.CAS.RemoteCache.PullResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.CAS.RemoteCache.PullResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.CAS.RemoteCache.PullResult a)
instance GHC.Show.Show Data.CAS.RemoteCache.PushResult
instance GHC.Classes.Ord Data.CAS.RemoteCache.PushResult
instance GHC.Classes.Eq Data.CAS.RemoteCache.PushResult
instance Control.Monad.IO.Class.MonadIO m => Data.CAS.RemoteCache.Cacher m Data.CAS.RemoteCache.MemoryCache
instance GHC.Base.Monad m => Data.CAS.RemoteCache.Cacher m Data.CAS.RemoteCache.NoCache
instance Data.CAS.RemoteCache.Cacher m a => Data.CAS.RemoteCache.Cacher m (GHC.Maybe.Maybe a)


-- | Dedicated module for orphan instances.
module Data.CAS.StoreOrphans
instance Data.Store.Impl.Store (Path.Internal.Path Path.Posix.Abs Path.Posix.File)
instance Data.Store.Impl.Store (Path.Internal.Path Path.Posix.Abs Path.Posix.Dir)
instance Data.Store.Impl.Store (Path.Internal.Path Path.Posix.Rel Path.Posix.File)
instance Data.Store.Impl.Store (Path.Internal.Path Path.Posix.Rel Path.Posix.Dir)
instance Data.Store.Impl.Store Data.CAS.ContentHashable.ContentHash
instance Data.Store.Impl.Store Data.CAS.ContentHashable.ExternallyAssuredFile
instance Data.Store.Impl.Store Data.CAS.ContentHashable.ExternallyAssuredDirectory


-- | Hash addressed store in file system.
--   
--   Associates a key (<a>ContentHash</a>) with an item in the store. An
--   item can either be <a>Missing</a>, <a>Pending</a>, or <a>Complete</a>.
--   The state is persisted in the file system.
--   
--   Items are stored under a path derived from their hash. Therefore,
--   there can be no two copies of the same item in the store. If two keys
--   are associated with the same item, then there will be only one copy of
--   that item in the store.
--   
--   The store is thread-safe and multi-process safe.
--   
--   It is assumed that the user that the process is running under is the
--   owner of the store root, or has permission to create it if missing.
--   
--   It is assumed that the store root and its immediate contents are not
--   modified externally. The contents of pending items may be modified
--   externally.
--   
--   <b>Implementation notes:</b>
--   
--   The hash of an item can only be determined once it is completed. If
--   that hash already exists in the store, then the new item is discarded.
--   
--   Store state is persisted in the file-system:
--   
--   <ul>
--   <li>Pending items are stored writable under the path
--   <tt>pending-&lt;key&gt;</tt>.</li>
--   <li>Complete items are stored read-only under the path
--   <tt>item-&lt;hash&gt;</tt>, with a link under
--   <tt>complete-&lt;key&gt;</tt> pointing to that directory.</li>
--   </ul>
module Data.CAS.ContentStore

-- | Open the store under the given root and perform the given action.
--   Closes the store once the action is complete
--   
--   See also: <a>open</a>
withStore :: (MonadIO m, MonadMask m) => Path Abs Dir -> (ContentStore -> m a) -> m a

-- | <tt>open root</tt> opens a store under the given root directory.
--   
--   The root directory is created if necessary.
--   
--   It is not safe to have multiple store objects refer to the same root
--   directory.
open :: Path Abs Dir -> IO ContentStore

-- | Free the resources associated with the given store object.
--   
--   The store object may not be used afterwards.
close :: ContentStore -> IO ()

-- | A cacher is responsible for controlling how steps are cached.
data CacherM m i o

-- | This step cannot be cached (default).
NoCache :: CacherM m i o
Cache :: (Int -> i -> m ContentHash) -> (o -> ByteString) -> (ByteString -> o) -> CacherM m i o

-- | Function to encode the input into a content hash. This function
--   additionally takes an <tt>identities</tt> which gets incorporated into
--   the cacher.
[cacherKey] :: CacherM m i o -> Int -> i -> m ContentHash
[cacherStoreValue] :: CacherM m i o -> o -> ByteString

-- | Attempt to read the cache value back. May throw exceptions.
[cacherReadValue] :: CacherM m i o -> ByteString -> o

-- | A pure <a>CacherM</a>
type Cacher = CacherM Identity

-- | Constructs a <a>Cacher</a> that will use hashability of input and
--   serializability of output to make a step cacheable
defaultCacherWithIdent :: forall m i o. (ContentHashable m i, Store o) => Int -> CacherM m i o

-- | Looks for a <tt>CacherM IO</tt>, then lifts it
defaultIOCacherWithIdent :: (MonadIO m, ContentHashable IO i, Store o) => Int -> CacherM m i o

-- | Caches a Kleisli of some MonadIO action in the store given the
--   required properties
cacheKleisliIO :: (MonadIO m, MonadUnliftIO m, MonadMask m, Cacher m remoteCache) => Maybe Int -> CacherM m i o -> ContentStore -> remoteCache -> (i -> m o) -> i -> m o

-- | Caches an action that writes content-addressed data to the store.
--   Returns the Item of the written content.
putInStore :: (MonadIO m, MonadMask m, MonadUnliftIO m, Cacher m remoteCacher, ContentHashable IO t) => ContentStore -> remoteCacher -> (ContentHash -> m ()) -> (Path Abs Dir -> t -> m ()) -> t -> m Item

-- | The absolute path to content within the store.
contentPath :: ContentStore -> Content t -> Path Abs t

-- | List all elements in the store <tt>(pending keys, completed keys,
--   completed items)</tt>.
listAll :: MonadIO m => ContentStore -> m ([ContentHash], [ContentHash], [Item])

-- | List all pending keys in the store.
listPending :: MonadIO m => ContentStore -> m [ContentHash]

-- | List all completed keys in the store.
listComplete :: MonadIO m => ContentStore -> m [ContentHash]

-- | List all completed items in the store.
listItems :: MonadIO m => ContentStore -> m [Item]

-- | Query the state of the item under the given key.
query :: MonadIO m => ContentStore -> ContentHash -> m (Status () () ())

-- | Check if there is no complete or pending item under the given key.
isMissing :: MonadIO m => ContentStore -> ContentHash -> m Bool

-- | Check if there is a pending item under the given key.
isPending :: MonadIO m => ContentStore -> ContentHash -> m Bool

-- | Check if there is a completed item under the given key.
isComplete :: MonadIO m => ContentStore -> ContentHash -> m Bool

-- | Query the state under the given key and return the item if completed.
--   Doesn't block if the item is pending.
lookup :: MonadIO m => ContentStore -> ContentHash -> m (Status () () Item)

-- | Query the state under the given key and return the item if completed.
--   Return an <a>Async</a> to await an update, if pending.
lookupOrWait :: MonadIO m => ContentStore -> ContentHash -> m (Status () (Async Update) Item)

-- | Query the state under the given key and return the item once
--   completed. Blocks if the item is pending. Returns <a>Nothing</a> if
--   the item is missing, or failed to be completed.
waitUntilComplete :: MonadIO m => ContentStore -> ContentHash -> m (Maybe Item)

-- | Runs a computation only if the ContentHash isn't already associated to
--   an entry in the store
cacheComputation :: (MonadIO m, MonadUnliftIO m, MonadMask m, Cacher m remoteCache) => ContentStore -> remoteCache -> m () -> ContentHash -> (Path Abs Dir -> m a) -> m (Maybe a, Item)

-- | Atomically query the state under the given key and mark pending if
--   missing.
constructIfMissing :: (MonadIO m, MonadUnliftIO m, MonadMask m, Cacher m remoteCache) => ContentStore -> remoteCache -> ContentHash -> m (Status (Path Abs Dir) () Item)

-- | Atomically query the state under the given key and mark pending if
--   missing. Execute the given function to construct the item, mark as
--   complete on success and remove on failure. Forcibly removes if an
--   uncaught exception occurs during item construction.
withConstructIfMissing :: (MonadIO m, MonadUnliftIO m, MonadMask m, Cacher m remoteCache) => ContentStore -> remoteCache -> m () -> ContentHash -> (Path Abs Dir -> m (Either e a)) -> m (Status e () (Maybe a, Item))

-- | Mark a non-existent item as pending.
--   
--   Creates the build directory and returns its path.
--   
--   See also: <a>constructIfMissing</a>.
markPending :: MonadIO m => ContentStore -> ContentHash -> m (Path Abs Dir)

-- | Mark a pending item as complete.
markComplete :: MonadIO m => ContentStore -> ContentHash -> m Item

-- | Remove a pending item.
--   
--   It is the callers responsibility to ensure that no other threads or
--   processes will attempt to access the item's contents afterwards.
removeFailed :: MonadIO m => ContentStore -> ContentHash -> m ()

-- | Remove a key association independent of the corresponding item state.
--   Do nothing if no item exists under the given key.
--   
--   It is the callers responsibility to ensure that no other threads or
--   processes will attempt to access the contents afterwards.
--   
--   Note, this will leave an orphan item behind if no other keys point to
--   it. There is no garbage collection mechanism in place at the moment.
removeForcibly :: MonadIO m => ContentStore -> ContentHash -> m ()

-- | Remove a completed item in the store. Do nothing if not completed.
--   
--   It is the callers responsibility to ensure that no other threads or
--   processes will attempt to access the contents afterwards.
--   
--   Note, this will leave keys pointing to that item dangling. There is no
--   garbage collection mechanism in place at the moment.
removeItemForcibly :: MonadIO m => ContentStore -> Item -> m ()

-- | Link the given alias to the given item. If the alias existed before it
--   is overwritten.
assignAlias :: MonadIO m => ContentStore -> Alias -> Item -> m ()

-- | Lookup an item under the given alias. Returns <a>Nothing</a> if the
--   alias does not exist.
lookupAlias :: MonadIO m => ContentStore -> Alias -> m (Maybe Item)

-- | Remove the given alias.
removeAlias :: MonadIO m => ContentStore -> Alias -> m ()

-- | List all aliases and the respective items.
listAliases :: MonadIO m => ContentStore -> m [(Alias, Item)]

-- | Get all hashes that resulted in the given item.
getBackReferences :: MonadIO m => ContentStore -> Item -> m [ContentHash]

-- | Define the input items to a subtree.
setInputs :: MonadIO m => ContentStore -> ContentHash -> [Item] -> m ()

-- | Get the input items to a subtree if any were defined.
getInputs :: MonadIO m => ContentStore -> ContentHash -> m [Item]

-- | Set a metadata entry on an item.
setMetadata :: (ToField k, ToField v, MonadIO m) => ContentStore -> ContentHash -> k -> v -> m ()

-- | Retrieve a metadata entry on an item, or <a>Nothing</a> if missing.
getMetadata :: (ToField k, FromField v, MonadIO m) => ContentStore -> ContentHash -> k -> m (Maybe v)

-- | Create and open a new metadata file on a pending item in write mode.
createMetadataFile :: MonadIO m => ContentStore -> ContentHash -> Path Rel File -> m (Path Abs File, Handle)

-- | Return the path to a metadata file if it exists.
getMetadataFile :: MonadIO m => ContentStore -> ContentHash -> Path Rel File -> m (Maybe (Path Abs File))
itemHash :: Item -> ContentHash

-- | The store path of a completed item.
itemPath :: ContentStore -> Item -> Path Abs Dir

-- | The scoped path to a content item within the store.
itemRelPath :: Item -> Path Rel Dir

-- | Store item containing the given content.
contentItem :: Content t -> Item
contentFilename :: Content File -> Path Rel File

-- | The root directory of the store.
root :: ContentStore -> Path Abs Dir

-- | A hash addressed store on the file system.
data ContentStore

-- | A completed item in the <a>ContentStore</a>.
data Item

-- | File or directory within a content store <a>Item</a>.
data Content t
[All] :: Item -> Content Dir
[:</>] :: Item -> Path Rel t -> Content t
infixr 5 :</>

-- | Append to the path within a store item.
(^</>) :: Content Dir -> Path Rel t -> Content t
infixl 4 ^</>
newtype Alias
Alias :: Text -> Alias
[unAlias] :: Alias -> Text

-- | Status of an item in the store.
data Status missing pending complete

-- | The item does not exist, yet.
Missing :: missing -> Status missing pending complete

-- | The item is under construction and not ready for consumption.
Pending :: pending -> Status missing pending complete

-- | The item is complete and ready for consumption.
Complete :: complete -> Status missing pending complete
type Status_ = Status () () ()

-- | Update about the status of a pending item.
data Update

-- | The item is now completed and ready for consumption.
Completed :: Item -> Update

-- | Constructing the item failed.
Failed :: Update

-- | Errors that can occur when interacting with the store.
data StoreError

-- | An item is not under construction when it should be.
NotPending :: ContentHash -> StoreError

-- | An item is already under construction when it should be missing.
AlreadyPending :: ContentHash -> StoreError

-- | An item is already complete when it shouldn't be.
AlreadyComplete :: ContentHash -> StoreError

-- | The link under the given hash points to an invalid path.
CorruptedLink :: ContentHash -> FilePath -> StoreError

-- | A failure occurred while waiting for the item to be constructed.
FailedToConstruct :: ContentHash -> StoreError

-- | <tt>IncompatibleStoreVersion storeDir actual expected</tt> The given
--   store has a version number that is incompatible.
IncompatibleStoreVersion :: Path Abs Dir -> Int -> Int -> StoreError

-- | <tt>MalformedMetadataEntry hash key</tt> The metadata entry for the
--   give <tt>hash</tt>, <tt>key</tt> pair is malformed.
MalformedMetadataEntry :: ContentHash -> SQLData -> StoreError
instance (GHC.Show.Show missing, GHC.Show.Show pending, GHC.Show.Show complete) => GHC.Show.Show (Data.CAS.ContentStore.Status missing pending complete)
instance (GHC.Classes.Eq missing, GHC.Classes.Eq pending, GHC.Classes.Eq complete) => GHC.Classes.Eq (Data.CAS.ContentStore.Status missing pending complete)
instance GHC.Show.Show Data.CAS.ContentStore.StoreError
instance GHC.Generics.Generic Data.CAS.ContentStore.Item
instance GHC.Show.Show Data.CAS.ContentStore.Item
instance GHC.Classes.Ord Data.CAS.ContentStore.Item
instance GHC.Classes.Eq Data.CAS.ContentStore.Item
instance GHC.Show.Show Data.CAS.ContentStore.Update
instance GHC.Classes.Eq Data.CAS.ContentStore.Update
instance Data.Store.Impl.Store Data.CAS.ContentStore.Alias
instance Database.SQLite.Simple.ToField.ToField Data.CAS.ContentStore.Alias
instance Database.SQLite.Simple.FromField.FromField Data.CAS.ContentStore.Alias
instance GHC.Show.Show Data.CAS.ContentStore.Alias
instance GHC.Classes.Ord Data.CAS.ContentStore.Alias
instance GHC.Classes.Eq Data.CAS.ContentStore.Alias
instance Data.CAS.ContentHashable.ContentHashable GHC.Types.IO Data.CAS.ContentStore.Alias
instance GHC.Classes.Eq (Data.CAS.ContentStore.Content t)
instance GHC.Show.Show (Data.CAS.ContentStore.Content t)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m (Data.CAS.ContentStore.Content Path.Posix.Dir)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m (Data.CAS.ContentStore.Content Path.Posix.File)
instance GHC.Base.Monad m => Data.CAS.ContentHashable.ContentHashable m Data.CAS.ContentStore.Item
instance Data.Aeson.Types.FromJSON.FromJSON Data.CAS.ContentStore.Item
instance Data.Aeson.Types.ToJSON.ToJSON Data.CAS.ContentStore.Item
instance Data.Hashable.Class.Hashable Data.CAS.ContentStore.Item
instance Data.Store.Impl.Store Data.CAS.ContentStore.Item
instance GHC.Exception.Type.Exception Data.CAS.ContentStore.StoreError
instance Database.SQLite.Simple.FromField.FromField Data.CAS.ContentHashable.ContentHash
instance Database.SQLite.Simple.ToField.ToField Data.CAS.ContentHashable.ContentHash
