-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple ANSI terminal support, with Windows compatibility
--   
--   ANSI terminal support for Haskell: allows cursor movement, screen
--   clearing, color output, showing or hiding the cursor, and changing the
--   title. Works on UNIX and Windows.
@package ansi-terminal
@version 0.11


-- | The 'ANSI' standards refer to the visual style of displaying
--   characters as their 'graphic rendition'. The style includes the color
--   of a character or its background, the intensity (bold, normal or
--   faint) of a character, or whether the character is italic or
--   underlined (single or double), blinking (slowly or rapidly) or visible
--   or not. The 'ANSI' codes to establish the graphic rendition for
--   subsequent text are referred to as SELECT GRAPHIC RENDITION (SGR).
--   
--   This module exports types and functions used to represent SGR aspects.
--   See also <a>setSGR</a> and related functions.
module System.Console.ANSI.Types

-- | ANSI Select Graphic Rendition (SGR) command
--   
--   In respect of colors, there are three alternative commands:
--   
--   <ol>
--   <li>the 'ANSI' standards allow for eight standard colors (with two
--   intensities). Windows and many other terminals (including xterm) allow
--   the user to redefine the standard colors (so, for example <a>Vivid</a>
--   <a>Green</a> may not correspond to bright green;</li>
--   <li>an extension of the standard that allows true colors (24 bit color
--   depth) in RGB space. This is usually the best alternative for more
--   colors; and</li>
--   <li>another extension that allows a palette of 256 colors, each color
--   specified by an index. Xterm provides a protocol for a palette of 256
--   colors that many other terminals, including Windows 10, follow. Some
--   terminals (including xterm) allow the user to redefine some or all of
--   the palette colors.</li>
--   </ol>
data SGR

-- | Default rendition, cancels the effect of any preceding occurrence of
--   SGR (implementation-defined)
Reset :: SGR

-- | Set the character intensity. Partially supported natively on Windows
--   10
SetConsoleIntensity :: !ConsoleIntensity -> SGR

-- | Set italicized. Not widely supported: sometimes treated as swapping
--   foreground and background. Not supported natively on Windows 10
SetItalicized :: !Bool -> SGR

-- | Set or clear underlining. Partially supported natively on Windows 10
SetUnderlining :: !Underlining -> SGR

-- | Set or clear character blinking. Not supported natively on Windows 10
SetBlinkSpeed :: !BlinkSpeed -> SGR

-- | Set revealed or concealed. Not widely supported. Not supported
--   natively on Windows 10
SetVisible :: !Bool -> SGR

-- | Set negative or positive image. Supported natively on Windows 10
SetSwapForegroundBackground :: !Bool -> SGR

-- | Set a color from the standard palette of 16 colors (8 colors by 2
--   color intensities). Many terminals allow the palette colors to be
--   customised
SetColor :: !ConsoleLayer -> !ColorIntensity -> !Color -> SGR

-- | Set a true color (24 bit color depth). Supported natively on Windows
--   10 from the Creators Update (April 2017)
SetRGBColor :: !ConsoleLayer -> !Colour Float -> SGR

-- | Set a color from a palette of 256 colors using a numerical index
--   (0-based). Supported natively on Windows 10 from the Creators Update
--   (April 2017) but not on legacy Windows native terminals. See
--   <a>xtermSystem</a>, <a>xterm6LevelRGB</a> and <a>xterm24LevelGray</a>
--   to construct indices based on xterm's standard protocol for a
--   256-color palette.
SetPaletteColor :: !ConsoleLayer -> !Word8 -> SGR

-- | Set a color to the default (implementation-defined)
SetDefaultColor :: !ConsoleLayer -> SGR

-- | ANSI colors can be set on two different layers
data ConsoleLayer
Foreground :: ConsoleLayer
Background :: ConsoleLayer

-- | ANSI's eight standard colors. They come in two intensities, which are
--   controlled by <a>ColorIntensity</a>. Many terminals allow the colors
--   of the standard palette to be customised, so that, for example,
--   <tt>setSGR [ SetColor Foreground Vivid Green ]</tt> may not result in
--   bright green characters.
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | ANSI's standard colors come in two intensities
data ColorIntensity
Dull :: ColorIntensity
Vivid :: ColorIntensity

-- | ANSI general console intensity: usually treated as setting the font
--   style (e.g. <a>BoldIntensity</a> causes text to be bold)
data ConsoleIntensity
BoldIntensity :: ConsoleIntensity

-- | Not widely supported: sometimes treated as concealing text. Not
--   supported natively on Windows 10
FaintIntensity :: ConsoleIntensity
NormalIntensity :: ConsoleIntensity

-- | ANSI text underlining
data Underlining
SingleUnderline :: Underlining

-- | Not widely supported. Not supported natively on Windows 10
DoubleUnderline :: Underlining
NoUnderline :: Underlining

-- | ANSI blink speeds: values other than <a>NoBlink</a> are not widely
--   supported
data BlinkSpeed

-- | Less than 150 blinks per minute
SlowBlink :: BlinkSpeed

-- | More than 150 blinks per minute
RapidBlink :: BlinkSpeed
NoBlink :: BlinkSpeed

-- | Given xterm's standard protocol for a 256-color palette, returns the
--   index to that part of the palette which is a 6 level (6x6x6) color
--   cube of 216 RGB colors. Throws an error if any of the red, green or
--   blue channels is outside the range 0 to 5. An example of use is:
--   
--   <pre>
--   &gt;&gt;&gt; setSGR [ SetPaletteColor $ xterm6LevelRGB 5 2 0 ] -- Dark Orange
--   </pre>
xterm6LevelRGB :: Int -> Int -> Int -> Word8

-- | Given xterm's standard protocol for a 256-color palette, returns the
--   index to that part of the palette which is a spectrum of 24 grays,
--   from dark gray (0) to near white (23) (black and white are themselves
--   excluded). Throws an error if the gray is outside of the range 0 to
--   23. An example of use is:
--   
--   <pre>
--   &gt;&gt;&gt; setSGR [ SetPaletteColor $ xterm24LevelGray 12 ] -- Gray50
--   </pre>
xterm24LevelGray :: Int -> Word8

-- | Given xterm's standard protocol for a 256-color palette, returns the
--   index to that part of the palette which corresponds to the 'ANSI'
--   standards' 16 standard, or 'system', colors (eight colors in two
--   intensities). An example of use is:
--   
--   <pre>
--   &gt;&gt;&gt; setSGR [ SetPaletteColor $ xtermSystem Vivid Green ]
--   </pre>
xtermSystem :: ColorIntensity -> Color -> Word8
instance GHC.Ix.Ix System.Console.ANSI.Types.Color
instance GHC.Read.Read System.Console.ANSI.Types.Color
instance GHC.Show.Show System.Console.ANSI.Types.Color
instance GHC.Enum.Enum System.Console.ANSI.Types.Color
instance GHC.Enum.Bounded System.Console.ANSI.Types.Color
instance GHC.Classes.Ord System.Console.ANSI.Types.Color
instance GHC.Classes.Eq System.Console.ANSI.Types.Color
instance GHC.Ix.Ix System.Console.ANSI.Types.ColorIntensity
instance GHC.Read.Read System.Console.ANSI.Types.ColorIntensity
instance GHC.Show.Show System.Console.ANSI.Types.ColorIntensity
instance GHC.Enum.Enum System.Console.ANSI.Types.ColorIntensity
instance GHC.Enum.Bounded System.Console.ANSI.Types.ColorIntensity
instance GHC.Classes.Ord System.Console.ANSI.Types.ColorIntensity
instance GHC.Classes.Eq System.Console.ANSI.Types.ColorIntensity
instance GHC.Ix.Ix System.Console.ANSI.Types.ConsoleLayer
instance GHC.Read.Read System.Console.ANSI.Types.ConsoleLayer
instance GHC.Show.Show System.Console.ANSI.Types.ConsoleLayer
instance GHC.Enum.Enum System.Console.ANSI.Types.ConsoleLayer
instance GHC.Enum.Bounded System.Console.ANSI.Types.ConsoleLayer
instance GHC.Classes.Ord System.Console.ANSI.Types.ConsoleLayer
instance GHC.Classes.Eq System.Console.ANSI.Types.ConsoleLayer
instance GHC.Ix.Ix System.Console.ANSI.Types.BlinkSpeed
instance GHC.Read.Read System.Console.ANSI.Types.BlinkSpeed
instance GHC.Show.Show System.Console.ANSI.Types.BlinkSpeed
instance GHC.Enum.Enum System.Console.ANSI.Types.BlinkSpeed
instance GHC.Enum.Bounded System.Console.ANSI.Types.BlinkSpeed
instance GHC.Classes.Ord System.Console.ANSI.Types.BlinkSpeed
instance GHC.Classes.Eq System.Console.ANSI.Types.BlinkSpeed
instance GHC.Ix.Ix System.Console.ANSI.Types.Underlining
instance GHC.Read.Read System.Console.ANSI.Types.Underlining
instance GHC.Show.Show System.Console.ANSI.Types.Underlining
instance GHC.Enum.Enum System.Console.ANSI.Types.Underlining
instance GHC.Enum.Bounded System.Console.ANSI.Types.Underlining
instance GHC.Classes.Ord System.Console.ANSI.Types.Underlining
instance GHC.Classes.Eq System.Console.ANSI.Types.Underlining
instance GHC.Ix.Ix System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Read.Read System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Show.Show System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Enum.Enum System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Enum.Bounded System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Classes.Ord System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Classes.Eq System.Console.ANSI.Types.ConsoleIntensity
instance GHC.Read.Read System.Console.ANSI.Types.SGR
instance GHC.Show.Show System.Console.ANSI.Types.SGR
instance GHC.Classes.Eq System.Console.ANSI.Types.SGR


-- | This module exports functions that return <a>String</a> values
--   containing codes in accordance with the 'ANSI' standards for control
--   character sequences described in the documentation of module
--   <a>System.Console.ANSI</a>.
--   
--   The module <a>System.Console.ANSI</a> exports functions with the same
--   names as those in this module. On some versions of Windows, the
--   terminal in use may not be ANSI-capable. When that is the case, the
--   same-named functions exported by module <a>System.Console.ANSI</a>
--   return "", for the reasons set out in the documentation of that
--   module.
--   
--   Consequently, if module <a>System.Console.ANSI</a> is also imported,
--   this module is intended to be imported qualified, to avoid name
--   clashes with those functions. For example:
--   
--   <pre>
--   import qualified System.Console.ANSI.Codes as ANSI
--   </pre>
module System.Console.ANSI.Codes
cursorUpCode :: Int -> String
cursorDownCode :: Int -> String
cursorForwardCode :: Int -> String
cursorBackwardCode :: Int -> String
cursorUpLineCode :: Int -> String
cursorDownLineCode :: Int -> String

-- | Code to move the cursor to the specified column. The column numbering
--   is 0-based (that is, the left-most column is numbered 0).
setCursorColumnCode :: Int -> String

-- | Code to move the cursor to the specified position (row and column).
--   The position is 0-based (that is, the top-left corner is at row 0
--   column 0).
setCursorPositionCode :: Int -> Int -> String

saveCursorCode :: String

restoreCursorCode :: String

-- | Code to emit the cursor position into the console input stream,
--   immediately after being recognised on the output stream, as: <tt>ESC [
--   &lt;cursor row&gt; ; &lt;cursor column&gt; R</tt>
--   
--   Note that the information that is emitted is 1-based (the top-left
--   corner is at row 1 column 1) but <a>setCursorPositionCode</a> is
--   0-based.
--   
--   In isolation of <tt>getReportedCursorPosition</tt> or
--   <tt>getCursorPosition</tt>, this function may be of limited use on
--   Windows operating systems because of difficulties in obtaining the
--   data emitted into the console input stream. The function
--   <tt>hGetBufNonBlocking</tt> in module <a>System.IO</a> does not work
--   on Windows. This has been attributed to the lack of non-blocking
--   primatives in the operating system (see the GHC bug report #806 at
--   <a>https://ghc.haskell.org/trac/ghc/ticket/806</a>).
reportCursorPositionCode :: String
clearFromCursorToScreenEndCode :: String
clearFromCursorToScreenBeginningCode :: String
clearScreenCode :: String
clearFromCursorToLineEndCode :: String
clearFromCursorToLineBeginningCode :: String
clearLineCode :: String
scrollPageUpCode :: Int -> String
scrollPageDownCode :: Int -> String
setSGRCode :: [SGR] -> String
hideCursorCode :: String
showCursorCode :: String

-- | XTerm control sequence to set the Icon Name and Window Title.
setTitleCode :: String -> String

-- | <a>colorToCode</a> <tt>color</tt> returns the 0-based index of the
--   color (one of the eight colors in the ANSI standard).
colorToCode :: Color -> Int

-- | <a>csi</a> <tt>parameters controlFunction</tt>, where
--   <tt>parameters</tt> is a list of <a>Int</a>, returns the control
--   sequence comprising the control function CONTROL SEQUENCE INTRODUCER
--   (CSI) followed by the parameter(s) (separated by ';') and ending with
--   the <tt>controlFunction</tt> character(s) that identifies the control
--   function.
csi :: [Int] -> String -> String

-- | <a>sgrToCode</a> <tt>sgr</tt> returns the parameter of the SELECT
--   GRAPHIC RENDITION (SGR) aspect identified by <tt>sgr</tt>.
sgrToCode :: SGR -> [Int]


-- | Through this module, this library provides platform-independent
--   support for control character sequences following the 'ANSI' standards
--   (see further below) for terminal software that supports those
--   sequences, running on a Unix-like operating system or Windows.
--   
--   The sequences of control characters (also referred to as 'escape'
--   sequences or codes) provide a rich range of functionality for terminal
--   control, which includes:
--   
--   <ul>
--   <li>Colored text output, with control over both foreground and
--   background colors</li>
--   <li>Clearing parts of a line or the screen</li>
--   <li>Hiding or showing the cursor</li>
--   <li>Moving the cursor around</li>
--   <li>Reporting the position of the cursor</li>
--   <li>Scrolling the screen up or down</li>
--   <li>Changing the title of the terminal</li>
--   </ul>
--   
--   A terminal that supports control character sequences acts on them when
--   they are flushed from the output buffer (with a newline character
--   <tt>"\n"</tt> or, for the standard output channel, <tt>hFlush
--   stdout</tt>).
--   
--   The functions moving the cursor to an absolute position are 0-based
--   (the top-left corner is considered to be at row 0 column 0) (see
--   <a>setCursorPosition</a>) and so is <a>getCursorPosition</a>. The
--   'ANSI' standards themselves are 1-based (that is, the top-left corner
--   is considered to be at row 1 column 1) and some functions reporting
--   the position of the cursor are too (see <a>reportCursorPosition</a>).
--   
--   The native terminal software on Windows is 'Command Prompt' or
--   `PowerShell`. Before Windows 10 version 1511 (known as the 'November
--   [2015] Update' or 'Threshold 2') that software did not support such
--   control sequences. For that software, this library also provides
--   support for such sequences by using emulation.
--   
--   Terminal software other than the native software exists for Windows.
--   One example is the 'mintty' terminal emulator for 'Cygwin', 'MSYS' or
--   'MSYS2', and dervied projects, and for 'WSL' (Windows Subsystem for
--   Linux).
--   
--   The 'ANSI' standards refer to (1) standard ECMA-48 `Control Functions
--   for Coded Character Sets' (5th edition, 1991); (2) extensions in ITU-T
--   Recommendation (previously CCITT Recommendation) T.416 (03/93)
--   'Information Technology – Open Document Architecture (ODA) and
--   Interchange Format: Character Content Architectures` (also published
--   as ISO/IEC International Standard 8613-6); and (3) further extensions
--   used by 'XTerm', a terminal emulator for the X Window System. The
--   escape codes are described in a Wikipedia article at
--   <a>http://en.wikipedia.org/wiki/ANSI_escape_code</a> and those codes
--   supported on current versions of Windows at
--   <a>https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences</a>.
--   
--   The whole of the 'ANSI' standards are not supported by this library
--   but most (if not all) of the parts that are popular and well-supported
--   by terminal software are supported. Every function exported by this
--   module comes in three variants, namely:
--   
--   <ul>
--   <li>A variant that has an <tt>IO ()</tt> type and doesn't take a
--   <tt>Handle</tt> (for example, <tt>clearScreen :: IO ()</tt>). This
--   variant just outputs the `ANSI` command directly to the standard
--   output channel (<tt>stdout</tt>) and any terminal corresponding to it.
--   Commands issued like this should work as you expect on both Unix-like
--   operating systems and Windows.</li>
--   <li>An '<tt>h</tt>...' variant that has an <tt>IO ()</tt> type but
--   takes a <tt>Handle</tt> (for example, <tt>hClearScreen :: Handle -&gt;
--   IO ()</tt>). This variant outputs the `ANSI` command to the supplied
--   handle and any terminal corresponding to it. Commands issued like this
--   should also work as you expect on both Unix-like operating systems and
--   Windows.</li>
--   <li>A '...<tt>Code</tt>' variant that has a <tt>String</tt> type (for
--   example, <tt>clearScreenCode :: String</tt>). This variant outputs the
--   sequence of control characters as a <a>String</a>, which can be added
--   to any other bit of text before being output. The use of these codes
--   is generally discouraged because they will not work on legacy versions
--   of Windows where the terminal in use is not ANSI-enabled (see further
--   above). On Windows, where emulation has been necessary, these variants
--   will always output the empty string. That is done so that it is
--   possible to use them portably; for example, coloring console output on
--   the understanding that you will see colors only if you are running on
--   a Unix-like operating system or a version of Windows where emulation
--   has not been necessary. If the control characters are always required,
--   see module <a>System.Console.ANSI.Codes</a>.</li>
--   </ul>
--   
--   Example:
--   
--   <pre>
--   module Main where
--   
--   import System.Console.ANSI
--   
--   -- Set colors and write some text in those colors.
--   main :: IO ()
--   main = do
--     setSGR [SetColor Foreground Vivid Red]
--     setSGR [SetColor Background Vivid Blue]
--     putStrLn "Red-On-Blue"
--     setSGR [Reset]  -- Reset to default colour scheme
--     putStrLn "Default colors."
--   </pre>
--   
--   Another example:
--   
--   <pre>
--   module Main where
--   
--   import System.IO (hFlush, stdout)
--   import System.Console.ANSI
--   
--   main :: IO ()
--   main = do
--     setSGR [SetColor Foreground Dull Blue]
--     putStr "Enter your name: "
--     setSGR [SetColor Foreground Dull Yellow]
--     hFlush stdout  -- flush the output buffer before getLine
--     name &lt;- getLine
--     setSGR [SetColor Foreground Dull Blue]
--     putStrLn $ "Hello, " ++ name ++ "!"
--     setSGR [Reset]  -- reset to default colour scheme
--   </pre>
--   
--   For many more examples, see the project's extensive <a>Example.hs</a>
--   file.
module System.Console.ANSI
cursorUp :: Int -> IO ()
cursorDown :: Int -> IO ()
cursorForward :: Int -> IO ()
cursorBackward :: Int -> IO ()
hCursorUp :: Handle -> Int -> IO ()
hCursorDown :: Handle -> Int -> IO ()
hCursorForward :: Handle -> Int -> IO ()
hCursorBackward :: Handle -> Int -> IO ()
cursorUpCode :: Int -> String
cursorDownCode :: Int -> String
cursorForwardCode :: Int -> String
cursorBackwardCode :: Int -> String
cursorUpLine :: Int -> IO ()
cursorDownLine :: Int -> IO ()
hCursorUpLine :: Handle -> Int -> IO ()
hCursorDownLine :: Handle -> Int -> IO ()
cursorUpLineCode :: Int -> String
cursorDownLineCode :: Int -> String

-- | Move the cursor to the specified column. The column numbering is
--   0-based (that is, the left-most column is numbered 0).
setCursorColumn :: Int -> IO ()
hSetCursorColumn :: Handle -> Int -> IO ()

-- | Code to move the cursor to the specified column. The column numbering
--   is 0-based (that is, the left-most column is numbered 0).
setCursorColumnCode :: Int -> String

-- | Move the cursor to the specified position (row and column). The
--   position is 0-based (that is, the top-left corner is at row 0 column
--   0).
setCursorPosition :: Int -> Int -> IO ()
hSetCursorPosition :: Handle -> Int -> Int -> IO ()

-- | Code to move the cursor to the specified position (row and column).
--   The position is 0-based (that is, the top-left corner is at row 0
--   column 0).
setCursorPositionCode :: Int -> Int -> String

-- | Save the cursor position in memory. The only way to access the saved
--   value is with the <a>restoreCursor</a> command.
saveCursor :: IO ()
hSaveCursor :: Handle -> IO ()

saveCursorCode :: String

-- | Restore the cursor position from memory. There will be no value saved
--   in memory until the first use of the <a>saveCursor</a> command.
restoreCursor :: IO ()
hRestoreCursor :: Handle -> IO ()

restoreCursorCode :: String

-- | Looking for a way to get the cursors position? See
--   <a>getCursorPosition</a>.
--   
--   Emit the cursor position into the console input stream, immediately
--   after being recognised on the output stream, as: <tt>ESC [ &lt;cursor
--   row&gt; ; &lt;cursor column&gt; R</tt>
--   
--   Note that the information that is emitted is 1-based (the top-left
--   corner is at row 1 column 1) but <a>setCursorColumn</a> and
--   <a>setCursorPosition</a> are 0-based.
--   
--   In isolation of <a>getReportedCursorPosition</a> or
--   <a>getCursorPosition</a>, this function may be of limited use on
--   Windows operating systems because of difficulties in obtaining the
--   data emitted into the console input stream. The function
--   <tt>hGetBufNonBlocking</tt> in module <a>System.IO</a> does not work
--   on Windows. This has been attributed to the lack of non-blocking
--   primatives in the operating system (see the GHC bug report #806 at
--   <a>https://ghc.haskell.org/trac/ghc/ticket/806</a>).
reportCursorPosition :: IO ()
hReportCursorPosition :: Handle -> IO ()

-- | Code to emit the cursor position into the console input stream,
--   immediately after being recognised on the output stream, as: <tt>ESC [
--   &lt;cursor row&gt; ; &lt;cursor column&gt; R</tt>
--   
--   Note that the information that is emitted is 1-based (the top-left
--   corner is at row 1 column 1) but <a>setCursorPositionCode</a> is
--   0-based.
--   
--   In isolation of <tt>getReportedCursorPosition</tt> or
--   <tt>getCursorPosition</tt>, this function may be of limited use on
--   Windows operating systems because of difficulties in obtaining the
--   data emitted into the console input stream. The function
--   <tt>hGetBufNonBlocking</tt> in module <a>System.IO</a> does not work
--   on Windows. This has been attributed to the lack of non-blocking
--   primatives in the operating system (see the GHC bug report #806 at
--   <a>https://ghc.haskell.org/trac/ghc/ticket/806</a>).
reportCursorPositionCode :: String
clearFromCursorToScreenEnd :: IO ()
clearFromCursorToScreenBeginning :: IO ()
clearScreen :: IO ()
hClearFromCursorToScreenEnd :: Handle -> IO ()
hClearFromCursorToScreenBeginning :: Handle -> IO ()
hClearScreen :: Handle -> IO ()
clearFromCursorToScreenEndCode :: String
clearFromCursorToScreenBeginningCode :: String
clearScreenCode :: String
clearFromCursorToLineEnd :: IO ()
clearFromCursorToLineBeginning :: IO ()
clearLine :: IO ()
hClearFromCursorToLineEnd :: Handle -> IO ()
hClearFromCursorToLineBeginning :: Handle -> IO ()
hClearLine :: Handle -> IO ()
clearFromCursorToLineEndCode :: String
clearFromCursorToLineBeginningCode :: String
clearLineCode :: String

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
scrollPageUp :: Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
scrollPageDown :: Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
hScrollPageUp :: Handle -> Int -> IO ()

-- | Scroll the displayed information up or down the terminal: not widely
--   supported
hScrollPageDown :: Handle -> Int -> IO ()
scrollPageUpCode :: Int -> String
scrollPageDownCode :: Int -> String

-- | Set the Select Graphic Rendition mode
setSGR :: [SGR] -> IO ()

-- | Set the Select Graphic Rendition mode
hSetSGR :: Handle -> [SGR] -> IO ()
setSGRCode :: [SGR] -> String
hideCursor :: IO ()
showCursor :: IO ()
hHideCursor :: Handle -> IO ()
hShowCursor :: Handle -> IO ()
hideCursorCode :: String
showCursorCode :: String

-- | Set the terminal window title
setTitle :: String -> IO ()

-- | Set the terminal window title
hSetTitle :: Handle -> String -> IO ()

-- | XTerm control sequence to set the Icon Name and Window Title.
setTitleCode :: String -> String

-- | Use heuristics to determine whether the functions defined in this
--   package will work with a given handle. This function assumes that the
--   handle is writable (that is, it manages output - see
--   <a>hIsWritable</a>).
--   
--   For Unix-like operating systems, the current implementation checks
--   that: (1) the handle is a terminal; and (2) a <tt>TERM</tt>
--   environment variable is not set to <tt>dumb</tt> (which is what the
--   GNU Emacs text editor sets for its integrated terminal).
--   
--   For Windows, the current implementation performs the same checks as
--   for Unix-like operating systems and, as an alternative, checks whether
--   the handle is connected to a 'mintty' terminal. (That is because the
--   function <a>hIsTerminalDevice</a> is used to check if the handle is a
--   terminal. However, where a non-native Windows terminal (such as
--   'mintty') is implemented using redirection, that function will not
--   identify a handle to the terminal as a terminal.) On Windows 10, if
--   the handle is identified as connected to a native terminal, this
--   function does <i>not</i> enable the processing of 'ANSI' control
--   characters in output (see <a>hSupportsANSIWithoutEmulation</a>).
hSupportsANSI :: Handle -> IO Bool

-- | Some terminals (e.g. Emacs) are not fully ANSI compliant but can
--   support ANSI colors. This can be used in such cases, if colors are all
--   that is needed.
hSupportsANSIColor :: Handle -> IO Bool

-- | Use heuristics to determine whether a given handle will support 'ANSI'
--   control characters in output. (On Windows versions before Windows 10,
--   that means 'support without emulation'.)
--   
--   If the handle is not writable (that is, it cannot manage output - see
--   <a>hIsWritable</a>), then <tt>return (Just False)</tt> is returned.
--   
--   On Unix-like operating systems, with one exception, the function is
--   consistent with <a>hSupportsANSI</a>. The exception is if the handle
--   is not writable.
--   
--   On Windows, what is returned will depend on what the handle is
--   connected to and the version of the operating system. If the handle is
--   identified as connected to a 'mintty' terminal, <tt>return (Just
--   True)</tt> is returned. If it is identifed as connected to a native
--   terminal, then, on Windows 10, the processing of 'ANSI' control
--   characters will be enabled and <tt>return (Just True)</tt> returned;
--   and, on versions of Windows before Windows 10, <tt>return (Just
--   False)</tt> is returned. Otherwise, if a <tt>TERM</tt> environment
--   variable is set to <tt>dumb</tt>, <tt>return (Just False)</tt> is
--   returned. In all other cases of a writable handle, <tt>return
--   Nothing</tt> is returned; this indicates that the heuristics cannot
--   assist - the handle may be connected to a file or to another type of
--   terminal.
hSupportsANSIWithoutEmulation :: Handle -> IO (Maybe Bool)

-- | Attempts to get the reported cursor position, combining the functions
--   <a>reportCursorPosition</a>, <a>getReportedCursorPosition</a> and
--   <a>cursorPosition</a>. Any position <tt>(row, column)</tt> is
--   translated to be 0-based (that is, the top-left corner is at <tt>(0,
--   0)</tt>), consistent with <a>setCursorColumn</a> and
--   <a>setCursorPosition</a>. (Note that the information emitted into the
--   console input stream by <a>reportCursorPosition</a> is 1-based.)
--   Returns <a>Nothing</a> if any data emitted by
--   <a>reportCursorPosition</a>, obtained by
--   <a>getReportedCursorPosition</a>, cannot be parsed by
--   <a>cursorPosition</a>. Uses <a>stdout</a>. If <a>stdout</a> will be
--   redirected, see <a>hGetCursorPosition</a> for a more general function.
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
getCursorPosition :: IO (Maybe (Int, Int))

-- | Attempts to get the reported cursor position, combining the functions
--   <a>hReportCursorPosition</a> (with the specified handle),
--   <a>getReportedCursorPosition</a> and <a>cursorPosition</a>. Any
--   position <tt>(row, column)</tt> is translated to be 0-based (that is,
--   the top-left corner is at <tt>(0, 0)</tt>), consistent with
--   <a>hSetCursorColumn</a> and <a>hSetCursorPosition</a>. (Note that the
--   information emitted into the console input stream by
--   <a>hReportCursorPosition</a> is 1-based.) Returns <a>Nothing</a> if
--   any data emitted by <a>hReportCursorPosition</a>, obtained by
--   <a>getReportedCursorPosition</a>, cannot be parsed by
--   <a>cursorPosition</a>.
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
hGetCursorPosition :: Handle -> IO (Maybe (Int, Int))

-- | Attempts to get the reported cursor position data from the console
--   input stream. The function is intended to be called immediately after
--   <a>reportCursorPosition</a> (or related functions) have caused
--   characters to be emitted into the stream.
--   
--   For example, on a Unix-like operating system:
--   
--   <pre>
--   -- set no buffering (if 'no buffering' is not already set, the contents of
--   -- the buffer will be discarded, so this needs to be done before the cursor
--   -- positon is emitted)
--   hSetBuffering stdin NoBuffering
--   -- ensure that echoing is off
--   input &lt;- bracket (hGetEcho stdin) (hSetEcho stdin) $ \_ -&gt; do
--     hSetEcho stdin False
--     reportCursorPosition
--     hFlush stdout -- ensure the report cursor position code is sent to the
--                   -- operating system
--     getReportedCursorPosition
--   </pre>
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
getReportedCursorPosition :: IO String

-- | Parses the characters emitted by <a>reportCursorPosition</a> into the
--   console input stream. Returns the cursor row and column as a tuple.
--   
--   For example, if the characters emitted by <a>reportCursorPosition</a>
--   are in <a>String</a> <tt>input</tt> then the parser could be applied
--   like this:
--   
--   <pre>
--   let result = readP_to_S cursorPosition input
--   case result of
--       [] -&gt; putStrLn $ "Error: could not parse " ++ show input
--       [((row, column), _)] -&gt; putStrLn $ "The cursor was at row " ++ show row
--           ++ " and column" ++ show column ++ "."
--       (_:_) -&gt; putStrLn $ "Error: parse not unique"
--   </pre>
cursorPosition :: ReadP (Int, Int)

-- | Attempts to get the current terminal size (height in rows, width in
--   columns), by using <a>getCursorPosition</a> to query the console input
--   stream after attempting to set the cursor position beyond the bottom
--   right corner of the terminal. Uses <a>stdout</a>. If <a>stdout</a>
--   will be redirected, see <a>hGetTerminalSize</a> for a more general
--   function.
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
getTerminalSize :: IO (Maybe (Int, Int))

-- | Attempts to get the current terminal size (height in rows, width in
--   columns), by writing control character sequences to the specified
--   handle (which will typically be <a>stdout</a> or <tt>stderr</tt>) and
--   using <a>hGetCursorPosition</a> to query the console input stream
--   after attempting to set the cursor position beyond the bottom right
--   corner of the terminal.
--   
--   On Windows operating systems, the function is not supported on
--   consoles, such as mintty, that are not based on the Win32 console of
--   the Windows API. (Command Prompt and PowerShell are based on the Win32
--   console.)
hGetTerminalSize :: Handle -> IO (Maybe (Int, Int))
